{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-12-02T14:11:24.545Z","updated":"2020-12-02T14:11:24.545Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-10-12T12:20:20.000Z","updated":"2020-12-01T14:26:10.112Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人博客：Marlowe毕业学校：重庆理工大学本科专业：计算机科学与技术个人邮箱：marlowe246@qq.comGithub:Marlowe"},{"title":"所有分类","date":"2020-12-01T14:23:54.558Z","updated":"2020-12-01T14:23:54.558Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-01T14:23:54.500Z","updated":"2020-12-01T14:23:54.500Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线程池","slug":"春招面试/线程池","date":"2021-03-18T08:11:53.000Z","updated":"2021-03-18T14:37:05.109Z","comments":true,"path":"2021/03/18/春招面试/线程池/","link":"","permalink":"http://example.com/2021/03/18/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。","text":"池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。 1、为什么要用线程池？ 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 2、实现 Runnable 接口和 Callable 接口的区别Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口， 这样代码看起来会更加简洁。 工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。 Runnable.java 1234567@FunctionalInterfacepublic interface Runnable &#123; /** * 被线程执行，没有返回值也无法抛出异常 */ public abstract void run();&#125; Callable.java 123456789@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * 计算结果，或在无法这样做时抛出异常。 * @return 计算得出的结果 * @throws 如果无法计算结果，则抛出异常 */ V call() throws Exception;&#125; 3、执行 execute()方法和 submit()方法的区别是什么呢？ execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功， 并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 4、ThreadPoolExecutor 类分析ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。 123456789101112131415161718192021222324/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 4.1 ThreadPoolExecutor构造函数重要参数分析ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他常见参数: keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁； unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :饱和策略。关于饱和策略下面单独介绍一下。 4.2 ThreadPoolExecutor 饱和策略ThreadPoolExecutor 饱和策略定义: 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略: ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。 编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。 ThreadPoolExecutorDemo.java 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolExecutorDemo &#123; private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int QUEUE_CAPACITY = 100; private static final Long KEEP_ALIVE_TIME = 1L; public static void main(String[] args) &#123; //使用阿里巴巴推荐的创建线程池的方式 //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), new ThreadPoolExecutor.CallerRunsPolicy()); for (int i = 0; i &lt; 10; i++) &#123; //创建WorkerThread对象（WorkerThread类实现了Runnable 接口） Runnable worker = new MyRunnable(&quot;&quot; + i); //执行Runnable executor.execute(worker); &#125; //终止线程池 executor.shutdown(); while (!executor.isTerminated()) &#123; &#125; System.out.println(&quot;Finished all threads&quot;); &#125;&#125; 可以看到我们上面的代码指定了： corePoolSize: 核心线程数为 5。 maximumPoolSize ：最大线程数 10 keepAliveTime : 等待时间为 1L。 unit: 等待时间的单位为 TimeUnit.SECONDS。 workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100; handler:饱和策略为 CallerRunsPolicy。 5、线程池原理分析为了搞懂线程池的原理，我们需要首先分析一下 execute方法。看看它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; private final BlockingQueue&lt;Runnable&gt; workQueue; public void execute(Runnable command) &#123; // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // ctl 中保存的线程池当前的一些状态信息 int c = ctl.get(); // 下面会涉及到 3 步 操作 // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里 // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。 if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 如果当前线程池为空就新创建一个线程并执行。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command); &#125; 图解： 参考线程池","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"author":"Marlowe"},{"title":"volatile 关键字","slug":"春招面试/volatile-关键字","date":"2021-03-18T02:30:02.000Z","updated":"2021-03-18T14:37:05.101Z","comments":true,"path":"2021/03/18/春招面试/volatile-关键字/","link":"","permalink":"http://example.com/2021/03/18/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/volatile-%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"volatile 关键字相关知识点…","text":"volatile 关键字相关知识点… 1、CPU缓存模型为什么要弄一个 CPU 高速缓存呢？类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。 我们甚至可以把 内存可以看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。 总结： CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。 CPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不一致性的问题 ！ 比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。 CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。 2、讲一下 JMM(Java 内存模型)在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 所以，volatile 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。 3、并发编程的三个重要特性 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。 可见性 ： 当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。 有序性 ： 代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。 4、说说 synchronized 关键字和 volatile 关键字的区别synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！ volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。 synchronized 关键字两者都能保证。 volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 5、参考volatile 关键字","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"volatile","slug":"volatile","permalink":"http://example.com/tags/volatile/"}],"author":"Marlowe"},{"title":"synchronized相关知识点","slug":"春招面试/synchronized相关知识点","date":"2021-03-17T14:39:35.000Z","updated":"2021-03-18T14:37:05.033Z","comments":true,"path":"2021/03/17/春招面试/synchronized相关知识点/","link":"","permalink":"http://example.com/2021/03/17/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/synchronized%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1、synchronized 关键字 1.1 synchronized 关键字简介synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。 为什么呢？因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 synchronized 关键字。 2、synchronized 关键字使用方式synchronized 关键字最主要的三种使用方式： 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁123synchronized void method() &#123; //业务代码&#125; 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。123synchronized static void method() &#123;//业务代码&#125; 修饰代码块： 指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得 当前 class 的锁 123synchronized(this) &#123; //业务代码&#125; 总结： synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。 synchronized 关键字加到实例方法上是给对象实例上锁。 尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！ 重点：面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全） 1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 构造方法不能使用synchronized 关键词修饰。因为构造方法本身就属于线程安全的，不存在同步的构造方法一说。 2.1 synchronized 关键字的底层原理2.1.1 synchronized 同步语句块的情况1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; 从上面我们可以看出： synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。 在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 2.1.2 synchronized 修饰方法的的情况12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(&quot;synchronized 方法&quot;); &#125;&#125; synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 2.1.3 总结synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取。 2.2 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 2.3 谈谈 synchronized 和 ReentrantLock 的区别2.3.1 两者都是可重入锁“可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。 2.3.2 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 2.3.3 ReentrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点： 等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。 Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 3、参考synchronized 关键字","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"synchronized","slug":"synchronized","permalink":"http://example.com/tags/synchronized/"}],"author":"Marlowe"},{"title":"线程和进程相关概念","slug":"春招面试/线程和进程相关概念","date":"2021-03-17T11:41:58.000Z","updated":"2021-03-18T14:37:05.105Z","comments":true,"path":"2021/03/17/春招面试/线程和进程相关概念/","link":"","permalink":"http://example.com/2021/03/17/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","excerpt":"","text":"1、什么是进程进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 2、什么是线程线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 3、线程和进程的关系 从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。 总结： 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。 3.1 程序计数器为什么是私有的?程序计数器主要有下面两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 3.2 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 3.3一句话简单了解堆和方法区堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 4、为什么要使用多线程呢?先从总体上来说： 从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。 从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。 再深入到计算机底层来探讨： 单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。 多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。 5、 使用多线程可能带来什么问题?并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。 6、什么是上下文切换？多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 7、死锁产生的四个必要条件 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 7.1 如何避免死锁为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 ：一次性申请所有的资源。 破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 8、说说 sleep() 方法和 wait() 方法区别和共同点? 两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁 。 两者都可以暂停线程的执行。 wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。 9、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。 10、参考Java并发基础常见面试题总结","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}],"author":"Marlowe"},{"title":"HashMap扩容机制","slug":"春招面试/HashMap扩容机制","date":"2021-03-16T02:33:21.000Z","updated":"2021-03-16T12:55:24.851Z","comments":true,"path":"2021/03/16/春招面试/HashMap扩容机制/","link":"","permalink":"http://example.com/2021/03/16/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/","excerpt":"聊聊HashMap扩容机制","text":"聊聊HashMap扩容机制 1、什么时候才需要扩容 在首次调用put方法的时候，初始化数组table 当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。 什么是红黑树：红黑树是一种自平衡的二叉查找树。 性质： 节点是红色或黑色。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 红黑树相比于BST和AVL树有什么优点？ 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。 相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。 2、HashMap的扩容是什么进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”原位置+旧容量“这个位置。 说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”原位置+旧容量”这个位置。 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(原位置+旧容量)”。 正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。 resize()方法源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105final Node&lt;K,V&gt;[] resize() &#123; //得到当前数组 Node&lt;K,V&gt;[] oldTab = table; //如果当前数组等于null长度返回0，否则返回当前数组的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前阀值点 默认是12(16*0.75) int oldThr = threshold; int newCap, newThr = 0; //如果老的数组长度大于0 //开始计算扩容后的大小 if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //修改阈值为int的最大值 threshold = Integer.MAX_VALUE; return oldTab; &#125; /* 没超过最大值，就扩充为原来的2倍 1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量 2)oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16 */ else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //阈值扩大一倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; //老阈值点大于0 直接赋值 else if (oldThr &gt; 0) // 老阈值赋值给新的数组长度 newCap = oldThr; else &#123;// 直接使用默认值 newCap = DEFAULT_INITIAL_CAPACITY;//16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize最大上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //新的阀值 默认原来是12 乘以2之后变为24 threshold = newThr; //创建新的哈希表 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) //newCap是新的数组长度--》32 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //判断旧数组是否等于空 if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 //遍历旧的哈希表的每个桶，重新计算桶里元素的新位置 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; //原来的数据赋值为null 便于GC回收 oldTab[j] = null; //判断数组是否有下一个引用 if (e.next == null) //没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入 newTab[e.hash &amp; (newCap - 1)] = e; //判断是否是红黑树 else if (e instanceof TreeNode) //说明是红黑树来处理冲突的，则调用相关方法把树分开 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 采用链表处理冲突 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //通过上述讲解的原理来计算节点的新位置 do &#123; // 原索引 next = e.next; //这里来判断如果等于true e这个节点在resize之后不需要移动位置 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 参考面试题：HashMap扩容机制","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"Marlowe"},{"title":"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现","slug":"春招面试/ConcurrentHashMap-线程安全的具体实现方式-底层具体实现","date":"2021-03-16T01:57:08.000Z","updated":"2021-03-16T12:46:53.468Z","comments":true,"path":"2021/03/16/春招面试/ConcurrentHashMap-线程安全的具体实现方式-底层具体实现/","link":"","permalink":"http://example.com/2021/03/16/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"JDK1.7 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。 12static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;&#125; 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。 JDK1.8ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))） synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"},{"name":"线程安全","slug":"线程安全","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"}],"author":"Marlowe"},{"title":"ConcurrentHashMap 和 Hashtable 的区别","slug":"春招面试/ConcurrentHashMap-和-Hashtable-的区别","date":"2021-03-16T01:56:52.000Z","updated":"2021-03-16T12:11:10.042Z","comments":true,"path":"2021/03/16/春招面试/ConcurrentHashMap-和-Hashtable-的区别/","link":"","permalink":"http://example.com/2021/03/16/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。","text":"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 两者的对比图：HashTable: JDK1.7 的 ConcurrentHashMap： JDK1.8 的 ConcurrentHashMap：JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"},{"name":"线程安全","slug":"线程安全","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"}],"author":"Marlowe"},{"title":"HashMap 和 Hashtable 的区别","slug":"春招面试/HashMap-和-Hashtable-的区别","date":"2021-03-15T13:21:12.000Z","updated":"2021-03-15T14:35:59.037Z","comments":true,"path":"2021/03/15/春招面试/HashMap-和-Hashtable-的区别/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）； 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它； 对 Null key 和 Null value 的支持： HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。 初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 HashMap 中带有初始容量的构造函数： 12345678910111213141516public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。 12345678910111213/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"Marlowe"},{"title":"ArrayList和LinkedList的区别","slug":"春招面试/ArrayList和LinkedList的区别","date":"2021-03-15T06:23:58.000Z","updated":"2021-03-15T14:35:59.010Z","comments":true,"path":"2021/03/15/春招面试/ArrayList和LinkedList的区别/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Arraylist 与 LinkedList 区别? 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。） 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 参考Arraylist 与 LinkedList 区别?","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"}],"author":"Marlowe"},{"title":"ArrayList扩容机制","slug":"春招面试/ArrayList扩容机制","date":"2021-03-15T06:23:43.000Z","updated":"2021-03-15T14:35:59.030Z","comments":true,"path":"2021/03/15/春招面试/ArrayList扩容机制/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1234567891、添加元素时，首先进行判断是否大于默认容量102、如果，小于默认容量，直接在原来基础上+1，元素添加完毕3、如果，大于默认容量，则需要进行扩容，扩容核心是grow()方法 3.1 扩容之前，首先创建一个新的数组，且旧数组被复制到新的数组中 这样就得到了一个全新的副本，我们在操作时就不会影响原来数组了 3.2 然后通过位运算符将新的容量更新为旧容量的 1.5 倍 3.3 如果新的容量比最小需要容量小，则最小需要容量为当前数组新容量， 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 grow()方法： 12345678910111213141516171819202122232425/** * 要分配的最大数组大小 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"}],"author":"Marlowe"},{"title":"HashMap是线程安全的吗？","slug":"春招面试/HashMap是线程安全的吗？","date":"2021-03-15T06:23:22.000Z","updated":"2021-03-16T12:01:45.285Z","comments":true,"path":"2021/03/15/春招面试/HashMap是线程安全的吗？/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/","excerpt":"HashMap的线程不安全体现在会造成死循环、数据丢失、数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖这样的问题。","text":"HashMap的线程不安全体现在会造成死循环、数据丢失、数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖这样的问题。 扩容引发的线程不安全HashMap的线程不安全主要是发生在扩容函数中，即根源是在transfer函数中，JDK1.7中HashMap的transfer函数如下： 123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; 这段代码是HashMap的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。 JDK1.8中的线程不安全根据上面JDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，如果你去阅读1.8的源码会发现找不到transfer函数，因为JDK1.8直接在resize函数中完成了数据迁移。另外说一句，JDK1.8在进行元素插入时使用的是尾插法。 为什么说JDK1.8会出现数据覆盖的情况喃，我们来看一下下面这段JDK1.8中的put操作代码： 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果没有hash碰撞则直接插入元素 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 其中第六行代码是判断是否出现hash碰撞，假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。 除此之前，还有就是代码的第38行处有个++size，我们这样想，还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到第38行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时，线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。 总结HashMap的线程不安全主要体现在下面两个方面： 在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。 在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。 参考HashMap的实现原理，以及在JDK1.7和1.8的区别","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"Marlowe"},{"title":"HashMap底层原理","slug":"春招面试/HashMap底层原理","date":"2021-03-15T06:23:01.000Z","updated":"2021-03-16T02:14:19.317Z","comments":true,"path":"2021/03/15/春招面试/HashMap底层原理/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"JDK1.7数据结构则是采用的位桶和链表相结合的形式完成了，即拉链法。具体如下图所示： HashMap里面存储的是静态内部类Entry的对象，这个对象其实也是一个key-value的结构。 hash源码： 12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; JDK1.8相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 hash源码： 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 HashMap 的长度为什么是 2 的幂次方为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。 这个算法应该如何设计呢？ 我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"Marlowe"},{"title":"常见的IO模型有哪些？Java中的BIO，NIO，AIO的区别","slug":"春招面试/常见的IO模型有哪些？Java中的BIO，NIO，AIO的区别","date":"2021-03-15T06:22:22.000Z","updated":"2021-03-15T14:35:59.033Z","comments":true,"path":"2021/03/15/春招面试/常见的IO模型有哪些？Java中的BIO，NIO，AIO的区别/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FJava%E4%B8%AD%E7%9A%84BIO%EF%BC%8CNIO%EF%BC%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。","text":"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。 简介当应用程序发起I/O调用后，会经历两个步骤： 内核等待 I/O 设备准备好数据 内核将数据从内核空间拷贝到用户空间。 UNIX系统5种I/O模型： 同步阻塞 I/O 同步非阻塞 I/O I/O 多路复用 信号驱动 I/O 异步 I/O Java中三种常见的I/O模型BIO (Blocking I/O)BIO 属于同步阻塞 IO 模型 。 同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。 在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (Non-blocking/New I/O)Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。 Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。 同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。 但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。 这个时候，I/O 多路复用模型 就上场了。 IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。 IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。 Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。 AIO (Asynchronous I/O)AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。 最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。 参考京东数科二面:常见的10模型有哪些? Java中的BIO、NIO、 AIO有啥区别?","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"I/O模型","slug":"I-O模型","permalink":"http://example.com/tags/I-O%E6%A8%A1%E5%9E%8B/"}],"author":"Marlowe"},{"title":"JDK动态代理和CGLIB动态代理","slug":"春招面试/JDK动态代理和CGLIB动态代理","date":"2021-03-15T06:21:31.000Z","updated":"2021-03-17T07:39:58.775Z","comments":true,"path":"2021/03/15/春招面试/JDK动态代理和CGLIB动态代理/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"1、代理模式简介我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。 作用代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。 2、静态代理静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码_），非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。 上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 静态代理实现步骤: 定义一个接口及其实现类； 创建一个代理类同样实现这个接口 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。 见下面代码展示：1.定义发送短信的接口 123public interface SmsService &#123; String send(String message);&#125; 2.实现发送短信的接口 123456public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 3.创建代理类并同样实现发送短信的接口 123456789101112131415161718public class SmsProxy implements SmsService &#123; private final SmsService smsService; public SmsProxy(SmsService smsService) &#123; this.smsService = smsService; &#125; @Override public String send(String message) &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method send()&quot;); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method send()&quot;); return null; &#125;&#125; 4.实际使用 123456789101112131415161718public class SmsProxy implements SmsService &#123; private final SmsService smsService; public SmsProxy(SmsService smsService) &#123; this.smsService = smsService; &#125; @Override public String send(String message) &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method send()&quot;); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method send()&quot;); return null; &#125;&#125; 运行上述代码之后，控制台打印出： 123before method send()send message:javaafter method send() 通过输出结果看出，我们已经增加了SmsServiceImpl 的send()方法。 3、动态代理3.1、JDK动态代理机制3.1.1 介绍：在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。这个方法一共有 3 个参数： loader :类加载器，用于加载代理对象。 interfaces : 被代理类实现的一些接口。 h : 实现了 InvocationHandler 接口的对象。 要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。 也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。 3.1.2 JDK 动态代理类使用步骤 定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象； 3.1.3 代码示例1.定义发送短信的接口 123public interface SmsService &#123; String send(String message);&#125; 2.实现发送短信的接口 123456public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 3.定义一个 JDK 动态代理类 12345678910111213141516171819202122232425import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class DebugInvocationHandler implements InvocationHandler &#123; /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return result; &#125;&#125; invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。4.获取代理对象的工厂类 123456789public class JdkProxyFactory &#123; public static Object getProxy(Object target) &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), // 目标类的类加载 target.getClass().getInterfaces(), // 代理需要实现的接口，可指定多个 new DebugInvocationHandler(target) // 代理对象对应的自定义 InvocationHandler ); &#125;&#125; getProxy() ：主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象5.实际使用 12SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());smsService.send(&quot;java&quot;); 运行上述代码之后，控制台打印出： 123before method sendsend message:javaafter method send 3.2、CGLIB 动态代理机制3.2.1 介绍JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。 在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。 你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。 123456public interface MethodInterceptorextends Callback&#123; // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;&#125; obj :被代理的对象（需要增强的对象） method :被拦截的方法（需要增强的方法） args :方法入参 methodProxy :用于调用原始方法 你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。 3.2.2 CGLIB 动态代理类使用步骤 定义一个类； 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 通过 Enhancer 类的 create()创建代理类 3.2.3 代码示例不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 1.实现一个使用阿里云发送短信的类 12345678package github.javaguide.dynamicProxy.cglibDynamicProxy;public class AliSmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 2.自定义 MethodInterceptor（方法拦截器） 12345678910111213141516171819202122232425262728import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 自定义MethodInterceptor */public class DebugMethodInterceptor implements MethodInterceptor &#123; /** * @param o 被代理的对象（需要增强的对象） * @param method 被拦截的方法（需要增强的方法） * @param args 方法入参 * @param methodProxy 用于调用原始方法 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object object = methodProxy.invokeSuper(o, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return object; &#125;&#125; 3.获取代理类import net.sf.cglib.proxy.Enhancer; public class CglibProxyFactory { public static Object getProxy(Class&lt;?&gt; clazz) &#123; // 创建动态代理增强类 Enhancer enhancer = new Enhancer(); // 设置类加载器 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new DebugMethodInterceptor()); // 创建代理类 return enhancer.create(); &#125; } 12345```**4.实际使用**```javaAliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);aliSmsService.send(&quot;java&quot;); 运行上述代码之后，控制台打印出： 123before method sendsend message:javaafter method send 3.3 JDK 动态代理和 CGLIB 动态代理对比 JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。 静态代理和动态代理的对比 灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 参考代理模式详解","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"JDK","slug":"JDK","permalink":"http://example.com/tags/JDK/"}],"author":"Marlowe"},{"title":"代理模式之静态代理和动态代理","slug":"春招面试/代理模式之静态代理和动态代理","date":"2021-03-15T06:20:34.000Z","updated":"2021-03-16T01:57:29.483Z","comments":true,"path":"2021/03/15/春招面试/代理模式之静态代理和动态代理/","link":"","permalink":"http://example.com/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[],"author":"Marlowe"},{"title":"final,static,this,super关键字总结","slug":"春招面试/final-static-this-super关键字总结","date":"2021-03-13T07:55:17.000Z","updated":"2021-03-15T06:20:56.208Z","comments":true,"path":"2021/03/13/春招面试/final-static-this-super关键字总结/","link":"","permalink":"http://example.com/2021/03/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/final-static-this-super%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/","excerpt":"","text":"final 关键字final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法； final修饰的方法不能被重写； final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 说明： 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 static 关键字static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 this 关键字this关键字用于引用类的当前实例。例如： 1234567891011class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println(&quot;Total employees: &quot; + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在上述代码中，this关键字运用于两个地方: this.employees.length：访问Manager的当前实例的变量。 this.report（）：调用类Manager的当前实例的方法。此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。super 关键字 使用 this 和 super 要注意的问题： 在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 简单解释一下： 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。 参考final,static,this,super 关键字总结","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"关键字","slug":"关键字","permalink":"http://example.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"}],"author":"Marlowe"},{"title":"Arrays.asList()使用指南","slug":"春招面试/Arrays-asList-使用指南","date":"2021-03-13T02:40:40.000Z","updated":"2021-03-15T06:21:03.042Z","comments":true,"path":"2021/03/13/春招面试/Arrays-asList-使用指南/","link":"","permalink":"http://example.com/2021/03/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Arrays-asList-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"Arrays.asList()将数组转换为集合后,底层其实还是数组","text":"Arrays.asList()将数组转换为集合后,底层其实还是数组 1234567891011public class Test1 &#123; public static void main(String[] args) &#123; String[] str = new String[]&#123;&quot;111&quot;, &quot;222&quot;&#125;; List&lt;String&gt; list = Arrays.asList(str); list.add(&quot;333&quot;); list.forEach(a-&gt;&#123; System.out.println(a); &#125;); &#125;&#125; 12345运行报错：Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) at test.Test1.main(Test1.java:16) 使用注意事项传递的数组必须是对象数组，而不是基本类型 1234567int[] myArray = &#123;1, 2, 3&#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//1System.out.println(myList.get(0));//数组地址值System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException: 1int[] array = (int[]) myList.get(0);System.out.println(array[0]);//1 当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。 我们使用包装类型数组就可以解决这个问题。 12345Integer[] myArray = &#123;1, 2, 3&#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//3System.out.println(myList.get(0));//1System.out.println(myList.get(1));//2 使用集合的修改方法:add()、remove()、clear()会抛出异常。 1234List myList = Arrays.asList(1, 2, 3);myList.add(4);//运行时报错：UnsupportedOperationExceptionmyList.remove(1);//运行时报错：UnsupportedOperationExceptionmyList.clear();//运行时报错：UnsupportedOperationException Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。 12List myList = Arrays.asList(1, 2, 3);System.out.println(myList.getClass());//class java.util.Arrays$ArrayList 查看remove() 方法，可以知道为啥抛出UnsupportedOperationException。 123public E remove(int index) &#123; throw new UnsupportedOperationException();&#125; 如何正确的将数组转换为ArrayList？1、最简便的方法1List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 2、使用Java8的Stream12345Integer [] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); 参考Arrays.asList()使用指南","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Arrays","slug":"Arrays","permalink":"http://example.com/tags/Arrays/"}],"author":"Marlowe"},{"title":"Spring是什么？","slug":"春招面试/Spring是什么？","date":"2021-03-11T07:42:30.000Z","updated":"2021-03-13T06:42:24.595Z","comments":true,"path":"2021/03/11/春招面试/Spring是什么？/","link":"","permalink":"http://example.com/2021/03/11/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"轻量级的开源的J2EE框架。它是一个容器框架，用来装JavaBean，也是一个中间层框架，可以起连接作用。","text":"轻量级的开源的J2EE框架。它是一个容器框架，用来装JavaBean，也是一个中间层框架，可以起连接作用。 Spring是什么？Spring是一个轻量级的控制反转(Ioc)和面向切面(AOP)的容器框架。 1、Spring的核心是一个轻量级（Lightweight）的容器（Container）。2、Spring是实现IoC（Inversion of Control）容器和非入侵性（No intrusive）的框架。3、Spring提供AOP（Aspect-oriented programming）概念的实现方式。4、Spring提供对持久层（Persistence）、事物（Transcation）的支持。5、Spring供MVC Web框架的实现，并对一些常用的企业服务API（Application Interface）提供一致的模型封装。6、Spring提供了对现存的各种框架（Structs、JSF、Hibernate、Ibatis、Webwork等）相整合的方案。总之，Spring是一个全方位的应用程序框架。 对AOP的理解AOP:将程序中的交叉业务逻辑(比如安全，日志，事务等)，封装成一个切面,然后注入到目标对象(具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情。 对IoC的理解IOC:控制反转也叫依赖注入，IOC利用java反射机制，所谓控制反转是指，本来被调用者的实例是由调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件中配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 控制反转:没有引入I0C容器之前，对象A依赖于对象B,那么对象A在初始化或者运行到某一点的时候， 自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B,控制权都在自己手上。 引入I0C容器之后,对象A与对象B之间失去了直接联系,当对象A运行到需要对象B的时候，I0C容器 会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为,控制权颠倒过来，这就是”控制反转”这个名称的由来。 全部对象的控制权全部上缴给”第三方”IOC容器,所以，I0C容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个”粘合剂”，对象与对象之间会彼此失去联系,这就是有人把IoC容器比喻成”粘合剂”的由来。 依赖注入:“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现I0C的方法,就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}],"author":"Marlowe"},{"title":"线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?线程池中线程复用原理","slug":"春招面试/线程池中阻塞队列的作用-为什么是先添加列队而不是先创建最大线程-线程池中线程复用原理","date":"2021-03-11T06:35:10.000Z","updated":"2021-03-11T13:05:35.431Z","comments":true,"path":"2021/03/11/春招面试/线程池中阻塞队列的作用-为什么是先添加列队而不是先创建最大线程-线程池中线程复用原理/","link":"","permalink":"http://example.com/2021/03/11/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E5%88%97%E9%98%9F%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"线程池中阻塞队列的作用?一般的队列只能保证作为一个有限长度的缓冲区,如果超出了缓冲长度,就无法保留当前的任务了,阻塞队列通过阻塞可以保留住当前想要继续入队的任务。阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程,使得线程进入wait状态,释放cpu资源。阻塞队列自带阻塞和唤醒的功能,不需要额外处理,无任务执行时,线程池利用阻塞队列的take方法挂起,从而维持核心线程的存活、不至于一直占用cpu资源 为什么是先添加列队而不是先创建最大线程?在创建新线程的时候,是要获取全局锁的,这个时候其它的就得阻塞,影响了整体效率。 就好比一个饭店里面有10个(core)正式工的名额,最多招10个正式工,要是任务超过正式工人数(task&gt;core)的情况下,工厂领导(线程池)不是首先扩招工人,还是这10人,但是任务可以稍微积压一下,即先放到队列去(代价低) 。10个正式工慢慢干,迟早会千完的,要是任务还在继续增加,超过正式工的加班忍耐极限了(队列满了) ,就的招外包帮忙了(注意是临时工)要是正式工加上外包还是不能完成任务,那新来的任务就会被领导拒绝了(线程池的拒绝策略) 线程池中线程复用原理线程池将线程和任务进行解耦,线程是线程,任务是任务,摆脱了之前通过Thread创建线程时的一个线程必须对应一个任务的限制。 在线程池中,同一个线程可以从阻塞队列中不断获取新任务来执行,其核心原理在于线程池对Thread进行了封装,并不是每次执行任务都会调用Thread.start（)来创建新线程,而是让每个线程去执行一个”循环任务”,在这个”循环任务”中不停检查是否有任务需要被执行,如果有则直接执行,也就是调用任务中的run方法,将run方法当成一个普通的方法执行,通过这种方式只使用固定的线程就将所有任务的run方法串联起来。 参考线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?线程池中线程复用原理","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"为什么用线程池？线程池参数解释","slug":"春招面试/为什么用线程池？线程池参数解释","date":"2021-03-11T02:26:10.000Z","updated":"2021-03-11T13:05:35.420Z","comments":true,"path":"2021/03/11/春招面试/为什么用线程池？线程池参数解释/","link":"","permalink":"http://example.com/2021/03/11/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/","excerpt":"","text":"为什么使用线程池? 1、降低资源消耗;提高线程利用率,降低创建和销毁线程的消耗。 2、提高响应速度;任务来了,直接有线程可用可执行,而不是先创建线程,再执行。 3、提高线程的可管理性;线程是稀缺资源,使用线程池可以统一分配调优监控。 corePoolsize代表核心线程数,也就是正常情况下创建工作的线程数,这些线程创建后并不会消除,而是一种常驻线程 maxinumPoolsize代表的是最大线程数,它与核心线程数相对应,表示最大允许被创建的线程数,比如当前任务较多,将核心线程数都用完了,还无法满足需求时,此时就会创建新的线程,但是线程池内线程总数不会超过最大线程数 keepAliverime, unit表示超出核心线程数之外的线程的空闲存活时间,也就是核心线程不会消除,但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过setKeepAliveTime来设置空闲时间 workQueue用来存放待执行的任务,假设我们现在核心线程都已被使用,还有任务进来则全部放入队列,直到整个队列被放满但任务还再持续进入则会开始创建新的线程 ThreadFactory实际上是一个线程工厂,用来生产线程执行任务。我们可以选择使用默认的创建工厂,产生的线程都在同一个组内,拥有相同的优先级,且都不是守护线程。当然我们也可以选择自定义线程工厂,一般我们会根据业务来制定不同的线程工厂 Handler任务拒绝策略,有两种情况,第一种是当我们调用shutdown等方法关闭线程池后,这时候即使线程池内部还有没执行完的任务正在执行,但是由于线程池已经关闭,我们再继续想线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数,线程池已经没有能力继续处理新提交的任务时,这时也就拒绝 执行线程池的流程线程池任务开始执行时，会先判断线程池是否已满，如果没有满则创建核心线程执行，如果核心线程已满那么就判断任务队列是否已满，未满则将任务放入到队列中，如果已满则判断最大线程数是否打到，未达到则创建临时线程执行，临时吸线程如果空闲时我们可以设置超时时间也就是KeepAliveTime，当达到超时时间临时线程则被回收。如果全部线程空间都满了那么我们可设置拒绝策略来处理。 参考文档为什么要用线程池，线程池的参数解释","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"并发的三大特性","slug":"春招面试/并发的三大特性","date":"2021-03-11T00:31:23.000Z","updated":"2021-03-11T13:05:35.425Z","comments":true,"path":"2021/03/11/春招面试/并发的三大特性/","link":"","permalink":"http://example.com/2021/03/11/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"原子性定义：原子性是指在一个操作中cpu不可以在中途暂停然后再调度,即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作:从账户A减去1000元,往账户B加上1000元。2个操作必须全部完成。 关键字：synchronized 1234private long count = 0;public void calc()&#123; count++;&#125; 在上述代码中，将执行以下步骤： 将count从主存读取到工作内存中的副本 +1运算 将结果写入工作内存 将工作内存中的值刷回主存(什么时候刷入由操作系统决定，不确定的) 可见性定义：当一个线程修改了共享变量的值，其他线程会马上知道这个修改。当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从缓存中读取。 关键字：volatile、synchronized、final 有序性定义：虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题。 1234567891011121314int a = 0;boolean flag = false;public void write()&#123; a = 2; //1 //1 flag = true; //2 //4&#125; public void multiply()&#123; if(flag)&#123; //3 //2 int res = a * a; //4 //3 &#125; &#125; 1234567如果按照1234执行，结果为：a = 2;res = 4;如果按照1423执行，结果为：a = 2;res = 0; 关键字：volatile、synchronized volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则明确的。 小结： synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。 在某些情况下，volatile的同步机制的性能确实要优于锁(使用synchronized关键字或java.util.concurrent包里面的锁)，因为volatile的总开销要比锁低。 我们判断使用volatile还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性) 参考文档高并发的三大特性—原子性、有序性、可见性","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"}],"author":"Marlowe"},{"title":"ThreadLocal原理和使用场景","slug":"春招面试/ThreadLocal原理和使用场景","date":"2021-03-10T07:31:01.000Z","updated":"2021-03-10T14:29:28.631Z","comments":true,"path":"2021/03/10/春招面试/ThreadLocal原理和使用场景/","link":"","permalink":"http://example.com/2021/03/10/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ThreadLocal%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals,它存储本线程中所有ThreadLocal对象及其对应的值。","text":"每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals,它存储本线程中所有ThreadLocal对象及其对应的值。 简介：ThreadLocal保存当前线程的变量，当前线程内，可以任意获取，但每个线程往ThreadLocal中读写数据是线程隔离，互不影响。 1234567891011ThreadLocalMap源码：static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ThreadLocalMap由一个个Entry对象构成Entry继承自WeakReference&lt;ThreadLoca1&lt;?&gt;&gt;,一个Entry由ThreadLocal对象和Object构成。由此可见，Entry 的key是ThreadLocal对象,并且是一个弱引用。 当没指向key的强引用后, 该key就会被垃圾收集器回收。 注意 ThreadLocal存在内存泄露： 强引用(StrongReference)： 使用最普遍的引用(new),一个对象具有强引用，不会被GC回收。当JVM的内存空间不足时，宁愿抛出OutOfMemoryError使得程序异常终止也不愿意回收具有强引用的存活着的对象。如果想取消强引用和某个对象之间的关联，可以显式的将引用赋值为null，这样可以是JVM在合适的时候回收该对象。 弱引⽤(WeakReference)：在GC的时候，不管内存空间足不足都会回收这个对象。可以在缓存中使用弱引用。 当我们了解完，ThreadLocalMap 中使⽤的 key是以弱引用指向ThreadLocal，这时候垃圾回收器线程运行，发现弱引用就回收，key被回收。ThreadLocalMap里对应的Entry的key会变成null。这时候尴尬出现了，ThreadLocalMap里对应的Entry的value则无法被访问到，value作为一个强引用垃圾回收不到也不能被访问，即造成了内存溢出。 ThreadLocal正确的使用方法 在使用完ThreadLocal后，主动调用remove方法进行清理。 将ThreadLocal变量定义成private static, 这样就一 直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值， 进而清除掉。 123456789ThreadLocal set()方法public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key,将值存储进ThreadLocalMap对象中。 1234567891011121314ThreadLocal get()方法public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; get方法执行过程类似。ThreadLocal首先会获取当前线程对象,然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key,获取对应的value。 由于每一条线程均含有各自私有的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。 使用场景：1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。2、线程间数据隔离。3、进行事务操作，用于存储线程事务信息。4、数据库连接，Session会话管理。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"浅谈对守护线程的理解","slug":"春招面试/浅谈对守护线程的理解","date":"2021-03-10T07:13:51.000Z","updated":"2021-03-10T14:29:28.680Z","comments":true,"path":"2021/03/10/春招面试/浅谈对守护线程的理解/","link":"","permalink":"http://example.com/2021/03/10/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E6%B5%85%E8%B0%88%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"为所有非守护线程提供服务的线程，也称后台线程，任何一个守护线程都是整个JVM中所有非守护线程的保姆。","text":"为所有非守护线程提供服务的线程，也称后台线程，任何一个守护线程都是整个JVM中所有非守护线程的保姆。 守护线程的作用：举例，GC垃圾回收线程:就是一个经典的守护线程, 当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做,所以当垃圾回收线程是JVM.上仅剩的线程时,垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 （守护线程必须在线程开启前设置！）thread.setDaemon(true)必须在thread.start()之前设置,否则会抛出一个llegalThreadStateException异常。 你不能把正在运行的常规线程设置为守护线程。 在守护(deamon)线程中产生的新线程也是守护线程","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"浅谈对线程安全的理解","slug":"春招面试/浅谈对线程安全的理解","date":"2021-03-10T06:46:58.000Z","updated":"2021-03-10T14:29:28.684Z","comments":true,"path":"2021/03/10/春招面试/浅谈对线程安全的理解/","link":"","permalink":"http://example.com/2021/03/10/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"当多个线程访问一个对象时，如果不进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。","text":"当多个线程访问一个对象时，如果不进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。 简单来说，多线程情况下和单线程执行结果一样，就是线程安全的。 堆是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆,但是用完了要还给操作系统，要不然就是内存泄漏。 在Java中，堆是Java虚拟机所管理的内存中最大的一块,是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例， 几乎所有的对象实例以及数组都在这里分配内存。 栈是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立,因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"sleep(),wait(),join(),yield()的区别","slug":"春招面试/sleep-wait-join-yield-的区别","date":"2021-03-09T09:12:15.000Z","updated":"2021-03-10T14:29:28.636Z","comments":true,"path":"2021/03/09/春招面试/sleep-wait-join-yield-的区别/","link":"","permalink":"http://example.com/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/sleep-wait-join-yield-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"锁池所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。 等待池当我们调用wait()方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify()或notifyAll()后等待的线程才会开始去竞争锁，notify()是随机从等待池中选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中。 sleep是Thread类的静态本地方法，wait是Object类的本地方法。 sleep方法不会释放lock，但wait会释放，而且会加入到等待队列中。1sleep就是把cpu的执行资格和执行权释放出去，不在运行此线程，当定时时间结束后再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时线程有所，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也即无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这个点和wait是一样的。 sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。 sleep不需要被唤醒(休眠之后退出阻塞),但是wait需要(不指定时间需要被别人中断)。 sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。 sleep会放出cpu执行时间且强制上下文切换，而wait则不一定，wait后可能还是有机会重新竞争到锁继续执行的。 yield() 执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行。 join() 执行后线程进入阻塞状态，例如在线程B中调用线程A的join()，则线程B会进入到阻塞队列，直到线程A结束或中断线程。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;222222&quot;); &#125; &#125;); t1.start(); t1.join(); // 这行代码需等t1线程执行结束才会继续执行 System.out.println(&quot;11111&quot;); &#125; 123结果：22222211111","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"线程的生命周期包括哪几个阶段","slug":"春招面试/线程的生命周期包括哪几个阶段","date":"2021-03-09T08:49:03.000Z","updated":"2021-03-10T14:29:28.689Z","comments":true,"path":"2021/03/09/春招面试/线程的生命周期包括哪几个阶段/","link":"","permalink":"http://example.com/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%85%E6%8B%AC%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5/","excerpt":"线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。","text":"线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 新建（New）：就是刚使用new方法，new出来的线程。 就绪（Runnable）：就是调用的线程的start()方法。该状态的线程位于可运行线程池中，等待获取CPU的使用权。 运行（Running）：当就绪的线程被调度并获得CPU资源时，便进入运行状态。 阻塞（Blocked）：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态。 销毁（Dead）：线程执行完了或者因异常退出了run方法，该线程结束生命周期。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"GC如何判断对象可以被回收","slug":"春招面试/GC如何判断对象可以被回收","date":"2021-03-09T08:26:44.000Z","updated":"2021-03-10T14:29:28.603Z","comments":true,"path":"2021/03/09/春招面试/GC如何判断对象可以被回收/","link":"","permalink":"http://example.com/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6/","excerpt":"","text":"引用计数法方式：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。优点：实现简单，效率高。缺点：无法解决循环引用。 可达性分析法方式：从一系列被称为GC ROOT的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到GC ROOT之间没有引用链，说明这个对象不可用。 GC ROOT对象： 虚拟机栈中引用的对象 方法区内类的静态属性引用的对象 方法区常量引用的对象 本地方法栈中引用的对象 finalize()当一个对象被判定为不可达对象后，也并不是非死不可。在通过可达性分析算法判断没有引用链使之与GC ROOT相连，会判断该对象是否有必要执行finalize方法:假如重写了finalize，并且未调用过，则说明有必要执行。 判断有必要执行finalize的对象，会被放入一个队列，有jvm建立的低优先级的Finalizer线程去执行。 当在finalize中自救成功的对象，就会在第二次标记时移除即将回收的集合。自救失败的就会被回收，不会再执行finalize。 所谓自救就是把自己与引用链上的一个对象关联起来。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"http://example.com/tags/GC/"}],"author":"Marlowe"},{"title":"Java中的异常体系","slug":"春招面试/Java中的异常体系","date":"2021-03-09T07:58:09.000Z","updated":"2021-03-10T14:29:28.607Z","comments":true,"path":"2021/03/09/春招面试/Java中的异常体系/","link":"","permalink":"http://example.com/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","excerpt":"","text":"所有异常类都是Throwable的子类 异常可分为Error(错误)和Exception(异常)两类 Exception又可分为RuntimeException(运行时异常)和非运行时异常两类 Error是程序无法处理的错误，一旦出现这个错误，则程序被迫停止运行。 Exception不会导致程序停止，分为RuntimeException运行时异常和CheckedException检查异常。 RuntimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"异常","slug":"异常","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8/"}],"author":"Marlowe"},{"title":"Java类加载机制和类加载器概述","slug":"春招面试/Java类加载机制和类加载器概述","date":"2021-03-09T05:44:40.000Z","updated":"2021-03-10T14:29:28.626Z","comments":true,"path":"2021/03/09/春招面试/Java类加载机制和类加载器概述/","link":"","permalink":"http://example.com/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0/","excerpt":"当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来兑该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时候也把这3个步骤统称为类加载或类初始化。","text":"当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来兑该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时候也把这3个步骤统称为类加载或类初始化。 一、类加载过程1. 加载加载指的是将类的Class文件腐乳到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。 2. 链接当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。 3. 初始化初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 二、类加载时机 创建类的实例，也即new一个对象 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（Class.forName(“com.lyj.load”)） 初始化一个类的子类（会首先初始化子类的父类） JVM启动时标明的启动类，即文件名和类名相同的那个类 除此之外，下面几种情形需要特别指出： 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。 三、类加载器 根类加载器（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展类加载器（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。 系统类加载器（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。 四、类加载机制 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。 双亲委派机制 工作原理双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 优势采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 好处 主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String，Integer。 同时避免了类的重新加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类。 五、参考文档jvm之java类加载机制和类加载器(ClassLoader)的详解","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}],"author":"Marlowe"},{"title":"什么是字节码？采用字节码的好处是什么？","slug":"春招面试/什么是字节码？采用字节码的好处是什么？","date":"2021-03-09T02:43:58.000Z","updated":"2021-03-10T14:29:28.660Z","comments":true,"path":"2021/03/09/春招面试/什么是字节码？采用字节码的好处是什么？/","link":"","permalink":"http://example.com/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"字节码：在Java中，供虚拟机理解的代码叫做字节码(也就是Java代码编译后的.class文件),他不面向任何特定的处理器，只面向虚拟机。","text":"字节码：在Java中，供虚拟机理解的代码叫做字节码(也就是Java代码编译后的.class文件),他不面向任何特定的处理器，只面向虚拟机。 Java中的编译器和解释器Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。 采用字节码的好处Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[],"author":"Marlowe"},{"title":"JWTUtils","slug":"自定义工具类/JWTUtils","date":"2021-03-02T06:36:50.000Z","updated":"2021-03-02T06:45:38.286Z","comments":true,"path":"2021/03/02/自定义工具类/JWTUtils/","link":"","permalink":"http://example.com/2021/03/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/JWTUtils/","excerpt":"Jwt 学习","text":"Jwt 学习 引入jwt依赖12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 编写JWTUtils工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JWTUtils &#123; private static final String SIGN = &quot;!QDJHFKSHFK:&quot;; /** * 生成token header.payload.sign * * @param map * @return */ public static String getToken(Map&lt;String, String&gt; map) &#123; Calendar instance = Calendar.getInstance(); // 默认7天过期 instance.add(Calendar.DATE, 7); // 创建jwt builder JWTCreator.Builder builder = JWT.create(); // payload map.forEach((k, v) -&gt; &#123; builder.withClaim(k, v); &#125;); // 指定令牌过期时间和签名 String token = builder.withExpiresAt(instance.getTime()) .sign(Algorithm.HMAC256(SIGN)); return token; &#125; /** * 验证token 合法性 * * @param token */ public static void verify(String token) &#123; JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token); &#125; /** * 获取token信息 * * @param token * @return */ public static DecodedJWT getTokenInfo(String token) &#123; DecodedJWT verify = JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token); return verify; &#125;&#125; 编写JWTinterceptor类12345678910111213141516171819202122232425262728293031public class JWTInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); // 获取请求头令牌 String token = request.getHeader(&quot;token&quot;); try &#123; // 验证令牌 JWTUtils.verify(token); // 放行请求 return true; &#125; catch (SignatureVerificationException e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;无效签名&quot;); &#125; catch (TokenExpiredException e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;token过期&quot;); &#125; catch (AlgorithmMismatchException e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;token算法不一致&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;token 无效&quot;); &#125; map.put(&quot;state&quot;, false); String json = new ObjectMapper().writeValueAsString(map); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().println(json); return false; &#125;&#125; 编写拦截器配置类123456789@Configurationpublic class InterceptorConfig implements WebMvcConfigurer&#123; @Override public vpid addInterceptors(InterceptorRegistry registry)&#123; registry.addInterceptor(new JWTInterceptor()) .addPathPatterns(&quot;/xxx&quot;) .excludePathPatterns(&quot;/xxx&quot;); &#125;&#125;","categories":[{"name":"自定义工具类","slug":"自定义工具类","permalink":"http://example.com/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://example.com/tags/JWT/"}],"author":"Marlowe"},{"title":"常用的辅助类","slug":"JUC/常用的辅助类","date":"2020-12-26T17:13:41.000Z","updated":"2021-03-09T07:58:25.123Z","comments":true,"path":"2020/12/27/JUC/常用的辅助类/","link":"","permalink":"http://example.com/2020/12/27/JUC/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB/","excerpt":"","text":"countDownLatch12345678910111213141516public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; Go out&quot;); countDownLatch.countDown(); &#125;, String.valueOf(i)).start(); &#125; // 等待计数器归零，然后再向下执行 countDownLatch.await(); System.out.println(&quot;close door&quot;); &#125;&#125; 原理：countDownLatch.countDown(); // 数量-1countDownLatch.await(); // 等待计数器归零，然后向下执行每次有线程调用countDown(),数量减一，假设计数器变为0,countDownLatch.await();就会被唤醒，继续执行！ CyclicBarrierdemo: 123456789101112131415161718192021public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙成功！&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; final int temp = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;收集了&quot; + temp + &quot;个龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 结果 12345678Thread-1收集了2个龙珠Thread-2收集了3个龙珠Thread-0收集了1个龙珠Thread-3收集了4个龙珠Thread-4收集了5个龙珠Thread-5收集了6个龙珠Thread-6收集了7个龙珠召唤神龙成功！ SemaphoreSemaphore：信号量 123456789101112131415161718192021public class SemaphoreDemo &#123; public static void main(String[] args) &#123; // 线程数量，停车位，限流 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 原理：semaphore.acquire() // 获得，假设已经满了，等待，等待被释放为止semaphore.release() // 释放，会将当前的信号量释放 + 1，然后唤醒等待线程！作用：多个共享资源互斥使用，开发限流！","categories":[{"name":"JUC","slug":"JUC","permalink":"http://example.com/categories/JUC/"}],"tags":[{"name":"辅助类","slug":"辅助类","permalink":"http://example.com/tags/%E8%BE%85%E5%8A%A9%E7%B1%BB/"}],"author":"Marlowe"},{"title":"Callable","slug":"JUC/Callable","date":"2020-12-26T12:29:25.000Z","updated":"2020-12-28T01:28:39.878Z","comments":true,"path":"2020/12/26/JUC/Callable/","link":"","permalink":"http://example.com/2020/12/26/JUC/Callable/","excerpt":"","text":"Callable简介： 可以有返回值 可以抛出异常 方法不同，Runnable 是 run()， Callable 是call() 1234567891011121314151617181920212223242526public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyThread thread = new MyThread(); // 适配类 FutureTask futureTask = new FutureTask(thread); new Thread(futureTask, &quot;A&quot;).start(); new Thread(futureTask, &quot;B&quot;).start(); // get方法可能会产生阻塞 Integer s = (Integer) futureTask.get(); System.out.println(s); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;call()&quot;); // 耗时的操作 return 1024; &#125;&#125; 注意： 有缓存 结果可能需要等待，会阻塞！","categories":[{"name":"JUC","slug":"JUC","permalink":"http://example.com/categories/JUC/"}],"tags":[{"name":"Callable","slug":"Callable","permalink":"http://example.com/tags/Callable/"}],"author":"Marlowe"},{"title":"Redis 发布与订阅","slug":"NoSQL/Redis-发布与订阅","date":"2020-12-25T03:59:32.000Z","updated":"2020-12-25T04:00:13.281Z","comments":true,"path":"2020/12/25/NoSQL/Redis-发布与订阅/","link":"","permalink":"http://example.com/2020/12/25/NoSQL/Redis-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/","excerpt":"","text":"Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接受消息。微博、微信、关注系统！Redis客户端可以订阅任意数量的频道。订阅/发布消息图：第一个：消息发送者，第二个：频道，第三个：消息订阅者使用场景 实时消息系统 实时聊天(频道当做聊天室，将信息回显给所有人即可) 订阅，关注系统 稍微复杂的场景就会使用消息中间件MQ","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}],"author":"Marlowe"},{"title":"Redis 缓存穿透与雪崩(面试高频)","slug":"NoSQL/Redis-缓存穿透与雪崩-面试高频","date":"2020-12-24T09:07:26.000Z","updated":"2020-12-24T19:48:15.612Z","comments":true,"path":"2020/12/24/NoSQL/Redis-缓存穿透与雪崩-面试高频/","link":"","permalink":"http://example.com/2020/12/24/NoSQL/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/","excerpt":"","text":"","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}],"author":"Marlowe"},{"title":"Redis 持久化","slug":"NoSQL/Redis-持久化","date":"2020-12-24T03:28:46.000Z","updated":"2020-12-24T07:42:41.845Z","comments":true,"path":"2020/12/24/NoSQL/Redis-持久化/","link":"","permalink":"http://example.com/2020/12/24/NoSQL/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能！","text":"Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能！ RDB(Redis DataBase)简介：在指定的时间间隔内将内存中的数据集写入磁盘，也就是行话讲的Snapshot快照，它恢复时时将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ 在生产环境我们会将这个文件进行备份！ rdb保存的文件是dump.rdb 都是在配置文件中 快照中进行配置的！触发机制 save的规则满足情况下，会自动触发rdb规则 执行flushall命令，也会触发我们的rdb规则！ 退出redis，也会产生rdb文件备份就自动生成一个dump.rdb 如何恢复rdb文件？ 只需将rdb文件放在redis启动目录就可以，redis启动的时候就会自动检查dump.rdb，并恢复其中的数据。 查看需要存放的位置123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;D:\\\\Program Files\\\\redis-2.8.9&quot; 优点： 适合大规模的数据恢复！ 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了！ fork进程的时候，会占用一定的内存空间！ AOF(Append Only File)简介将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍！以日志的形式来记录每个读写操作，将Redis执行过的所有指令记录下来(读操作不记录),只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据,换言之，redis重启的话就根据日志文件的内容将写指令从前往后执行一次以完成数据的恢复工作Aof保存的是appendonly.aof文件 默认是不开启的，需要手动进行配置，只需要将appendonly改为yes就可以开启aof！ 重启redis就可以生效如果这个aof文件有错，redis将无法启动，需要修复这个aof文件redis提供了一个工具 redis-check-aof --fix如果文件正常，重启就可以直接恢复了！ 重写规则说明：aof默认就是文件的无限追加，文件会越来越大!如果aof文件大于64m，太大了，会fork一个新的进程来将文件重写！ 优点： 每一次修改都同步，文件的完整性会更加好！ 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点： 相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢 Aof运行效率比rdb慢，所以redis默认的配置就是rdb持久化","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}],"author":"Marlowe"},{"title":"SpringBoot整合Redis","slug":"NoSQL/SpringBoot整合Redis","date":"2020-12-23T13:59:54.000Z","updated":"2020-12-24T02:14:15.077Z","comments":true,"path":"2020/12/23/NoSQL/SpringBoot整合Redis/","link":"","permalink":"http://example.com/2020/12/23/NoSQL/SpringBoot%E6%95%B4%E5%90%88Redis/","excerpt":"","text":"说明：SpringBoot2.x之后，原来使用jedis被替换为了lettucejedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用jedis pool连接池！ 更像BIO模式lettuce：采用netty，示例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式原码分析： 12345678910111213141516171819@Bean@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)// 我们可以自定义一个redisTemplate来替换这个默认的！@ConditionalOnSingleCandidate(RedisConnectionFactory.class)public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; // 默认的RedisTemplate没有过多的设置，redis对象都是需要序列化！ // 两个泛型都是Object，Object的类型，我们使用需要强制转换&lt;String,Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template;&#125;@Bean@ConditionalOnMissingBean // 由于tring是redis中最常使用的类型，所以单独提取出来了一个bean！@ConditionalOnSingleCandidate(RedisConnectionFactory.class)public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template;&#125; 整合测试 导入依赖12345&lt;!--操作redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接12spring.redis.host=127.0.0.1spring.redis.port=6379 测试12345678910@Testvoid contextLoads() &#123; // 获取redis的连接对象 // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(&quot;mykey&quot;, &quot;kuangshen&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));&#125;","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}],"author":"Marlowe"},{"title":"Jedis","slug":"NoSQL/Jedis","date":"2020-12-23T13:19:43.000Z","updated":"2020-12-24T02:14:15.073Z","comments":true,"path":"2020/12/23/NoSQL/Jedis/","link":"","permalink":"http://example.com/2020/12/23/NoSQL/Jedis/","excerpt":"…","text":"… 简介Jedis 是 Redis官方推荐的Java连接开发工具，使用Java操作Redis中间件。 测试 导入对应的依赖12345678910111213&lt;!--导入jedis的依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编码测试 连接数据库 操作命令 断开连接12345678910public class TestPing &#123; public static void main(String[] args) &#123; // 1、new Jedis对象 Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); System.out.println(jedis.ping()); &#125;&#125; 输出： 操作事务： 12345678910111213141516171819202122232425262728293031public class TestTx &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); jedis.flushDB(); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;hello&quot;, &quot;world&quot;); jsonObject.put(&quot;name&quot;, &quot;marlowe&quot;); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); try &#123; multi.set(&quot;user1&quot;, result); multi.set(&quot;user2&quot;, result); // 代码抛出异常，事务执行失败 int i = 1 / 0; // 执行事务 multi.exec(); &#125; catch (Exception e) &#123; // 放弃事务 multi.discard(); e.printStackTrace(); &#125; finally &#123; System.out.println(jedis.get(&quot;user1&quot;)); System.out.println(jedis.get(&quot;user2&quot;)); jedis.close(); &#125; &#125;&#125; 输出：","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"http://example.com/tags/Jedis/"}],"author":"Marlowe"},{"title":"Redis 事务","slug":"NoSQL/Redis-事务","date":"2020-12-20T03:46:30.000Z","updated":"2020-12-23T12:19:32.013Z","comments":true,"path":"2020/12/20/NoSQL/Redis-事务/","link":"","permalink":"http://example.com/2020/12/20/NoSQL/Redis-%E4%BA%8B%E5%8A%A1/","excerpt":"Redis 事务简介","text":"Redis 事务简介 Redis 事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！一次性，顺序性，排他性 执行一系列的命令！ 1-----队列 set set set 执行----- Redis事务没有隔离级别的概念所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！ExecRedis单条命令是保证原子性的，但是事务不保证原子性Redis的事务： 开启事务() 命令入队() 执行事务() 正常执行事务 123456789101112131415127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec # 执行事务1) OK2) OK3) &quot;v2&quot;4) OK 放弃事务 123456789101112127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; discard # 取消事务OK127.0.0.1:6379&gt; get k4 # 事务队列中的命令都不会被执行(nil) 编译型异常，事务中的所有命令都不会被执行！ 123456789101112131415161718127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v5QUEUED127.0.0.1:6379&gt; exec # 执行命令的时候报错(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 # 所有的命令都不会执行(nil) 运行时异常如果事务队列中存在与发行，那么执行命令的时候，其他命令是可以正常执行，错误命令抛出异常！ 1234567891011121314151617181920127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 &quot;v1&quot;QUEUED127.0.0.1:6379&gt; incr k1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec1) OK2) (error) ERR value is not an integer or out of range # 第一条命令报错，但是依旧正常执行成功了！3) OK4) OK5) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot; 监控 Watch 悲观锁 很悲观，认为什么时候都会出问题，无论做什么都会加锁！ 乐观锁 很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version Redis 监视测试正常执行成功！ 123456789101112131415127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money # 监视money对象OK127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功OK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED127.0.0.1:6379&gt; exec1) (integer) 802) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"事务","slug":"事务","permalink":"http://example.com/tags/%E4%BA%8B%E5%8A%A1/"}],"author":"Marlowe"},{"title":"Redis 三种特殊数据类型","slug":"NoSQL/Redis-三种特殊数据类型","date":"2020-12-20T02:58:35.000Z","updated":"2020-12-20T15:40:18.878Z","comments":true,"path":"2020/12/20/NoSQL/Redis-三种特殊数据类型/","link":"","permalink":"http://example.com/2020/12/20/NoSQL/Redis-%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Radis 三种特殊数据类型…","text":"Radis 三种特殊数据类型… 三种特殊数据类型geospatial12345678geoadd # 添加位置geopos #获得当前定位 一定是一个坐标值geodist # 两人之间的距离georadius # 以给定的经纬度为中心，找出某一半径内的元素可以加参数 withdist 显示距离， withcoord 显示经纬度， count x 限制个数georadiusbymember 找出指定元素周围的其他元素geohash 返回11个字符串的geohash字符串geo底层的实现原理就是zset！我们可以通过zset命令来操作geo Hyperloglog1234567891011Redis Hyperloglog 基数统计的算法！优点:占用的内存固定，2^64不同的元素基数，只需要12KB内存！如果要从内存角度来比较的话Hyperloglog首选！网页UV（一个人访问一个网站多次，但是还是算作一个人！）传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断！这个方式如果保存大量的用户id，就会比较麻烦！ 我们的目的是为了计数，而不是保存用户id；0.81误错率！ 统计UV任务，可以忽略不计的！pfcount 统计元素的基数数量pfmearge mykey3 mykey mykey2 #合并两组mykey mykey2 =&gt; mykey3 并集如果允许容错，使用Hyperloglog；如果不允许容错，就使用set或者自己的数据类型即可 Bitmap 位存储 12345678910111213141516171819统计用户信息，活跃 不活跃！ 登录 未登录! 打卡 未打卡！ 两个状态的，都可以使用BitmapsBitmaps 位图，数据结构！ 都是操作二进制来进行记录，就只有0和1两个状态！365天=365bit 1字节=8比特 46比特左右！使用bitmap来记录 周一到周日的打卡！127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 0(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0 查看某一天是否打卡！ 1234127.0.0.1:6379&gt; getbit sign 3(integer) 1127.0.0.1:6379&gt; getbit sign 6(integer) 0 统计操作，统计打卡的天数！ 12127.0.0.1:6379&gt; bitcount sign # 统计这周的打卡记录，可以看到是否全勤(integer) 3","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"数据类型","slug":"数据类型","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"author":"Marlowe"},{"title":"Redis 五大数据类型","slug":"NoSQL/Redis-五大数据类型","date":"2020-12-19T09:10:33.000Z","updated":"2020-12-20T15:40:18.890Z","comments":true,"path":"2020/12/19/NoSQL/Redis-五大数据类型/","link":"","permalink":"http://example.com/2020/12/19/NoSQL/Redis-%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Redis 五大数据类型详述…","text":"Redis 五大数据类型详述… Redis-keyString（字符串）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127.0.0.1:6379&gt; set key1 v1OK127.0.0.1:6379&gt; get key1&quot;v1&quot;127.0.0.1:6379&gt; keys *1) &quot;key1&quot;127.0.0.1:6379&gt; exists key1(integer) 1127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 如果当前key不存在，就相当于set key(integer) 7127.0.0.1:6379&gt; get key1&quot;v1hello&quot;127.0.0.1:6379&gt; strlen key1(integer) 7########################################### i++127.0.0.1:6379&gt; set views 0OK127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incr views(integer) 1127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; decr views(integer) 0127.0.0.1:6379&gt; decr views(integer) -1127.0.0.1:6379&gt; get views&quot;-1&quot;127.0.0.1:6379&gt; incr views(integer) 0127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incrby views 10(integer) 10127.0.0.1:6379&gt; decrby views 5(integer) 5########################################### 字符串范围 range127.0.0.1:6379&gt; set key1 &quot;hello,kuangshen&quot;OK127.0.0.1:6379&gt; get key1&quot;hello,kuangshen&quot;127.0.0.1:6379&gt; getrange key1 0 3&quot;hell&quot;127.0.0.1:6379&gt; getrange key1 0 -1&quot;hello,kuangshen&quot;# 替换127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2&quot;abcdefg&quot;127.0.0.1:6379&gt; setrange key2 1 xx(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;########################################### setex(set with expire) # 设置过期时间# setnx(set if not exist) # 不存在再设置(在分布式锁中常常使用！)127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;OK127.0.0.1:6379&gt; ttl key3(integer) 26127.0.0.1:6379&gt; get key3&quot;hello&quot;127.0.0.1:6379&gt; setnx mykey &quot;redis&quot;(integer) 1127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;3) &quot;mykey&quot;4) &quot;key3&quot;127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;3) &quot;mykey&quot;127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot;(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;##########################################127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;127.0.0.1:6379&gt; get k1 k2 k3(error) ERR wrong number of arguments for &#x27;get&#x27; command127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获得多个值1) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx是一个原子性操作，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379&gt; get k4(nil)# 对象set user:1&#123;name:zhangsan,age:3&#125; # 设置一个user：1对象，值为json字符来保存一个对象# 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125;127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:11) (nil)127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;##########################################getset # 先get再set127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回nil(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db mongodb # 如果存在值，则获取原来的值&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mongodb&quot; String类似的使用场景：value除了是字符串还可以是数字 计数器 统计多单位的数量 粉丝数 对象缓存存储！ List基本数据类型，列表所有的list命令都是以l开头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163##########################################127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; lpush list one # 将一个值或者多个值，插到列表的头部(左)(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; rpush list rigth # 将一个值或者多个值，插到列表的尾部(右)(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;rigth&quot;##########################################lpoprpop127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;rigth&quot;127.0.0.1:6379&gt; lpop list # 移除列表的第一个元素&quot;three&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;rigth&quot;127.0.0.1:6379&gt; rpop list # 移除列表的最后一个元素&quot;rigth&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;##########################################lindex127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; lindex list 0 # 通过下标获得list中的某一个值&quot;two&quot;127.0.0.1:6379&gt; lindex list 1&quot;one&quot;##########################################llen127.0.0.1:6379&gt; lpush list one(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; llen list(integer) 3##########################################移除指定的值！取关 uidlrem127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; lrem list 1 one # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; lrem list 1 three(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; keys *1) &quot;list&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; lrem list 2 three(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;##########################################trim：修剪 list：截断127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush list &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpush list &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; rpush list &quot;hello4&quot;(integer) 5127.0.0.1:6379&gt; ltrim list 0 1 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;hello1&quot;##########################################rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush list &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpush list &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; rpoplpush list list1 # 移除列表的最后一个元素，将他移动到新的列表中&quot;hello3&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;hello1&quot;3) &quot;hello2&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;hello3&quot;##########################################lset # 将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379&gt; lset list 0 itemOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;item&quot;2) &quot;hello1&quot;3) &quot;hello2&quot;127.0.0.1:6379&gt; lset list 1 item1OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;item&quot;2) &quot;item1&quot;3) &quot;hello2&quot;##########################################linsert # 将某个具体的value插入到列表中某个元素的前面或者后面！127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;world&quot;(integer) 2127.0.0.1:6379&gt; linsert list before world other(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;127.0.0.1:6379&gt; linsert list after world other1(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;4) &quot;other1&quot; ########################################## 小结 实际上是一个链表，before Node after， left right都可以插入值 如果key不存在，创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在！ 在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点~ 消息排队！ 消息队列 （lpush rpop），栈（lpush lpop） Set(集合)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104##########################################127.0.0.1:6379&gt; sadd myset hello(integer) 1127.0.0.1:6379&gt; sadd myset kuangshen(integer) 1127.0.0.1:6379&gt; sadd myset lovekuangshen(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen&quot;2) &quot;hello&quot;3) &quot;kuangshen&quot;127.0.0.1:6379&gt; sismember myset hello(integer) 1127.0.0.1:6379&gt; sismember myset world(integer) 0##########################################127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数(integer) 4##########################################srem 127.0.0.1:6379&gt; scard myset(integer) 4127.0.0.1:6379&gt; srem myset hello # 移除set集合中指定的元素(integer) 1127.0.0.1:6379&gt; scard myset(integer) 3127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen2&quot;2) &quot;lovekuangshen&quot;3) &quot;kuangshen&quot;##########################################set 无序不重复集合，抽随机！127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen2&quot;2) &quot;lovekuangshen&quot;3) &quot;kuangshen&quot;127.0.0.1:6379&gt; srandmember myset # 随机抽选出一个元素&quot;lovekuangshen2&quot;127.0.0.1:6379&gt; srandmember myset # 随机抽选出一个元素&quot;lovekuangshen2&quot;127.0.0.1:6379&gt; srandmember myset # 随机抽选出一个元素&quot;kuangshen&quot;127.0.0.1:6379&gt; srandmember myset 2 # 随机抽选出指定个数的元素1) &quot;lovekuangshen&quot;2) &quot;kuangshen&quot;##########################################删除指定的key，随机删除key127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen2&quot;2) &quot;lovekuangshen&quot;3) &quot;kuangshen&quot;127.0.0.1:6379&gt; spop myset #随机删除一些set中的元素&quot;kuangshen&quot;127.0.0.1:6379&gt; spop myset&quot;lovekuangshen2&quot;127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen&quot;##########################################将一个指定的值，移动到另外一个set集合！127.0.0.1:6379&gt; sadd myset hello(integer) 1127.0.0.1:6379&gt; sadd myset world(integer) 1127.0.0.1:6379&gt; sadd myset kuangshen(integer) 1127.0.0.1:6379&gt; sadd myset2 set2(integer) 1127.0.0.1:6379&gt; smove myset myset2 kuangshen # 将一个指定的值，移动到另外一个set集合(integer) 1127.0.0.1:6379&gt; smembers(error) ERR wrong number of arguments for &#x27;smembers&#x27; command127.0.0.1:6379&gt; smembers myset1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; smembers myset21) &quot;set2&quot;2) &quot;kuangshen&quot;##########################################微博，b站，共同关注(交集)127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 c(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e(integer) 1127.0.0.1:6379&gt; sdiff key1 key21) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; sinter key1 key21) &quot;c&quot;127.0.0.1:6379&gt; sunion key1 key21) &quot;c&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;d&quot;5) &quot;e&quot;########################################## 微博，A用户将所有关注的人放在一个set集合中！ 将他的粉丝也放在一个集合中！共同关注，共同爱好，二度好友，推荐好友！(六度分割理论) Hash(哈希)Map 集合，key-map! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556127.0.0.1:6379&gt; hset myhash field1 kuangshen(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;kuangshen&quot;127.0.0.1:6379&gt; hmset myhash field1 hello field2 worldOK127.0.0.1:6379&gt; hmget myhash field1 field21) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field1&quot;4) &quot;hello&quot;5) &quot;field2&quot;6) &quot;world&quot;127.0.0.1:6379&gt; hdel myhash field1(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field2&quot;4) &quot;world&quot;##########################################hlen127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量(integer) 2##########################################127.0.0.1:6379&gt; hexists myhash field1 # 判断hash中指定字段是否存在！(integer) 0127.0.0.1:6379&gt; hexists myhash field2(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field2&quot;4) &quot;world&quot;########################################### 只获取所有的field127.0.0.1:6379&gt; hkeys myhash1) &quot;field&quot;2) &quot;field2&quot;# 只获取所有的value127.0.0.1:6379&gt; hvals myhash1) &quot;kuangshen&quot;2) &quot;world&quot;########################################## hash变更的数据 user name age，尤其是用户信息之类的，经常变动的数据！hash更适合于对象的存储，String更加适合字符串存储！ Zset(有序集合)123456zaddzrangezrangebyscore xxx -inf +inf withscores # 显示全部的用户并且附带成绩zrevrange # 从大到小排序zrem # 移除元素zcount # 获取指定区间的成员数量 其余API，查官方文档案例思路：set 排序 存储班级成绩表，工资排序表！普通消息：1 重要消息：2 带权重进行判断！排行榜应用实现，取TOP 10","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"数据类型","slug":"数据类型","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"author":"Marlowe"},{"title":"Redis 基础知识","slug":"NoSQL/Redis-基础知识","date":"2020-12-19T08:19:14.000Z","updated":"2020-12-20T15:40:18.893Z","comments":true,"path":"2020/12/19/NoSQL/Redis-基础知识/","link":"","permalink":"http://example.com/2020/12/19/NoSQL/Redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"Redis 基础知识","text":"Redis 基础知识 Redis 是单线程的！ Redis 是很快的，官方表示，Redis 是基于内存操作，CPU 不是Redis性能瓶颈，Redis 的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程实现，就使用单线程了。 Redis 是C语言写的，官方提供的数据位100000+的QPS，完全不比同样的使用key-value的Memecache差。 Redis 单线程为什么还这么快？ 误区1： 高性能服务器一定是多线程的？ 误区2： 多线程(CPU上下文会切换)一定比单线程效率高？ 核心：Redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程(CPU上下文切换：耗时的操作！！)对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上，在内存情况下，这就是最佳的方案！","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}],"author":"Marlowe"},{"title":"高效的一天","slug":"学习方法/高效的一天","date":"2020-12-19T01:18:48.000Z","updated":"2020-12-20T15:40:18.911Z","comments":true,"path":"2020/12/19/学习方法/高效的一天/","link":"","permalink":"http://example.com/2020/12/19/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E9%AB%98%E6%95%88%E7%9A%84%E4%B8%80%E5%A4%A9/","excerpt":"大佬高效工作的一天…","text":"大佬高效工作的一天… 半小时整理每日重点和待办事项12整理每日计划，梳理一下今天大概要做什么事情，思考每件事情的优先级软件推荐：Notion 独立的工作区 回想昨天的工作，处理邮件 提前准备会议内容1Visio or PPT 整理要说的内容 避免多任务切换1和计算机类似，在计算机里切换任务，或者发生中断，要保存各种状态，上下文和数据，完成中断之后，还要恢复之前保存的数据，保存和恢复的过程，都要花费大量的计算，想办法尽量避免中断 在家工作划分工作和生活的界限 必要的生产力工具1iPad Pro + Notability + Notion 琐碎任务集中处理","categories":[{"name":"学习方法","slug":"学习方法","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"效率","slug":"效率","permalink":"http://example.com/tags/%E6%95%88%E7%8E%87/"},{"name":"工作方法","slug":"工作方法","permalink":"http://example.com/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"}],"author":"Marlowe"},{"title":"ES 文档的API操作详情","slug":"ElasticSearch/ES-文档的API操作详情","date":"2020-12-08T11:16:02.000Z","updated":"2020-12-10T00:43:37.401Z","comments":true,"path":"2020/12/08/ElasticSearch/ES-文档的API操作详情/","link":"","permalink":"http://example.com/2020/12/08/ElasticSearch/ES-%E6%96%87%E6%A1%A3%E7%9A%84API%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/","excerpt":"…","text":"… 编写ElasticSearchConfig 配置文件，将ES交给Spring托管 ElasticSearchConfig.java 1234567891011@Configurationpublic class ElasticSearchConfig &#123; @Bean public RestHighLevelClient restHighLevelClient() &#123; RestHighLevelClient restHighLevelClient = new RestHighLevelClient( RestClient.builder( new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;))); return restHighLevelClient; &#125;&#125; ES部分APIKuangEsApiApplicationTests.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173@SpringBootTestclass KuangEsApiApplicationTests &#123; @Autowired @Qualifier(&quot;restHighLevelClient&quot;) private RestHighLevelClient client; /** * 测试索引的创建 Request PUT kuang_index */ @Test void testCreateIndex() throws IOException &#123; // 1.创建索引请求 CreateIndexRequest request = new CreateIndexRequest(&quot;kuang_index&quot;); // 2.客户端执行请求 IndicesClient 请求后获得相应 CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); &#125; /** * 测试获取索引,判断其是否存在 */ @Test void testExistsIndex() throws IOException &#123; GetIndexRequest request = new GetIndexRequest(&quot;kuang_index&quot;); boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * 测试删除索引，判断是否存在 * * @throws IOException */ @Test void testDeleteIndex() throws IOException &#123; DeleteIndexRequest request = new DeleteIndexRequest(&quot;kuang_index&quot;); AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); &#125; /** * 测试添加文档 */ @Test void testAddDocument() throws IOException &#123; // 创建对象 User user = new User(&quot;狂神说&quot;, 3); // 创建请求 IndexRequest request = new IndexRequest(&quot;kuang_index&quot;); // 规则 put /kuang_index/_doc/1 request.id(&quot;1&quot;); request.timeout(TimeValue.timeValueSeconds(1)); request.timeout(&quot;1s&quot;); // 将我们的数据放入请求 json IndexRequest source = request.source(JSON.toJSONString(user), XContentType.JSON); // 客户端发送请求,获取响应的结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse.toString()); System.out.println(indexResponse.status()); &#125; /** * 获取文档，判断是否存在 */ @Test void testIsExists() throws IOException &#123; GetRequest getRequest = new GetRequest(&quot;kuang_index&quot;, &quot;1&quot;); // 不获取返回的_source的上下文了 getRequest.fetchSourceContext(new FetchSourceContext(false)); getRequest.storedFields(&quot;_none_&quot;); boolean exists = client.exists(getRequest, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * 获取文档的信息 */ @Test void testGetDocument() throws IOException &#123; GetRequest getRequest = new GetRequest(&quot;kuang_index&quot;, &quot;1&quot;); GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT); // 打印文档的内容 System.out.println(getResponse.getSourceAsString()); // 返回的全部内容和命令是一样的 System.out.println(getResponse); &#125; /** * 更新文档的信息 */ @Test void testUpdateDocument() throws IOException &#123; UpdateRequest updateRequest = new UpdateRequest(&quot;kuang_index&quot;, &quot;1&quot;); updateRequest.timeout(&quot;1s&quot;); User user = new User(&quot;狂神说Java&quot;, 18); updateRequest.doc(JSON.toJSONString(user), XContentType.JSON); UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse.status()); &#125; /** * 删除文档的信息 */ @Test void testDeleteDocument() throws IOException &#123; DeleteRequest deleteRequest = new DeleteRequest(&quot;kuang_index&quot;, &quot;1&quot;); deleteRequest.timeout(&quot;1s&quot;); DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT); System.out.println(deleteResponse); &#125; /** * 批量插入数据 */ @Test void testBulkRequest() throws IOException &#123; BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(&quot;10s&quot;); List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;kuangshen1&quot;, 3)); userList.add(new User(&quot;kuangshen2&quot;, 3)); userList.add(new User(&quot;kuangshen3&quot;, 3)); userList.add(new User(&quot;qinjiang1&quot;, 3)); userList.add(new User(&quot;qinjiang2&quot;, 3)); userList.add(new User(&quot;qinjiang3&quot;, 3)); // 批处理请求 for (int i = 0; i &lt; userList.size(); i++) &#123; bulkRequest.add( new IndexRequest(&quot;kuang_index&quot;) .id(&quot;&quot; + (i + 1)) .source(JSON.toJSONString(userList.get(i)), XContentType.JSON)); &#125; BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulkResponse.hasFailures()); &#125; /** * 查询 * searchRequest 搜索请求 * SearchSourceBuilder 条件构造 * HighlightBuilder 构建高亮 * TermQueryBuilder 精确查询 */ @Test void testSearch() throws IOException &#123; SearchRequest searchRequest = new SearchRequest(ESConst.ES_INDEX); // 构建搜索条件 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); // 查询条件，我们可以使用QueryBuilder 工具来实现 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;name&quot;, &quot;qinjiang1&quot;); sourceBuilder.query(termQueryBuilder); sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(searchResponse.getHits())); System.out.println(&quot;======================&quot;); for (SearchHit documentFields : searchResponse.getHits().getHits()) &#123; System.out.println(documentFields.getSourceAsMap()); &#125; &#125;&#125;","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://example.com/categories/ElasticSearch/"}],"tags":[{"name":"ES","slug":"ES","permalink":"http://example.com/tags/ES/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"}],"author":"Marlowe"},{"title":"Rest风格操作","slug":"ElasticSearch/Rest风格操作","date":"2020-12-08T04:24:51.000Z","updated":"2020-12-09T08:26:40.796Z","comments":true,"path":"2020/12/08/ElasticSearch/Rest风格操作/","link":"","permalink":"http://example.com/2020/12/08/ElasticSearch/Rest%E9%A3%8E%E6%A0%BC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"关于索引的基本操作12PUT /索引名/~类型名~/文档id&#123;请求体&#125; 完成了自动增加索引！数据也成功的添加了 指定字段的类型 12345678910111213141516PUT /test2&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;birthday&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125;&#125; 创建规则 可以通过GET请求获取具体信息 查看默认信息 如果自己的文档字段没有指定，那么es会给我们默认配置字段类型！ 扩展：通过命令elasticsearch索引情况！通过GET _cat/ 可以获得es当前的很多信息！ 更新方法 以前的方法 现在的方法 删除索引通过DELETE命令删除、根据你的请求来判断是删除索引还是删除文档记录！使用RESTFUL风格是ES推荐大家使用的！ 关于文档的基本操作(重点)基本操作 添加数据 1234567PUT /kuangshen/user/2&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;desc&quot;: &quot;法外狂徒张三&quot;, &quot;tags&quot;: [&quot;旅游&quot;,&quot;温暖&quot;,&quot;渣男&quot;]&#125; 获取数据 GET 1GET /kuangshen/user/1 更新数据 PUT POST _updatePUT如果不传递值就会被覆盖，POST灵活度更高 简单的搜索 1GET /kuangshen/user/1 简单的条件查询,可以根据默认的映射规则，产生基本的查询！ 1GET /kuangshen/user/_search?q=name:狂神说java 复杂操作搜索select(排序，分页，高亮，模糊查询，精准查询！) hits：索引和文档的信息查询的结果总数然后就是查询出来的具体的文档数据中心的所有东西都可以遍历出来了分数：我们可以通过分数来判断谁更加符合搜索结果 输出结果，只需要指定的字段 之后Java操作es，所有的方法和对象就是这里面的key！ 排序 分页查询数据下标还是从0开始的，和学的所有的数据结构是一样的！/search/{current}/{pagesize}布尔值查询must（and）,所有的条件都要符合 where id = 1 and name = xxx多条件查询 should（or）,所有的条件都要符合 where id = 1 or name = xxx must_not (not) 过滤器 filter 匹配多个条件 term查询是直接通过倒排索引指定的词条进行精确的查找！ 关于分词 term，直接查询精确的 match，会使用分词器解析！(先分析文档，然后再通过分析的文档进行查询！) 两个类型 text keyword keyword 字段类型不会被分词器解析 多个值匹配的精确查询 高亮查询 自定义搜索高亮条件 这些MySQL也能做，只是MySQL效率比较低！ 匹配 按照条件匹配 精确匹配 区间范围匹配 区间字段匹配 多条件查询 高亮查询","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://example.com/categories/ElasticSearch/"}],"tags":[{"name":"ES","slug":"ES","permalink":"http://example.com/tags/ES/"},{"name":"Resuful","slug":"Resuful","permalink":"http://example.com/tags/Resuful/"}],"author":"Marlowe"},{"title":"ElasticSearch之ik插件之究极大坑","slug":"环境配置之踩坑/ElasticSearch之ik插件之究极大坑","date":"2020-12-07T17:10:24.000Z","updated":"2020-12-07T17:25:12.629Z","comments":true,"path":"2020/12/08/环境配置之踩坑/ElasticSearch之ik插件之究极大坑/","link":"","permalink":"http://example.com/2020/12/08/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B8%A9%E5%9D%91/ElasticSearch%E4%B9%8Bik%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%A9%B6%E6%9E%81%E5%A4%A7%E5%9D%91/","excerpt":"由于最近要做搜索引擎课设，可以用ElasticSearch做，因此，开启了ES的学习之路，也开启了ES踩坑之路，入门一小时，配环境两小时！！~","text":"由于最近要做搜索引擎课设，可以用ElasticSearch做，因此，开启了ES的学习之路，也开启了ES踩坑之路，入门一小时，配环境两小时！！~ 在elasticsearch中安装ik中文分词器，使用的elasticsearch版本是7.10.0，elasticsearch-analysis-ik版本是7.10.0。 安装后，重新启动报错，报错信息为： 12[2020-11-18T17:14:56,012][WARN ][o.e.c.r.a.AllocationService] [LAPTOP-TLVIFKFC] failing shard [AccessControlException[access denied (&quot;java.io.FilePermission&quot; &quot;D:\\Program%20Files\\elasticsearch\\elasticsearch-7.10.0\\plugins\\ik\\config\\IKAnalyzer.cfg.xml&quot; &quot;read&quot;)]], markAsStale [true]]java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;D:\\Program%20Files\\elasticsearch\\elasticsearch-7.10.0\\plugins\\ik\\config\\IKAnalyzer.cfg.xml&quot; &quot;read&quot;) 原因是：elasticsearch安装路径中有空格造成的，如安装路径为D:\\Program Files\\elasticsearch\\elasticsearch-7.10.0，其中”Program Files”两个词中间有空格 解决方法：elasticsearch选择没有空格的文件目录下安装 前前后后下载了很多版本的插件，以及找同学烤文件，都没能解决这个问题，在百度重新搜索elasticsearch ik 7.10.0 下载的时候，出现了一篇拯救我的文章，重新安装好es所需要的文件后，将整个文件移动到没有空格的文件夹，问题才得以解决！ 参考：elasticsearch-7.10.0使用elasticsearch-analysis-ik-7.10.0分词器插件后启动报错 ES学习教程:【狂神说Java】ElasticSearch7.6.x最新完整教程通俗易懂","categories":[{"name":"环境配置之踩坑","slug":"环境配置之踩坑","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"ES","slug":"ES","permalink":"http://example.com/tags/ES/"},{"name":"踩坑","slug":"踩坑","permalink":"http://example.com/tags/%E8%B8%A9%E5%9D%91/"}],"author":"Marlowe"},{"title":"Java中如何跳出多重循环","slug":"Java基础/Java中如何跳出多重循环","date":"2020-12-07T00:20:29.000Z","updated":"2020-12-07T17:22:18.848Z","comments":true,"path":"2020/12/07/Java基础/Java中如何跳出多重循环/","link":"","permalink":"http://example.com/2020/12/07/Java%E5%9F%BA%E7%A1%80/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/","excerpt":"Java 基础回顾…","text":"Java 基础回顾… 在JAVA中如何跳出当前的多重嵌套循环在java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的的break语句，即可跳出 1234567891011public static void main(String[] args) &#123; ok: while (true) &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); if (i == 200) &#123; break ok; &#125; &#125; &#125; &#125; return和 break区别breakbreak语句虽然可以独立使用，但通常主要用于switch语句中，控制程序的执行流程转移。在switch语句中，其作用是强制退出switch结构，执行switch结构之后的语句。其本质就是在单层循环结构体系中，其作用是强制退出循环结构。 returnreturn语句用来明确地从一个方法返回。也就是，return 语句使程序控制返回到调用它方法。因此，将它分类为跳转语句.有两个作用，一个是返回方法指定类型的值（这个值总是确定的）;一个是结束方法的执行（仅仅一个return语句）。return 语句可以使其从当前方法中退出，返回到调用该方法的语句处，继续程序的执行 。 exit()函数 和 return 区别exit(0)：正常运行程序并退出程序；exit(1)：非正常运行导致退出程序；return()：返回函数，若在主函数中，则会退出函数并返回一值。 具体来说： return返回函数值，是关键字； exit 是一个函数。 return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示结束一个进程 。 return是函数的退出(返回)；exit是进程的退出。 return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。 return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出， 非0 为非正常退出。 非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。 参考在java中如何跳出当前的多重嵌套循环？","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面经","slug":"面经","permalink":"http://example.com/tags/%E9%9D%A2%E7%BB%8F/"}],"author":"Marlowe"},{"title":"Swagger在线文档","slug":"Spring/Swagger在线文档","date":"2020-12-06T10:30:51.000Z","updated":"2020-12-18T02:35:43.038Z","comments":true,"path":"2020/12/06/Spring/Swagger在线文档/","link":"","permalink":"http://example.com/2020/12/06/Spring/Swagger%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/","excerpt":"Swagger在线文档使用教程…","text":"Swagger在线文档使用教程… SpringBoot集成Swagger 新建一个SpringBoot项目==&gt;web 导入相关依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 编写HelloWorld 配置Swagger1234@Configuration@EnableSwagger2public class SwaggerConfig &#123;&#125; 测试运行 http://localhost:8080/swagger-ui.html 配置Swagger信息Swagger的bean示例Docket 123456789101112131415161718192021222324252627@Configuration@EnableSwagger2public class SwaggerConfig &#123; /** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()); &#125; public ApiInfo apiInfo() &#123; // 作者信息 Contact contact = new Contact(&quot;Marlowe&quot;, &quot;https://xmmarlowe.github.io&quot;, &quot;marlowe246@qq.com&quot;); return new ApiInfo(&quot;Visit CQUT Swagger API Documentation&quot;, &quot;Api Documentation&quot;, &quot;v1.0&quot;, &quot;urn:tos&quot;, contact, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; Swagger配置扫描接口Docket.select() 1234567891011121314151617181920212223/** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() /** * RequestHandlerSelectors，配置要扫描接口的方式 * basePackage:指定要扫描的包 * any():扫描全部 * none():不扫描 * withClassAnnotation:扫描类上的注解，参数是一个注解的反射对象 * withMethodAnnotation：扫描方法上的注解 */ .apis(RequestHandlerSelectors.basePackage(&quot;com.marlowe.swagger.controller&quot;)) // paths(): 过滤什么路径 .paths(PathSelectors.ant(&quot;/marlowe/**&quot;)) .build(); &#125; 配置是否启动swagger 123456789101112131415/** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) // enable是否启动Swagger，如果为false，则swagger不能在浏览器中访问 .enable(false) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.marlowe.swagger.controller&quot;)) .build(); &#125; 我只希望我的Swagger在生产环境中使用，在发布的时候不使用？ 判断是不是生产环境 flag = false 注入enable(flag)123456789101112131415161718192021/** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket(Environment environment) &#123; // 设置要现实的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 获取项目的环境： boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) // enable是否启动Swagger，如果为false，则swagger不能在浏览器中访问 .enable(flag) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.marlowe.swagger.controller&quot;)) .build(); &#125; 配置API文档的分组1.groupName(&quot;Marlowe&quot;) 如何配置多个分组；多个Docket实例即可1234567891011121314@Beanpublic Docket docket1() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;);&#125;@Beanpublic Docket docket2() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;);&#125;@Beanpublic Docket docket3() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;C&quot;);&#125; 实体类配置12345678910111213141516171819package com.marlowe.swagger.pojo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * @program: swagger-demo * @description: * @author: Marlowe * @create: 2020-12-06 19:39 **/@ApiModel(&quot;用户实体类&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) public String username; @ApiModelProperty(&quot;密码&quot;) public String password;&#125; controller12345678910111213141516171819202122232425262728293031323334353637383940414243package com.marlowe.swagger.controller;import com.marlowe.swagger.pojo.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;/** * @program: swagger-demo * @description: * @author: Marlowe * @create: 2020-12-06 18:07 **/@Api(tags = &quot;hello控制类&quot;)@RestControllerpublic class HelloController &#123; @GetMapping(value = &quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; @PostMapping(value = &quot;/user&quot;) public User user() &#123; return new User(); &#125; @ApiOperation(&quot;Hello 控制类&quot;) @GetMapping(value = &quot;/hello2&quot;) public String hello2(@ApiParam(&quot;用户名&quot;) String username) &#123; return &quot;hello&quot; + username; &#125; @ApiOperation(&quot;Post 控制类&quot;) @GetMapping(value = &quot;/postt&quot;) public User post(@ApiParam(&quot;用户&quot;) User user) &#123; return user; &#125;&#125; 总结： 可以通过Swagger给一些比较难理解的属性或者接口，增加注释信息 接口文档实时更新 可以在线测试 【注意点】在正式发布的时候，关闭Swagger！！！ 处于安全考虑，并且节省内存！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Swagger","slug":"Swagger","permalink":"http://example.com/tags/Swagger/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"}],"author":"Marlowe"},{"title":"使用注解开发","slug":"Spring/使用注解开发","date":"2020-12-05T05:40:10.000Z","updated":"2020-12-05T06:18:50.748Z","comments":true,"path":"2020/12/05/Spring/使用注解开发/","link":"","permalink":"http://example.com/2020/12/05/Spring/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"使用注解开发…","text":"使用注解开发… 在Spring4之后，使用注解开发，必须要保证aop的包导入了使用注解需要导入context约束，增加注解的支持！ 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 1.bean2.属性如何注入12345678910@Componentpublic class User &#123; public String name; // 相当于&lt;property name=&quot;name&quot; value=&quot;marlowe2&quot;&gt; @Value(&quot;marlowe2&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 3.衍生的注解@Component有几个衍生注解，我们再web开发中，会按照mvc三层架构分层！ dao【@Repository】 service【@Service】 controller【@Service】这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配Bean 4.自动装配1234- @Autowired:自动装配通过类型。名字 如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value=&quot;xxx&quot;)- @Nullable： 字段标记了这个注解，说明这个字段可以为null- @Resource： 自动装配通过名字。类型 5.作用域1234567891011@Component@Scope(&quot;prototype&quot;)public class User &#123; public String name; // 相当于&lt;property name=&quot;name&quot; value=&quot;marlowe2&quot;&gt; @Value(&quot;marlowe2&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 6.小结xml与注解： xml： 更加万能，适用于任何场合！维护简单方便 注解： 不是自己的类使用不了，维护相对复杂！ xml与注解最佳实践： xml用来管理bean 注解只负责完成属性的注入 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持 123&lt;!--指定要扫描的包，这个包下面的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;com.marlowe&quot;/&gt;&lt;context:annotation-config/&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"注解","slug":"注解","permalink":"http://example.com/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"Marlowe"},{"title":"依赖注入","slug":"Spring/依赖注入","date":"2020-12-05T04:50:54.000Z","updated":"2020-12-05T04:55:07.288Z","comments":true,"path":"2020/12/05/Spring/依赖注入/","link":"","permalink":"http://example.com/2020/12/05/Spring/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"简述依赖注入的三种方式","text":"简述依赖注入的三种方式 构造器注入见文章《IOC创建对象的方式》 Set方式注入【重点】 依赖注入：Set注入！ 依赖：bean对象的创建依赖于容器！ 注入：bean对象中的所有属性，由容器来注入！ 【环境搭建】 复杂类型123456789101112public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 真实测试对象 12345678910public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info;&#125; beans.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--第一种，普通值注入，value--&gt; &lt;bean id=&quot;student&quot; class=&quot;com.marlowe.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;marlowe&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 1234567public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.getName()); &#125;&#125; 完善注入信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.marlowe.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;China&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.marlowe.pojo.Student&quot;&gt; &lt;!--第一种，普通值注入，value--&gt; &lt;property name=&quot;name&quot; value=&quot;marlowe&quot;/&gt; &lt;!--第二种，Bean注入，ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--数组--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;11111111&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;22222222&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LoL&lt;/value&gt; &lt;value&gt;DNF&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--Properties--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;11111&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;marlowe&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 扩展方式注入我们可以使用p命名空间和c命名空间进行注入官方解释： 使用: 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot; p:name=&quot;marlowe&quot; p:age=&quot;18&quot;&gt;&lt;/bean&gt; &lt;!--c命名空间注入，可以通过构造器注入：construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.marlowe.pojo.User&quot; c:name=&quot;marlowe&quot; c:age=&quot;18&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 测试： 123456@Testpublic void test2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;); User user = (User) context.getBean(&quot;user2&quot;); System.out.println(user.toString());&#125; 注意点：p命名和c命名不能直接使用，需要导入xml约束！ 12xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; bean的作用域 单例模式（spring默认机制）1&lt;bean id=&quot;user2&quot; class=&quot;com.marlowe.pojo.User&quot; c:name=&quot;marlowe&quot; c:age=&quot;18&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 原型模式：每次从容器中get的时候，都会产生一个新对象！1&lt;bean id=&quot;user2&quot; class=&quot;com.marlowe.pojo.User&quot; c:name=&quot;marlowe&quot; c:age=&quot;18&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 其余的request、session、application 这些只能在web开发中使用到！","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"http://example.com/tags/DI/"}],"author":"Marlowe"},{"title":"Bean的自动装配","slug":"Spring/Bean的自动装配","date":"2020-12-05T03:55:53.000Z","updated":"2020-12-05T05:38:33.810Z","comments":true,"path":"2020/12/05/Spring/Bean的自动装配/","link":"","permalink":"http://example.com/2020/12/05/Spring/Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","excerpt":"bean的三种自动装配方式…","text":"bean的三种自动装配方式… 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring中有三种装配方式 在xml中显示的配置 在java中显示配置 隐式的自动装配bean【重要】 测试环境搭建：一个人有两个宠物 12345public class People &#123; private String name; private Cat cat; private Dog dog;&#125; byName自动装配123456&lt;!--byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的bean id！--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.marlowe.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;陈浩南&quot;/&gt;&lt;/bean&gt; byType自动装配123456789&lt;bean class=&quot;com.marlowe.pojo.Cat&quot;/&gt;&lt;bean class=&quot;com.marlowe.pojo.Dog&quot;/&gt;&lt;!--byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean！--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.marlowe.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;陈浩南&quot;/&gt;&lt;/bean&gt; 小结： byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！（原理是将set方法后面部分转换成小写，再与id进行比对，例如：setDog ==&gt; id = “dog”、setdog1 ==&gt; id = “dog1”等可以自动注入、但是setDog ==&gt; id = “Dog”就不行） byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！ 使用注解实现自动装配JDK1.5支持的注解，Spring2.5就支持注解了！要使用注解须知： 导入约束。context约束 配置注解的支持 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方式上使用！ 使用Autowired，我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName！ 科普： 1@Nullable 字段标记了这个注解，说明这个字段可以为null 123 public @interface Autowired &#123; boolean required() default true;&#125; 测试代码 12345678public class People &#123; // 如果显示定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name;&#125;如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成额时候、我们可以使用@Qualifier(value = “xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 1234567@Autowired@Qualifier(value = &quot;cat11&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog11&quot;)private Dog dog; @Resource注解 1234567public class People &#123; @Resource(name = &quot;cat1&quot;) private Cat cat; @Resource private Dog dog;&#125; 小结：@Autowired和@Resource的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired 通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired 通过byType的方式实现。@Resource默认通过byName的方式实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Bean","slug":"Bean","permalink":"http://example.com/tags/Bean/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}],"author":"Marlowe"},{"title":"IOC创建对象的方式","slug":"Spring/IOC创建对象的方式","date":"2020-12-04T13:02:41.000Z","updated":"2020-12-05T04:49:49.390Z","comments":true,"path":"2020/12/04/Spring/IOC创建对象的方式/","link":"","permalink":"http://example.com/2020/12/04/Spring/IOC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"IOC创建对象的三种方式…","text":"IOC创建对象的三种方式… 下标 1234&lt;!--第一种方式：下标赋值--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;狂神说Java&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 类型 1234&lt;!--第二种方式：不建议使用！通过类型创建--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;狂神&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 参数名 1234&lt;!--第三种方式，直接通过参数名来设置--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;狂神说Java&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"http://example.com/tags/IOC/"}],"author":"Marlowe"},{"title":"集合类不安全","slug":"JUC/集合类不安全","date":"2020-12-03T13:49:32.000Z","updated":"2020-12-05T06:30:38.804Z","comments":true,"path":"2020/12/03/JUC/集合类不安全/","link":"","permalink":"http://example.com/2020/12/03/JUC/%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8/","excerpt":"111","text":"111 List不安全12345678910111213141516171819202122232425262728293031323334353637383940package com.marlowe.unsafe;import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;/** * @program: juc * @description: java.util.ConcurrentModificationException 并发修改异常 * @author: Marlowe * @create: 2020-12-03 21:00 **/public class ListTest &#123; public static void main(String[] args) &#123; /** * 并发下ArrayList 不安全的 * * 解决方法： * 1、List&lt;String&gt; list = new Vector&lt;&gt;(); * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ /** * CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 * 多个线程调用的时候，list，读取的时候，固定的，写入的（覆盖） * 在写入的时候避免覆盖，造成数据问题！ * CopyOnWriteArrayList 比 Vector 好在那里 前者是lock，后者是是synchronized */ List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; Set不安全123456789101112131415161718192021222324252627282930package com.marlowe.unsafe;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;/** * @program: juc * @description: 同理可证 ：java.util.ConcurrentModificationException * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); * @author: Marlowe * @create: 2020-12-03 21:53 **/public class SetTest &#123; public static void main(String[] args) &#123; // Set&lt;String&gt; set = new HashSet&lt;&gt;(); // Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; set.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(set); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; HashSet 底层是什么？1234567891011public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;// add set本质就是map key是无法重复的public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;// PRESENTprivate static final Object PRESENT = new Object(); Map 不安全回顾Map基本操作 12345678910111213141516171819202122232425import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;/** * @program: juc * @description: java.util.ConcurrentModificationException * @author: Marlowe * @create: 2020-12-03 22:11 **/public class MapTest &#123; public static void main(String[] args) &#123; // map是这样用的吗？不是，工作中不用HashMap // HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125;","categories":[{"name":"JUC","slug":"JUC","permalink":"http://example.com/categories/JUC/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"list","slug":"list","permalink":"http://example.com/tags/list/"},{"name":"线程不安全","slug":"线程不安全","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"}],"author":"Marlowe"},{"title":"8锁问题","slug":"JUC/8锁问题","date":"2020-12-03T12:08:54.000Z","updated":"2020-12-05T05:29:29.769Z","comments":true,"path":"2020/12/03/JUC/8锁问题/","link":"","permalink":"http://example.com/2020/12/03/JUC/8%E9%94%81%E9%97%AE%E9%A2%98/","excerpt":"待完善…","text":"待完善… 小结 new this 具体的一个手机static Class 唯一的一个模板","categories":[{"name":"JUC","slug":"JUC","permalink":"http://example.com/categories/JUC/"}],"tags":[{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"synchronized和Lock区别","slug":"JUC/synchronized和Lock区别","date":"2020-12-02T14:19:29.000Z","updated":"2020-12-05T05:29:42.139Z","comments":true,"path":"2020/12/02/JUC/synchronized和Lock区别/","link":"","permalink":"http://example.com/2020/12/02/JUC/synchronized%E5%92%8CLock%E5%8C%BA%E5%88%AB/","excerpt":"简述 synchronized 和 Lock 区别…","text":"简述 synchronized 和 Lock 区别… synchronized 内置的Java关键字；Lock 是一个Java类 synchronized 无法判断获取锁的状态；Lock 可以判断是否获取了锁 synchronized 会自动释放锁；Lock 必须要手动释放锁！ 如果不释放，死锁 synchronized 线程1（获得锁，阻塞）、线程2（等待、傻傻的等）；Lock 锁就不一定会等待下去 synchronized 可重入锁，不可以中断的，非公平的；Lock ，可重入锁，可以判断锁，非公平（可以自己设置） synchronized 适合锁少量的代码同步问题；Lock 适合锁大量的！","categories":[{"name":"JUC","slug":"JUC","permalink":"http://example.com/categories/JUC/"}],"tags":[{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"设计模式-策略","slug":"设计模式/设计模式-策略","date":"2020-11-29T12:38:08.000Z","updated":"2020-11-30T04:04:57.448Z","comments":true,"path":"2020/11/29/设计模式/设计模式-策略/","link":"","permalink":"http://example.com/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/","excerpt":"在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。","text":"在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 优缺点及注意优点 算法可以自由切换。 避免使用多重条件判断。 扩展性良好。 缺点 策略类会增多。 所有策略类都需要对外暴露。 注意如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 实现策略角色 123456public interface Strategy &#123; /** * 算法方法 */ public void algorithmInterface();&#125; 以下三个实现类为具体的策略角色 123456public class ConcreteStrategyA implements Strategy&#123; @Override public void algorithmInterface() &#123; System.out.println(&quot;具体的策略A&quot;); &#125;&#125; 123456public class ConcreteStrategyB implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println(&quot;具体的策略B&quot;); &#125;&#125; 1234567public class ConcreteStrategyC implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println(&quot;具体的策略C&quot;); &#125;&#125; Context上下文 1234567891011121314public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 上下文接口,执行对应策略 */ public void executeStrategy() &#123; strategy.algorithmInterface(); &#125;&#125; 客户端 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.executeStrategy(); context = new Context(new ConcreteStrategyB()); context.executeStrategy(); context = new Context(new ConcreteStrategyC()); context.executeStrategy(); &#125;&#125; 结果： 123具体的策略A具体的策略B具体的策略C","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://example.com/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"策略","slug":"策略","permalink":"http://example.com/tags/%E7%AD%96%E7%95%A5/"}],"author":"Marlowe"},{"title":"JsonUtils","slug":"自定义工具类/JsonUtils","date":"2020-11-27T13:34:41.000Z","updated":"2020-12-11T02:07:56.029Z","comments":true,"path":"2020/11/27/自定义工具类/JsonUtils/","link":"","permalink":"http://example.com/2020/11/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/JsonUtils/","excerpt":"","text":"123456789101112131415161718192021222324252627282930package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; public static String getJson(Object object,String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try &#123; return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125;","categories":[{"name":"自定义工具类","slug":"自定义工具类","permalink":"http://example.com/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"Json","slug":"Json","permalink":"http://example.com/tags/Json/"},{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"}],"author":"Marlowe"},{"title":"设计模式-代理","slug":"设计模式/设计模式-代理","date":"2020-11-27T08:36:13.000Z","updated":"2021-03-17T07:13:40.626Z","comments":true,"path":"2020/11/27/设计模式/设计模式-代理/","link":"","permalink":"http://example.com/2020/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/","excerpt":"在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。","text":"在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 主要解决的问题在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 优缺点及注意优点 职责清晰。 高扩展性。 智能化。缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 注意 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现静态代理角色分析: 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作 客户：访问代理对象的人！ 接口1234567public interface Rent &#123; /** * 出租房屋 */ public void rent();&#125; 真实角色123456public class Landlord implements Rent &#123; @Override public void rent() &#123; System.out.println(&quot;房东要出租房子！&quot;); &#125;&#125; 代理角色12345678910111213141516171819202122232425262728293031public class Proxy implements Rent &#123; private Landlord landlord; public Proxy() &#123; &#125; public Proxy(Landlord landlord) &#123; this.landlord = landlord; &#125; @Override public void rent() &#123; seeHouse(); landlord.rent(); signContract(); fee(); &#125; public void seeHouse() &#123; System.out.println(&quot;中介带你看房&quot;); &#125; public void signContract() &#123; System.out.println(&quot;签合同&quot;); &#125; public void fee() &#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; 客户端访问代理角色1234567891011public class Client &#123; public static void main(String[] args) &#123; // 房东要租房子 Landlord landlord = new Landlord(); // 代理,中介帮房东租房子，但是 代理一般会有一些附属操作 Proxy proxy = new Proxy(landlord); // 你不用面对房东，直接找中介即可 proxy.rent(); &#125;&#125; 12345结果：中介带你看房房东要出租房子！签合同收中介费 Spring AOP 代理模式的好处： 可以是真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 缺点： 一个真实的角色就会产生一个代理角色；代码量会翻倍，开发效率会变低~ 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口 — JDK动态代理 基于类：cglib java字节码实现：javasist 需要两节两个类：Proxy，InvocationHandler：调用处理程序 动态代理的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要实现了同一接口即可。 接口123456789public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 实现类12345678910111213141516171819202122public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 动态代理工具类（通用方法）12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyInvocationHandlerUtil implements InvocationHandler &#123; /** * 被代理的接口 */ private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; /** * 生成得到代理类 * * @return */ public Object getProxy() &#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /** * 处理代理实例，并返回结果 * * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String msg) &#123; System.out.println(&quot;[Debug] 使用了&quot; + msg + &quot;方法&quot;); &#125;&#125; 客户端访问代理角色12345678910111213public class Client2 &#123; public static void main(String[] args) &#123; // 真实角色 UserServiceImpl userService = new UserServiceImpl(); // 代理角色，不存在 ProxyInvocationHandlerUtil pihu = new ProxyInvocationHandlerUtil(); // 设置需要代理的对象 pihu.setTarget(userService); // 动态生成代理类 UserService proxy = (UserService) pihu.getProxy(); proxy.add(); &#125;&#125; 123结果：[Debug] 使用了add方法增加了一个用户","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"代理","slug":"代理","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://example.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"author":"Marlowe"},{"title":"设计模式-单例","slug":"设计模式/设计模式-单例","date":"2020-11-22T23:17:03.000Z","updated":"2020-12-05T04:44:01.063Z","comments":true,"path":"2020/11/23/设计模式/设计模式-单例/","link":"","permalink":"http://example.com/2020/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。","text":"单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 介绍单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。 这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。优缺点及注意 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。注意getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现饿汉式12345678910111213141516171819202122232425262728package com.marlowe.singleton;/** * @program: GoF23 * @description: 饿汉式 * @author: Marlowe * @create: 2020-11-23 15:07 **/public class Hungry &#123; /** * 可能会浪费空间 */ private byte[] data1 = new byte[1024 * 1024]; private byte[] data2 = new byte[1024 * 1024]; private byte[] data3 = new byte[1024 * 1024]; private Hungry() &#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() &#123; return HUNGRY; &#125;&#125; DCL(Double CheckLock 双重校验锁(线程安全、效率高))懒汉式，深究！注意： 如果不使用volatile关键词修饰，可能会导致拿到的对象是未被初始化的。具体原因见代码注释部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.marlowe.singleton;import java.lang.reflect.Constructor;import java.lang.reflect.Field;/** * @program: GoF23 * @description: 懒汉式 * @author: Marlowe * @create: 2020-11-23 15:11 **/public class LazyMan &#123; private static boolean marlowe = false; private LazyMan() &#123; synchronized (LazyMan.class) &#123; if (marlowe == false) &#123; marlowe = true; &#125; else &#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot;ok&quot;); &#125; private volatile static LazyMan lazyMan; /** * 双重检测所模式的 懒汉式单例 DCL懒汉式 * * @return */ public static LazyMan getInstance() &#123; if (lazyMan == null) &#123; synchronized (LazyMan.class) &#123; if (lazyMan == null) &#123; // 不是原子性操作 lazyMan = new LazyMan(); /** * 1. 分配内存空间 * 2. 执行构造方法，初始化对象 * 3. 把这个对象指向这个空间 * * 预期执行顺序 1-&gt;2-&gt;3 * 由于JVM具有指令重排的特性 实际顺序可能是1-&gt;3-&gt;2 * 指令重排在单线程的环境下不会出现问题，但是在多线程环境下可能会导致一个线程获得还没有初始化的实例 * 例如：A线程执行了1,3，此时B线程调用getInstance() 后发现 lazyMan 不为空，因此直接返回 lazyMan * 但此时 lazyMan 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行 * */ &#125; &#125; &#125; return lazyMan; &#125; /** * 反射 * * @param args */ public static void main(String[] args) throws Exception &#123; Field marlowe = LazyMan.class.getDeclaredField(&quot;marlowe&quot;); marlowe.setAccessible(true); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); LazyMan instance2 = declaredConstructor.newInstance(); marlowe.set(instance, false); System.out.println(instance); System.out.println(instance2); &#125;&#125; 静态内部类12345678910111213141516171819202122package com.marlowe.singleton;/** * @program: GoF23 * @description: 静态内部类 * @author: Marlowe * @create: 2020-11-23 15:32 **/public class Holder &#123; private Holder() &#123; &#125; public static Holder getInstance() &#123; return InnerClass.HOLDER; &#125; public static class InnerClass &#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 单例不安全，因为有反射12345678910111213141516171819202122232425262728293031package com.marlowe.singleton;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * @program: GoF23 * @description: enum 是什么？ 本身也是一个class类 * @author: Marlowe * @create: 2020-11-23 15:49 **/public enum EnumSingleton &#123; INSTANCE; public EnumSingleton getInstance() &#123; return INSTANCE; &#125;&#125;class Test &#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123; EnumSingleton instance1 = EnumSingleton.INSTANCE; Constructor&lt;EnumSingleton&gt; declaredConstructor = EnumSingleton.class.getDeclaredConstructor(String.class, int.class); declaredConstructor.setAccessible(true); EnumSingleton instance2 = declaredConstructor.newInstance(); System.out.println(instance1); System.out.println(instance2); &#125;&#125; 枚举类型的最终反编译原码里面是有参构造方法 经验之谈 单例对象 占用资源少，不需要延时加载，枚举 好于 饿汉 单例对象 占用资源多，需要延时加载，静态内部类 好于 懒汉式 参考文献blog.unclezs.com","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"单例","slug":"单例","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"author":"Marlowe"},{"title":"设计模式-工厂","slug":"设计模式/设计模式-工厂","date":"2020-11-20T08:49:24.000Z","updated":"2020-12-05T04:44:01.060Z","comments":true,"path":"2020/11/20/设计模式/设计模式-工厂/","link":"","permalink":"http://example.com/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82/","excerpt":"工厂设计模式很常用，分为简单工厂，工厂方法和抽象工厂。","text":"工厂设计模式很常用，分为简单工厂，工厂方法和抽象工厂。 核心本质 实例化对象不使用new，用工厂方法代替 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们实现类解耦 OOP七大原则 开闭原则：一个软件的实体应当对扩展开放，对修改关闭 依赖倒转原则：要针对接口编程，不要针对实现编程 迪米特法则：只与你直接的朋友通信，而避免与陌生人通信 应用场景 JDK中Calendar的getInstance方法 JDBC中的Connection对象的获取 Spring中IOC容器创建管理bean对象 反射中Class对象的newInstance方法 三种模式简单工厂(Simple Factory)用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码） 如下图需要扩展一类新车–Ford，需要扩展车工厂里面的代码 Car接口 123456789101112package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 车接口 * @author: Marlowe * @create: 2020-11-20 17:00 **/public interface Car &#123; public void name();&#125; 以下两个实体类实现Car接口 123456789101112131415package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 宝马 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Bmw implements Car &#123; @Override public void name() &#123; System.out.println(&quot;我是宝马！&quot;); &#125;&#125; 123456789101112131415package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 特斯拉 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Tesla implements Car&#123; @Override public void name() &#123; System.out.println(&quot;我是特斯拉！&quot;); &#125;&#125; CarFactory工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 汽车工厂 * 静态工厂模式 * 开闭原则 * @author: Marlowe * @create: 2020-11-20 17:02 **/public class CarFactory &#123; /** * 方法一 * * @param car * @return */ public static Car getCar(String car) &#123; if (&quot;宝马&quot;.equals(car)) &#123; return new Bmw(); &#125; else if (&quot;特斯拉&quot;.equals(car)) &#123; return new Tesla(); &#125; else &#123; return null; &#125; &#125; /** * 方法二 * * @return */ public static Car getBmw() &#123; return new Bmw(); &#125; public static Car getTesla() &#123; return new Tesla(); &#125;&#125; 主类 1234567891011121314151617181920212223package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 顾客 * @author: Marlowe * @create: 2020-11-20 17:03 **/public class Comsumer &#123; public static void main(String[] args) &#123; System.out.println(&quot;通过方式1获取:&quot;); Car car1 = CarFactory.getCar(&quot;宝马&quot;); Car car2 = CarFactory.getCar(&quot;特斯拉&quot;); car1.name(); car2.name(); System.out.println(&quot;通过方式2获取:&quot;); Car bmw = CarFactory.getBmw(); Car tesla = CarFactory.getTesla(); bmw.name(); tesla.name(); &#125;&#125; 1234567结果：通过方式1获取:我是宝马！我是特斯拉！通过方式2获取:我是宝马！我是特斯拉！ 工厂方法(Factory Method)用来生产同一等级结构中的固定产品（支持增加任意产品） 如下图需要扩展一类新车–Ford，横向扩展即可 Car接口 123456789101112package com.marlowe.factory.method;/** * @program: GoF23 * @description: 车接口 * @author: Marlowe * @create: 2020-11-20 17:00 **/public interface Car &#123; public void name();&#125; 以下两个实体类实现Car接口 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: 宝马 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Bmw implements Car &#123; @Override public void name() &#123; System.out.println(&quot;我是宝马！&quot;); &#125;&#125; 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: 特斯拉 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Tesla implements Car &#123; @Override public void name() &#123; System.out.println(&quot;我是特斯拉！&quot;); &#125;&#125; CarFactory接口 123456789101112package com.marlowe.factory.method;/** * @program: GoF23 * @description: 工厂方法模式 * @author: Marlowe * @create: 2020-11-20 18:54 **/public interface CarFactory &#123; Car getCar();&#125; 以下两个类实现CarFactory接口 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: * @author: Marlowe * @create: 2020-11-20 18:55 **/public class BmwFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Bmw(); &#125;&#125; 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: * @author: Marlowe * @create: 2020-11-20 18:55 **/public class TeslaFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Tesla(); &#125;&#125; 主类 123456789101112131415161718192021package com.marlowe.factory.method;import com.marlowe.factory.simple.CarFactory;/** * @program: GoF23 * @description: 顾客 * @author: Marlowe * @create: 2020-11-20 17:03 **/public class Comsumer &#123; public static void main(String[] args) &#123; Car car1 = new TeslaFactory().getCar(); Car car2 = new BmwFactory().getCar(); Car car3 = new FordFactory().getCar(); car1.name(); car2.name(); car3.name(); &#125;&#125; 1234结果：我是特斯拉！我是宝马！我是福特！ 抽象工厂(Abstract Factory)围绕一个超级工厂创建其他工厂，该工厂又称为其他工厂的工厂 抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类 抽象产品工厂 123456789101112131415161718192021222324package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 抽象产品工厂 * @author: Marlowe * @create: 2020-11-21 10:54 **/public interface IProductFactory &#123; /** * 生产手机 * * @return */ IPhoneProduct iPhoneProduct(); /** * 生产路由器 * * @return */ IRouterProduct iRouterProduct();&#125; 小米工厂 1234567891011121314151617181920package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 小米工厂 * @author: Marlowe * @create: 2020-11-21 10:57 **/public class XiaomiFactory implements IProductFactory &#123; @Override public IPhoneProduct iPhoneProduct() &#123; return new XiaomiPhone(); &#125; @Override public IRouterProduct iRouterProduct() &#123; return new XiaomiRouter(); &#125;&#125; 华为工厂 1234567891011121314151617181920package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 华为工厂 * @author: Marlowe * @create: 2020-11-21 10:57 **/public class HuaweiFactory implements IProductFactory &#123; @Override public IPhoneProduct iPhoneProduct() &#123; return new HuaweiPhone(); &#125; @Override public IRouterProduct iRouterProduct() &#123; return new HuaweiRouter(); &#125;&#125; 手机产品接口 123456789101112131415161718192021222324252627282930package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 手机产品接口 * @author: Marlowe * @create: 2020-11-20 22:38 **/public interface IPhoneProduct &#123; /** * 开机 */ void start(); /** * 关机 */ void shutdown(); /** * 打电话 */ void call(); /** * 发信息 */ void sendMessage();&#125; 以下小米手机和华为手机分别实现手机产品接口 1234567891011121314151617181920212223242526272829303132package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 小米手机 * @author: Marlowe * @create: 2020-11-20 22:41 **/public class XiaomiPhone implements IPhoneProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开小米手机&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭小米手机&quot;); &#125; @Override public void call() &#123; System.out.println(&quot;小米手机打电话&quot;); &#125; @Override public void sendMessage() &#123; System.out.println(&quot;小米手机发信息&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 华为手机 * @author: Marlowe * @create: 2020-11-20 22:44 **/public class HuaweiPhone implements IPhoneProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开华为手机&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭华为手机&quot;); &#125; @Override public void call() &#123; System.out.println(&quot;华为手机打电话&quot;); &#125; @Override public void sendMessage() &#123; System.out.println(&quot;华为手机发信息&quot;); &#125;&#125; 路由器产品接口 123456789101112131415161718192021222324252627282930package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 路由器产品接口 * @author: Marlowe * @create: 2020-11-20 22:40 **/public interface IRouterProduct &#123; /** * 开机 */ void start(); /** * 关机 */ void shutdown(); /** * 打开wifi */ void openWifi(); /** * 设置 */ void setting();&#125; 以下小米路由器和华为路由器分别实现路由器产品接口 12345678910111213141516171819202122232425262728293031package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 小米路由器 * @author: Marlowe * @create: 2020-11-20 22:46 **/public class XiaomiRouter implements IRouterProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开小米路由器&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭小米路由器&quot;); &#125; @Override public void openWifi() &#123; System.out.println(&quot;打开小米路由器wifi&quot;); &#125; @Override public void setting() &#123; System.out.println(&quot;设置小米路由器&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 华为路由器 * @author: Marlowe * @create: 2020-11-20 22:46 **/public class HuaweiRouter implements IRouterProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开华为路由器&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭华为路由器&quot;); &#125; @Override public void openWifi() &#123; System.out.println(&quot;打开华为路由器wifi&quot;); &#125; @Override public void setting() &#123; System.out.println(&quot;设置华为路由器&quot;); &#125;&#125; 主类 12345678910111213141516171819202122232425262728293031package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 客户端 * @author: Marlowe * @create: 2020-11-21 11:01 **/public class Client &#123; public static void main(String[] args) &#123; System.out.println(&quot;===============小米系列产品=================&quot;); XiaomiFactory xiaomiFactory = new XiaomiFactory(); IPhoneProduct iPhoneProduct = xiaomiFactory.iPhoneProduct(); iPhoneProduct.call(); iPhoneProduct.sendMessage(); IRouterProduct iRouterProduct = xiaomiFactory.iRouterProduct(); iRouterProduct.openWifi(); System.out.println(); System.out.println(&quot;===============华为系列产品=================&quot;); HuaweiFactory huaweiFactory = new HuaweiFactory(); iPhoneProduct = huaweiFactory.iPhoneProduct(); iPhoneProduct.call(); iPhoneProduct.sendMessage(); IRouterProduct iRouterProduct1 = huaweiFactory.iRouterProduct(); iRouterProduct1.openWifi(); &#125;&#125; 12345678910结果：===============小米系列产品=================小米手机打电话小米手机发信息打开小米路由器wifi===============华为系列产品=================华为手机打电话华为手机发信息打开华为路由器wifi 适用场景： 客户端（应用层）不依赖与产品类实例如何被创建、实现等细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复代码 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现 优点 具体产品在应用层的代码隔离，无需关心创建的细节 将一个系列的产品统一到一起管理 缺点 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难 增加了系统的抽象性和理解难度 小结 简单工厂模式（静态工厂模式）虽然某种程度上不符合设计原则，但实际使用最多！ 工厂方法模式不修改已有类的前提下，通过新增新的工厂类实现扩展。 抽象工厂模式不可以增加产品，可以增加产品族！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"工厂","slug":"工厂","permalink":"http://example.com/tags/%E5%B7%A5%E5%8E%82/"}],"author":"Marlowe"},{"title":"设计模式-模板","slug":"设计模式/设计模式-模板","date":"2020-11-20T07:06:57.000Z","updated":"2020-12-05T04:44:01.103Z","comments":true,"path":"2020/11/20/设计模式/设计模式-模板/","link":"","permalink":"http://example.com/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF/","excerpt":"一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。","text":"一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 介绍在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 主要解决了一些方法通用，却在每一个子类都重新写了这一方法。 使用场景： 有多个子类共有的方法，且逻辑相同。 重要的、复杂的方法，可以考虑为模板方法。 优缺点及注意优点 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现。 缺点每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 注意事项为防止恶意操作，一般模板方法都加上 final 关键词。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.marlowe;/** * @program: GoF23 * @description: 模板方法模式 * @author: Marlowe * @create: 2020-11-21 16:11 **/public class TemplateMethodPattern &#123; public static void main(String[] args) &#123; Cooking cooking = new CookingFood(); cooking.cook(); &#125;&#125;/** * 做饭抽象类 */abstract class Cooking &#123; protected abstract void step1(); protected abstract void step2(); /** * 模板方法 */ public final void cook() &#123; System.out.println(&quot;开始做饭:&quot;); step1(); step2(); System.out.println(&quot;做饭结束:&quot;); &#125;&#125;/** * 抽象类的具体实现 */class CookingFood extends Cooking &#123; @Override protected void step1() &#123; System.out.println(&quot;放鸡蛋和西红柿&quot;); &#125; @Override protected void step2() &#123; System.out.println(&quot;少放盐多放味精&quot;); &#125;&#125; 12345结果：开始做饭:放鸡蛋和西红柿少放盐多放味精做饭结束:","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"模板","slug":"模板","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://example.com/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"author":"Marlowe"},{"title":"对链表进行插入排序","slug":"Leetcode题解/对链表进行插入排序","date":"2020-11-19T16:37:34.000Z","updated":"2020-12-05T04:44:01.019Z","comments":true,"path":"2020/11/20/Leetcode题解/对链表进行插入排序/","link":"","permalink":"http://example.com/2020/11/20/Leetcode%E9%A2%98%E8%A7%A3/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"147. 对链表进行插入排序对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 分析由gif可以看出，链表在插入排序过程中由排序好的部分和当前节点以及后面的节点组成，因此可以去排序好部分的下一个元素作为当前待排序节点，当当前节点为null时，所有节点排序结束。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; // 如果头节点为空，直接返回 if(head == null)&#123; return head; &#125; // 新建哑节点，保存头结点信息 ListNode dummy = new ListNode(0); dummy.next = head; // 排序好部分最后一个元素 ListNode lastSorted = head; // 当前节点（待排序元素） ListNode curr = head.next; while(curr != null)&#123; // 如果当前元素不用排序，将排序链表增长，也即lastSorted后移 if(lastSorted.val &lt;= curr.val)&#123; lastSorted = lastSorted.next; &#125;else&#123; // 从头结点开始找，pre保存前一个元素 ListNode pre = dummy; while(pre.next.val &lt;= curr.val)&#123; pre = pre.next; &#125; // 将curr节点插入到对应位置 lastSorted.next = curr.next; curr.next = pre.next; pre.next = curr; &#125; // 更新当前节点为排序好链表下一个节点 curr = lastSorted.next; &#125; return dummy.next; &#125;&#125;","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"插入排序","slug":"插入排序","permalink":"http://example.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"author":"Marlowe"},{"title":"设计模式-外观","slug":"设计模式/设计模式-外观","date":"2020-11-18T14:05:41.000Z","updated":"2020-12-05T04:44:01.066Z","comments":true,"path":"2020/11/18/设计模式/设计模式-外观/","link":"","permalink":"http://example.com/2020/11/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82/","excerpt":"要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易使用。","text":"要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易使用。 介绍外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。传统模式 外观模式 优缺点及注意优点 为复杂的模块或子系统提供外界访问的模块。 子系统相对独立。 预防低水平人员带来的风险。 缺点 不符合开闭原则。所谓的开闭原则是软件工程里面一个最基本的原则：对扩展开放，对修改关闭。换句话说，你的系统可以提供新的功能模块而不必进行修改。 注意事项在层次化结构中，可以使用外观模式定义系统中每一层的入口。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243package com.marlowe;/** * @program: GoF23 * @description: 外观模式 * @author: Marlowe * @create: 2020-11-21 17:04 **/public class FacadePattern &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); System.out.println(facade.prove()); &#125;&#125;class SubFlow1 &#123; boolean isTrue() &#123; return true; &#125;&#125;class SubFlow2 &#123; boolean isOk() &#123; return true; &#125;&#125;class SubFlow3 &#123; boolean isGoodMan() &#123; return true; &#125;&#125;class Facade &#123; SubFlow1 subFlow1 = new SubFlow1(); SubFlow2 subFlow2 = new SubFlow2(); SubFlow3 subFlow3 = new SubFlow3(); boolean prove() &#123; return subFlow1.isTrue() &amp;&amp; subFlow2.isOk() &amp;&amp; subFlow3.isGoodMan(); &#125;&#125; 12结果：true","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://example.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"外观","slug":"外观","permalink":"http://example.com/tags/%E5%A4%96%E8%A7%82/"}],"author":"Marlowe"},{"title":"DockerFile","slug":"Docker/DockerFile","date":"2020-11-16T17:06:17.000Z","updated":"2020-12-05T04:44:00.874Z","comments":true,"path":"2020/11/17/Docker/DockerFile/","link":"","permalink":"http://example.com/2020/11/17/Docker/DockerFile/","excerpt":"","text":"dockerfile 是用来构建docker镜像的文件！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}],"author":"Marlowe"},{"title":"容器数据卷","slug":"Docker/容器数据卷","date":"2020-11-16T12:10:54.000Z","updated":"2020-12-05T04:44:00.882Z","comments":true,"path":"2020/11/16/Docker/容器数据卷/","link":"","permalink":"http://example.com/2020/11/16/Docker/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/","excerpt":"","text":"什么是容器数据卷docker的理念回顾将应用和环境打包成一个镜像！数据？如果数据都在容器中，那么容器一删除，数据就会丢失！==需求：数据可以持久化==MySQL，容器删了，删库跑路！==需求：MySQL数据可以存储在本地！==容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！总结一句话：容器的持久化和同步操作！容器建也是可以数据共享的！ 使用数据卷 方式一：直接使用命令来挂载 -v 123456docker run -it -v 主机目录：容器内目录# 测试[root@hecs-x-large-2-linux-20200425095544 home]# docker run -it -v /home/ceshi:/home centos /bin/bash# 启动起来的时候我们可以通过docker inspect 容器id 测试：1、停止容器2、宿主机上修改文件3、启动容器4、容器内的数据依旧是同步的！好处：我们以后修改只需要在本地修改即可，容器内会自动同步！ 实战：安装MySQL思考：MySQL的数据持久化问题！ 123456789101112131415161718# 获取镜像[root@hecs-x-large-2-linux-20200425095544 home]# docker pull mysql:5.7# 运行容器，需要做数据挂载！ # 安装启动mysql，需要配置密码的，这是注意点# 官当测试： docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 启动我们的-d 后台运行-p 端口映射-v 卷挂载-e 环境配置--name 容器名字[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7# 启动成功之后，我们在本地使用navcat来连接测试一下# navcat-连接到服务器的3310 ----3310和容器内的3306映射，这个时候我们就可以连接上了！# 在本地测试创建一个数据库，查看一下我们的映射路径是否ok！ 加入我们将容器删除发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！ 具名和匿名挂载12345678910111213141516171819# 匿名挂载-v 容器内路径！docker run -d -P --name nginx01 -v /etc/nginx nginx# 查看所有的 volume 的情况[root@hecs-x-large-2-linux-20200425095544 ~]# docker volume lsDRIVER VOLUME NAMElocal 7be1d9b8c43e3b6bedc76ab75894eb8b8a8423e83ef2c4e9cf8b4a22ee4d9f2b# 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内路径，没有写容器外路径！# 具名挂载[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginx86efd65c8724a4485ae7bb75b75ec8ed62a225cb33d0c75ed1b6b3652500f5e9[root@hecs-x-large-2-linux-20200425095544 ~]# docker volume lslocal juming-nginx# 通过 -v 卷名：容器内路径# 查看一下这个卷 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volume/xxx/_data我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的具名挂载 1234如何确定是具名挂载还是匿名挂载，还是指定路径挂载！-v 容器内路径 # 匿名挂载-v 卷名：容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载！ 拓展： 123456789# 通过 -v 容器内路径：ro rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写# 一旦这个设置了容器权限。容器对我们挂载出来的内容就限定了！docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ 初识DockerfileDockerfile就是用来构建docker镜像的构建文件！ 命令脚本！先体验一下！通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！ 1234567891011# 创建一个dockerfile文件，名字可以随机 建议Dockerfile# 文件中的内容 指令(大写) 参数FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;---end---&quot;CMD /bin/bash# 这里的每个命令，就是镜像的一层！ 1# 启动自己写的容器 这个卷和外部一定有一个同步的目录！ 这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像！假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名:容器内路径！ 数据卷容器多个mysql同步数据！ 123# 测试：可以删除docker01，查看一下docker02和docker03是否还可以访问这个文件# 测试依旧可以访问(拷贝的概念) 多个mysql实现数据共享 12345[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root --name mysql02 --volumes-form mysql01 mysql:5.7# 这个时候，可以实现两个容器数据同步！ 结论：容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦持久到了本地，这个时候，本地的数据是不会删除的！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}],"author":"Marlowe"},{"title":"Docker镜像讲解","slug":"Docker/Docker镜像讲解","date":"2020-11-16T11:46:45.000Z","updated":"2020-12-05T04:44:00.878Z","comments":true,"path":"2020/11/16/Docker/Docker镜像讲解/","link":"","permalink":"http://example.com/2020/11/16/Docker/Docker%E9%95%9C%E5%83%8F%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"如何提交一个自己的镜像 commit镜像1234docker commit 提交容器成为一个新的副本# 命令和git原理类似docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名：[TAG] 实战测试 1234567891011# 1、启动一个默认的tomcat[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -it -p 8080:8080 tomcat# 2、发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认webapps下面是没有文件的！# 3、我自己拷贝进去了基本的文件root@186285ef065e:/usr/local/tomcat# cp -r webapps.dist/* webapps# 4、将我们操作过的容器通过commit提交为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像[root@hecs-x-large-2-linux-20200425095544 ~]# docker commit -a=&quot;marlowe&quot; -m=&quot;add web app&quot; 186285ef065e tomcat02:1.0 1如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比以前学习VM的时候，快照！ 到这里才算是入门Docker！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}],"author":"Marlowe"},{"title":"Docker常用命令","slug":"Docker/Docker常用命令","date":"2020-11-11T08:16:31.000Z","updated":"2020-12-05T04:44:01.217Z","comments":true,"path":"2020/11/11/Docker/Docker常用命令/","link":"","permalink":"http://example.com/2020/11/11/Docker/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"帮助命令123docker version # 显示docker的版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help # 帮助命令 帮助文档地址：https://docs.docker.com/reference/ 镜像命令docker images 查看所有本地的主机上的镜像 123456789[root@hecs-x-large-2-linux-20200425095544 home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 8.0 db2b37ec6181 2 weeks ago 545MBmysql latest db2b37ec6181 2 weeks ago 545MBhello-world latest bf756fb1ae65 10 months ago 13.3kB# 可选项 -a，--all # 列出所有的镜像 -q，--quiet # 只显示镜像的id docker search 搜索镜像 12345678910[root@hecs-x-large-2-linux-20200425095544 home]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL mysql MySQL is a widely used, open-source relation… 10148 [OK] # 可选项，通过收藏来过滤--filter=STARS=3000 # 搜索出来的镜像就是STARS大于3000的[root@hecs-x-large-2-linux-20200425095544 home]# docker search mysql --filter=stars=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10148 [OK] mariadb MariaDB is a community-developed fork of MyS… 3737 [OK] docker pull 下载镜像 12345678910111213141516171819202122# 下载镜像 docker pull 镜像名[:tag][root@hecs-x-large-2-linux-20200425095544 ~]# docker pull mysql:8.08.0: Pulling from library/mysql # 如果不写tag，默认就是latestbb79b6b2107f: Pull complete 49e22f6fb9f7: Pull complete 842b1255668c: Pull complete 9f48d1f43000: Pull complete c693f0615bce: Pull complete 8a621b9dbed2: Pull complete 0807d32aef13: Pull complete a56aca0feb17: Pull complete de9d45fd0f07: Pull complete 1d68a49161cc: Pull complete d16d318b774e: Pull complete 49e112c55976: Pull complete Digest: sha256:8c17271df53ee3b843d6e16d46cff13f22c9c04d6982eb15a9a47bd5c9ac7e2d # 签名Status: Downloaded newer image for mysql:8.0docker.io/library/mysql:8.0 # 真实地址# 等价于它docker pull mysqldocker pull docker.io/library/mysql:8.0 docker rmi 删除镜像 123[root@hecs-x-large-2-linux-20200425095544 ~]# docker rmi -f 镜像id # 删除指定的镜像[root@hecs-x-large-2-linux-20200425095544 ~]# docker rmi -f 镜像id 镜像id # 删除多个镜像[root@hecs-x-large-2-linux-20200425095544 ~]# docker rmi -f $(docker images -aq) # 删除全部的镜像 容器命令说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习 1docker pull centos 新建容器并启动 123456789101112131415161718192021222324docker run[可选参数] image# 参数说明--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p 指定容器的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口（常用） -p 容器端口 容器端口-P 随机指定端口# 测试，启动并进入容器[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -it centos /bin/bash[root@9b4676b718b5 /]# ls # 查看容器内的centos，基础版本，很多命令都是不完善的！bin etc lib lost+found mnt proc run srv tmp vardev home lib64 media opt root sbin sys usr# 从容器中退回主机[root@9b4676b718b5 /]# exitexit[root@hecs-x-large-2-linux-20200425095544 ~]# lsinstall.sh 列出所有运行的容器 123456789101112# docker ps 命令 # 列出当前正在运行的容器-a # 列出当前正在运行的容器 + 带出历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号[root@hecs-x-large-2-linux-20200425095544 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@hecs-x-large-2-linux-20200425095544 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9b4676b718b5 centos &quot;/bin/bash&quot; 26 minutes ago Exited (0) 16 minutes ago festive_feistelc8c1137aaa4e bf756fb1ae65 &quot;/hello&quot; 5 hours ago Exited (0) 5 hours ago confident_cannon 退出容器 12345exit # 容器停止并退出Ctrl + P + Q # 容器不停止退出[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -it centos /bin/bash[root@9d6ac1f17089 /]# [root@hecs-x-large-2-linux-20200425095544 ~]# 删除容器 123docker rm 容器id # 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f docker rm -f $(docker ps -aq) # 删除所有的容器docker ps -a -q|xargs docker rm # 删除所有的容器，使用管道 启动和容器的操作 1234docker start 容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止当前正在运行的容器docker kill 容器id # 强制停止当前容器 常用其他命令 后台启动容器 1234567# 命令 docker run -d 镜像名：[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d centos# 问题docker ps，发现 centos停止了# 常见的坑！！ docker容器使用后台运行，就唏嘘有一个前台进程，docker发现没有应用，就自动停止# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 查看日志 12345678910111213 docker logs -f -t --tail 容器id ,没有日志 # 自己编写一段shell脚本 [root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d centos /bin/bash -c &quot;while true;do echo kuangshen; sleep 1;done&quot;[root@hecs-x-large-2-linux-20200425095544 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESaadc743a101c centos &quot;/bin/bash -c &#x27;while…&quot; 4 seconds ago Up 3 seconds tender_moser # 显示日志 -tf # 显示日志 -tail number # 要显示日志条数 [root@hecs-x-large-2-linux-20200425095544 ~]# docker logs -tf --tail 10 284eaba4616b 查看容器中进程信息 ps 12345# 命令 docker top 容器id [root@hecs-x-large-2-linux-20200425095544 ~]# docker top 284eaba4616bUID PID PPID C STIME TTY TIME CMDroot 15211 15194 0 18:31 ? 00:00:00 /bin/bash -c while true;do echo kuangshen; sleep 1;doneroot 15918 15211 0 18:37 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211# 命令docker inspect 容器id# 测试[root@hecs-x-large-2-linux-20200425095544 ~]# docker inspect 284eaba4616b[ &#123; &quot;Id&quot;: &quot;284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6&quot;, &quot;Created&quot;: &quot;2020-11-12T10:31:46.264703694Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo kuangshen; sleep 1;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 15211, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-11-12T10:31:46.559658378Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6-json.log&quot;, &quot;Name&quot;: &quot;/dazzling_roentgen&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a-init/diff:/var/lib/docker/overlay2/ab2394ffb62a3a589a4794ed317cdec52ff1b73d6c0025a32b56cfa266fe4d97/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;284eaba4616b&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;while true;do echo kuangshen; sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20200809&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;da70a9e57940a409d3f4827907ee892aa3a9a20aa2575fbeffd380cedfc6b03a&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/da70a9e57940&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;9e9c2139cd06d068313f00e7e7ec3bf9411a3344792d962fffecd4324d1ff87a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;7a8c920abbd19ce06b9315879005e6d73adea85afc13f16ca1bd88c49bf5694b&quot;, &quot;EndpointID&quot;: &quot;9e9c2139cd06d068313f00e7e7ec3bf9411a3344792d962fffecd4324d1ff87a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819202122# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置# 命令 docker exec -it 容器id bashShell# 测试[root@hecs-x-large-2-linux-20200425095544 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 6 hours ago Up 6 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql[root@hecs-x-large-2-linux-20200425095544 ~]# docker exec -it e60fd257e7cf /bin/bashroot@e60fd257e7cf:/# lsbin docker-entrypoint-initdb.d home media proc sbin tmpboot entrypoint.sh lib mnt root srv usrdev etc lib64 opt run sys varroot@e60fd257e7cf:/# ps -ef# 方式2 docker attach 容器id# docker exec # 进入容器后开启一个新的终端，可以在里面操作（常用）# docker attach # 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到主机上 12345678910111213141516171819202122232425262728293031docker cp 容器id：容器内路径 目的的主机路径# 查看当前主机目录下[root@hecs-x-large-2-linux-20200425095544 home]# lschn hello.java hh leo Marlowe www[root@hecs-x-large-2-linux-20200425095544 home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES37b64bd24047 centos &quot;/bin/bash&quot; About a minute ago Up About a minute funny_williamse60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql# 进入docker容器内部[root@hecs-x-large-2-linux-20200425095544 home]# docker attach 37b64bd24047[root@37b64bd24047 /]# cd /home[root@37b64bd24047 home]# ls# 在容器内新建一个文件[root@37b64bd24047 home]# touch test.java[root@37b64bd24047 home]# lstest.java[root@37b64bd24047 home]# exitexit[root@hecs-x-large-2-linux-20200425095544 home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql# 将这文件拷贝出来到主机上[root@hecs-x-large-2-linux-20200425095544 home]# docker cp 37b64bd24047:/home/test.java /home [root@hecs-x-large-2-linux-20200425095544 home]# lschn hello.java hh leo Marlowe test.java www# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现，自动同步 /home /home Docker 安装nginx 123456789101112131415161718192021# 1.搜索镜像 search 建议大家去docker搜素，可以看帮助文档# 2.下载镜像 pull# 3.运行测试[root@hecs-x-large-2-linux-20200425095544 home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest c39a868aad02 7 days ago 133MBmysql 8.0 db2b37ec6181 2 weeks ago 545MBmysql latest db2b37ec6181 2 weeks ago 545MBcentos latest 0d120b6ccaa8 3 months ago 215MB# -d后台运行# --name 给容器命名# -p 宿主机端口，容器内部端口[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d --name nginx01 -p 3344:80 nginx100d4c411f6d16c5ff4e630f521f59448d065cb2b201bd0b3a1ea6840045e955[root@hecs-x-large-2-linux-20200425095544 home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES100d4c411f6d nginx &quot;/docker-entrypoint.…&quot; 8 seconds ago Up 7 seconds 0.0.0.0:3344-&gt;80/tcp nginx01e60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql[root@hecs-x-large-2-linux-20200425095544 home]# curl localhost:3344 作业练习 Docker 安装 Nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 1.搜索镜像 search 建议去docker搜索，可以看到帮助文档# 2.下载镜像 pull# 3.运行测试[root@hecs-x-large-2-linux-20200425095544 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest c39a868aad02 9 days ago 133MBmysql 8.0 db2b37ec6181 3 weeks ago 545MBmysql latest db2b37ec6181 3 weeks ago 545MBcentos latest 0d120b6ccaa8 3 months ago 215MB# -d 后台运行# --name 容器命名# -p 宿主机端口：容器内端口[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d --name nginx01 -p 3344:80 nginx[root@hecs-x-large-2-linux-20200425095544 ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;# 进入容器[root@hecs-x-large-2-linux-20200425095544 ~]# docker exec -it nginx01 /bin/bashroot@100d4c411f6d:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx 思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？ -v 数据卷！ 作业2：docker装tomcat 123456789101112131415161718# 官方安装docker run -it --rm tomcat:9.0# 我们之前的启动都是后台，停止了容器之后，容器还是可以查到， docker run -it --rm 一般用来测试，用完就删除# 下载再启用docker pull tomcat# 启动运行docker run -d -p 3355:8080 --name tomcat01 tomcat# 测试访问没有问题# 进入容器[root@hecs-x-large-2-linux-20200425095544 ~]# docker exec -it tomcat01 /bin/bash# 发现问题：1.linux命令少了，2.没有webapps，阿里云镜像的原因，默认是最小的镜像，左右不必要的都删除掉。# 保证最小可运行的环境！ 思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外提供一个映射路径，webapps，我们在外部放置项目，就自动同步到内部就好了！ 作业：部署es+kibana 123456789101112131415161718192021222324252627282930313233# es 暴露的端口很多# es 十分的耗内存# es的数据一般需要放置到安全目录！ 挂载# --net somenetwork ？ 网络配置# 下载启动docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2# 启动后非常卡 linux卡住了，docker status 查看cpu状态# es十分耗内存；# 查看 docker stats# 测试es是否成功了[root@hecs-x-large-2-linux-20200425095544 ~]# curl localhost:9200&#123; &quot;name&quot; : &quot;6e4e7e14f10d&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;C4GbFU9pQ7m0WT6ko_pkJA&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 12# 增加内存限制，修改配置文件 -e 环境配置修改docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 作业：使用kibana连接es？思考网络如何才能连接过去！ 可视化 portainer(先用这个)1docker run -d -p 8088:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer Rancher(CI/CD再用) 什么是portainer？Docker图形化界面管理工具！提供一个后台面板供我们操作！ 1docker run -d -p 8088:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}],"author":"Marlowe"},{"title":"二叉树的前中后序非递归遍历算法","slug":"Leetcode题解/二叉树的前中后序非递归遍历算法","date":"2020-10-12T14:01:09.000Z","updated":"2020-12-05T04:44:01.014Z","comments":true,"path":"2020/10/12/Leetcode题解/二叉树的前中后序非递归遍历算法/","link":"","permalink":"http://example.com/2020/10/12/Leetcode%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"二叉树的前中后序非递归遍历算法学过数据结构的同学都知道二叉树的深度优先遍历算法有三种，前序，中序，后序遍历。 前序：根–&gt;左–&gt;右 中序：左–&gt;根–&gt;右 后序：左–&gt;右–&gt;根 不难发现，后序遍历和前序遍历有相似的地方，如果我们将后序遍历变成根右左的顺序，将结果集翻转后就会变成前序的根左右顺序。 前中后序非递归遍历的核心算法：前序遍历：123456789101112while(root != null || !stack.isEmpty())&#123; // 一直往左边走 while(root != null)&#123; res.add(root.val); stack.push(root); root = root.left; &#125; // 开始回退 TreeNode cur = stack.pop(); // 往右边走 root = cur.right;&#125; 后序遍历：123456789101112131415while(root != null || !stack.isEmpty())&#123; // 一直往右边走 while(root != null)&#123; res.add(root.val); stack.push(root); root = root.right; &#125; // 开始回退 TreeNode cur = stack.pop(); // 往左边走 root = cur.left; // 反转，使变成后序遍历 Collections.reverse(res);&#125; 中序遍历：12345678910111213while(root != null || !stack.isEmpty())&#123; // 碰到根节点，压栈 while(root != null)&#123; stack.push(root); // 往左边走 root = root.left; &#125; // 开始回退 root = stack.pop(); res.add(root.val); // 往右边走 root = root.right;&#125; 前中后序递归遍历的核心算法：前序遍历：1234567public void dfs(TreeNode root)&#123; while(root != null)&#123; res.add(root.val); dfs(root.left); dfs(root.right); &#125;&#125; 中序遍历：1234567public void dfs(TreeNode root)&#123; while(root != null)&#123; dfs(root.left); res.add(root.val); dfs(root.right); &#125;&#125; 后序遍历：1234567public void dfs(TreeNode root)&#123; while(root != null)&#123; dfs(root.left); dfs(root.right); res.add(root.val); &#125;&#125;","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Marlowe"},{"title":"Map集合的统计每个字符出现次数的两种方法","slug":"Leetcode题解/Map集合的统计每个字符出现次数的两种方法","date":"2020-10-12T13:53:51.000Z","updated":"2020-12-05T04:44:00.949Z","comments":true,"path":"2020/10/12/Leetcode题解/Map集合的统计每个字符出现次数的两种方法/","link":"","permalink":"http://example.com/2020/10/12/Leetcode%E9%A2%98%E8%A7%A3/Map%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"Map集合的统计每个字符出现次数的两种方法一、map.containsKey()方法Map可以出现在k与v的映射中，v为null的情况。Map集合允许值对象为null，并且没有个数限制，所以当get()方法的返回值为null时，可能有两种情况，一种是在集合中没有该键对象，另一种是该键对象没有映射任何值对象，即值对象为null。因此，在Map集合中不应该利用get()方法来判断是否存在某个键，而应该利用containsKey()方法来判断。 1234567891011121314151617/** * map.containsKey()方法 * * @param nums */ public static void test1(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; if (!cnt.containsKey(num)) &#123; cnt.put(num, 1); &#125; else &#123; cnt.put(num, cnt.get(num) + 1); &#125; &#125; // 遍历HashMap pnt(cnt); &#125; 1234567原始数组：int[] nums &#x3D; new int[]&#123;1, 2, 2, 3, 5, 5, 5, 9, 1, 1&#125;;结果： 1出现的次数：3 2出现的次数：2 3出现的次数：1 5出现的次数：3 9出现的次数：1 二、map.getOrDefault()方法 当Map集合中有这个key时，就使用这个key值，如果没有就使用默认值defaultValue 。 12345678910111213/** * map.getOrDefault()方法 * * @param nums */ public static void test2(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; cnt.put(num, cnt.getOrDefault(num, 0) + 1); &#125; // 遍历HashMap pnt(cnt); &#125; 1234567原始数组：int[] nums = new int[]&#123;1, 2, 2, 3, 5, 5, 5, 9, 1, 1&#125;;结果： 1出现的次数：3 2出现的次数：2 3出现的次数：1 5出现的次数：3 9出现的次数：1 三、demo源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.HashMap;import java.util.Map;/** * @program: leecode1 * @description: * @author: Marlowe * @create: 2020-09-07 15:28 **/public class map集合统计每个字符出现的次数 &#123; public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 2, 3, 5, 5, 5, 9, 1, 1&#125;; test1(nums); test2(nums); &#125; /** * map.containsKey()方法 * * @param nums */ public static void test1(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; if (!cnt.containsKey(num)) &#123; cnt.put(num, 1); &#125; else &#123; cnt.put(num, cnt.get(num) + 1); &#125; &#125; pnt(cnt); &#125; /** * map.getOrDefault()方法 * * @param nums */ public static void test2(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; cnt.put(num, cnt.getOrDefault(num, 0) + 1); &#125; pnt(cnt); &#125; /** * 遍历HashMap */ public static void pnt(HashMap&lt;Integer, Integer&gt; map) &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; int num = entry.getKey(); int count = entry.getValue(); System.out.println(num + &quot;出现的次数：&quot; + count); &#125; &#125;&#125;","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"Marlowe"},{"title":"Leetcode组合总和1-4题题解","slug":"Leetcode题解/Leetcode组合总和1-4题题解","date":"2020-10-12T13:52:22.000Z","updated":"2020-12-05T04:44:00.946Z","comments":true,"path":"2020/10/12/Leetcode题解/Leetcode组合总和1-4题题解/","link":"","permalink":"http://example.com/2020/10/12/Leetcode%E9%A2%98%E8%A7%A3/Leetcode%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C1-4%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"","text":"Leetcode组合总和1-4题题解Leecode最近几天的每日一题都是组合总和问题，预测明天是组合总和Ⅳ，因此，提前将组合总和的所有题目刷了，前三题的思路都差不多，最后一题做法有所不同： 组合总和：candidates 中的数字可以无限制重复被选取。 组合总和Ⅱ： candidates 中的每个数字在每个组合中只能使用一次。 组合总和Ⅲ：组合中只允许有1-9的数字，并且每种组合中不存在重复的数字。 组合总和Ⅳ：找出符合要求组合的个数。 39. 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 123456输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,所求解集为：[ [7], [2,2,3]] 示例 2： 1234567输入：candidates &#x3D; [2,3,5], target &#x3D; 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500 题解（dfs，回溯算法）分析：此类问题可以画出树形图，然后就会发现此题可以用dfs+回溯算法解决，用到的数据结构为双端队列，具有栈和队列的性质，其定义方式为：Deque stack = new ArrayDeque();具体步骤见代码。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // 保存结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 获取数组的长度 int len = candidates.length; //如果数组为空，直接返回空集合 if(len == 0)&#123; return res; &#125; // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历求所有结果集 dfs(candidates,0,len,target,path,res); return res; &#125; public void dfs(int[] candidates,int start,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果选多了，也即target &lt; 0,直接return if(target &lt; 0)&#123; return; &#125; // 找到一条路径 if(target == 0)&#123; // 将路径加入结果集 res.add(new ArrayList(path)); &#125; // 从下标为start的数开始寻找 for(int i = start; i &lt; len; i++)&#123; // 将当前元素入栈 path.addLast(candidates[i]); // 由于可以选择重复的元素，因此i不变，但是选择了东西，target对应减少 dfs(candidates,i,len,target - candidates[i],path,res); // 回到之前的状态 path.removeLast(); &#125; &#125;&#125; 40. 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,所求解集为:[ [1,2,2], [5]] 题解（dfs，回溯算法，哈希表）分析：此题和组合总和的区别在于 candidates 中的每个数字在每个组合中只能使用一次，并且解集不能包含重复的元素，因此可用哈希表对重复解集去重，具体步骤看下方代码注释。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; // 将原始数组排序 Arrays.sort(candidates); // 获取数组长度 int len = candidates.length; // 结果集列表 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历 + 回溯 dfs(candidates,0,len,target,path,res); // 去重，因为解集不能有重复元素 HashSet&lt;List&lt;Integer&gt;&gt; set = new HashSet(); for(List&lt;Integer&gt; list : res)&#123; set.add(list); &#125; // 将HashSet转换为List集合 return new ArrayList(set); &#125; public void dfs(int[] candidates,int start,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果选多了，也即target &lt; 0,直接return if(target &lt; 0)&#123; return; &#125; // 找到一条路径 if(target == 0)&#123; // 将路径加入结果集 res.add(new ArrayList(path)); &#125; for(int i = start; i &lt; len; i++)&#123; // 将当前元素入栈 path.addLast(candidates[i]); // 由于数组中的元素只能用一次，因此i + 1,并且target减少 dfs(candidates,i+1,len,target - candidates[i],path,res); // 回到之前的状态 path.removeLast(); &#125; &#125;&#125; 216. 组合总和 III 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 12输入: k &#x3D; 3, n &#x3D; 7输出: [[1,2,4]] 示例 2: 12输入: k &#x3D; 3, n &#x3D; 9输出: [[1,2,6], [1,3,5], [2,3,4]] 题解（dfs，回溯算法）分析：此题和组合总和Ⅱ的区别在于在1-9中选择数据,并且每个数据只能选一次，且只需返回长度为k的路径,因此需对结果集进行筛选，具体步骤看下方代码注释。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; // 手动将1-9加入数组arr中 int[] arr = new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; // 初始结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 最终结果集 List&lt;List&lt;Integer&gt;&gt; res1 = new ArrayList(); // 临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历求出所有解集 dfs(arr,0,n,path,res); // 选出符合长度为k的解集 for(List&lt;Integer&gt; list : res)&#123; if(list.size() == k)&#123; res1.add(list); &#125; &#125; return res1; &#125; public void dfs(int[] arr,int start,int n ,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果选多了，也即n &lt; 0,直接return if(n &lt; 0)&#123; return; &#125; // 找到一条路径 if(n == 0)&#123; // 将路径加入结果集 res.add(new ArrayList(path)); &#125; for(int i = start; i &lt; 9; i++)&#123; // 将当前元素入栈 path.addLast(arr[i]); // 由于数组中的元素只能用一次，因此i + 1,并且n减少 dfs(arr,i + 1,n - arr[i],path,res); // 回到之前的状态 path.removeLast(); &#125; &#125;&#125; 377. 组合总和 Ⅳ给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: 12345678910111213141516nums &#x3D; [1, 2, 3]target &#x3D; 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ 题解（1.dfs,回溯算法 2.动态规划）分析：此题和组合总和类似，区别在于求出所有解集后，还需求出解集的全排列，并返回全排列的个数。 组合总数前三题都是同样的套路，只是在结果处理以及中间过程有略微差别，但是这题不同的是要求结果集的全排列，因此，我就想用第一题的算法 + 全排列算法求出此题，代码如demo1，结果超时，代码逻辑是没有问题的，但题目所给数据过大，导致算全排列的时候使用过多时间，因此未通过。 查看题解，发现正确的解法为动态规划，根据分析可以得到状态转移方程： dp[i] = dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]]...... 例如nums = [1,3,4],target = 7; dp[7] = dp[6] + dp[4] + dp[3]; 具体代码见demo2 具体步骤如下：demo1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; Arrays.sort(nums); int sum = 0; // 保存结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 获取数组的长度 int len = nums.length; // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历求所有结果集 dfs(nums,0,len,target,path,res); // 求出解集中的所有情况 for(List&lt;Integer&gt; list : res)&#123; sum += isok(list); &#125; return sum; &#125; // 求出所有解集 public void dfs(int[] nums,int start,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(target &lt; 0)&#123; return; &#125; if(target == 0)&#123; res.add(new ArrayList(path)); &#125; for(int i = start; i &lt; len; i++)&#123; path.addLast(nums[i]); // 可以重复使用，因此i不用+1 dfs(nums,i,len,target - nums[i],path,res); path.removeLast(); &#125; &#125; // 求出列表的所有组合情况 public int isok(List&lt;Integer&gt; list)&#123; int[] nums = new int[list.size()]; for(int i = 0 ; i &lt; nums.length; i++)&#123; nums[i] = list.get(i); &#125; int len = nums.length; Deque&lt;Integer&gt; path = new ArrayDeque(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 布尔数组，用于标记改数是否使用过 boolean[] used = new boolean[len]; dfs2(nums,len,0,used,path,res); return res.size(); &#125; // 求全排列 public void dfs2(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(depth == len)&#123; res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; if(used[i])&#123; continue; &#125; // 因为有重复元素，所以在下一层碰到相同元素会使结果重复，相对于全排列，进一步剪枝 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])&#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs2(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; demo2 123456789101112131415class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for(int i = 0; i &lt;= target; i++)&#123; for(int num : nums)&#123; if(num &lt;= i)&#123; dp[i] += dp[i - num]; &#125; &#125; &#125; return dp[target]; &#125;&#125; :smile:以上题解仅限于个人理解，如有更好的方法或者更高效的解法，请移步至评论区，谢谢！","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}],"author":"Marlowe"},{"title":"Leetcode全排列1-2题题解","slug":"Leetcode题解/Leetcode全排列1-2题题解","date":"2020-10-12T13:49:35.000Z","updated":"2020-12-05T04:44:00.939Z","comments":true,"path":"2020/10/12/Leetcode题解/Leetcode全排列1-2题题解/","link":"","permalink":"http://example.com/2020/10/12/Leetcode%E9%A2%98%E8%A7%A3/Leetcode%E5%85%A8%E6%8E%92%E5%88%971-2%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"","text":"Leetcode全排列1-2题题解对于全排列问题，可能我们很多人从小在数学课上都做过，并且都能由一定的规律将所有排列情况写出来，但如何用编码的方式求解此类问题成了我的问题，或许也成是你们还未解决的问题，其实这类问题的套路都是 dfs + 回溯算法，然后，根据题目要求进行剪枝，我将通过下面两题来讲解这类问题具体做法。 46. 全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 题解（dfs，回溯算法）分析：由于是回溯算法，因此，会用到栈，通常我们所学的栈是这种用法 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();,但在Stack的源码中发现了Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();这种用法，百度之后，知道了Deque : （double-ended queue，双端队列）是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，相比list增加运算符重载。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 数组长度 int len = nums.length; // 结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 布尔数组，保存改数字是否使用过 boolean[] used = new boolean[len]; // 深度优先遍历求所有结果集 dfs(nums,len,0,used,path,res); return res; &#125; public void dfs(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果到达最深的一层 if(depth == len)&#123; // 将当前路径加入结果集 res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; // 判断当前数字是否用过 if(used[i])&#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; 47. 全排列 II给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 题解（dfs，回溯算法）分析：此题和全排列解法类似，唯一的差别在于可选数组nums中存在重复的数字，可能会产生重复的路径，因此，需要在判断当前数字是否用过后，再次判断上一次使用的数字和当前数字是否相同，如果相同，进行剪枝，具体差别见代码。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 数组长度 int len = nums.length; // 对数组排序 Arrays.sort(nums); // 结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 布尔数组，保存改数字是否使用过 boolean[] used = new boolean[len]; // 深度优先遍历求所有结果集 dfs(nums,len,0,used,path,res); return res; &#125; public void dfs(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果到达最深的一层 if(depth == len)&#123; // 将当前路径加入结果集 res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; // 判断当前数字是否用过 if(used[i])&#123; continue; &#125; // 因为有重复元素，所以在下一层碰到相同元素会使结果重复，相对于全排列，进一步剪枝 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; :smile:以上题解仅限于个人理解，如有更好的方法或者更高效的解法，请移步至评论区，谢谢！","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}],"author":"Marlowe"},{"title":"Leetcode两数-四数之和题解","slug":"Leetcode题解/Leetcode两数-四数之和题解","date":"2020-10-12T13:35:23.000Z","updated":"2020-12-05T04:44:00.942Z","comments":true,"path":"2020/10/12/Leetcode题解/Leetcode两数-四数之和题解/","link":"","permalink":"http://example.com/2020/10/12/Leetcode%E9%A2%98%E8%A7%A3/Leetcode%E4%B8%A4%E6%95%B0-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%E9%A2%98%E8%A7%A3/","excerpt":"","text":"Leecode两数-四数之和题解最近两天做了两数之和，四数之和，并且之前也做过三数之和，感觉这几道题解法都差不多，并且用同样的方法能求解n数之和。 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解（哈希表）分析：利用哈希map，key存放数字，value存放索引，遍历数组，依次取一个数，然后计算出另外一个数，如果哈希map中存在，直接取出索引，返回结果，如果不存在，向哈希map中添加当前元素和对应的下标。 具体步骤如下：1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // key存放数字，value存放index HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int i = 0; i &lt; nums.length;i++)&#123; int num2 = target - nums[i]; // 如果哈希map中存在当前数，直接返回i和当前数的下标 if(map.containsKey(num2))&#123; return new int[] &#123; map.get(num2), i &#125;; &#125;else&#123; // 将当前数放入哈希map map.put(nums[i],i); &#125; &#125; return null; &#125;&#125; 15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 题解（排序，双指针）分析：此题要求出三个数的和为0的结果集，则只需对原数组排序，然后从最小的数开始选，接着设置左右指针，如果当前三个数和为0，将这三个数加入结果集，继续寻找，如果当前三个数和大于0，右指针左移，小于0，左指针右移。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); //如果数组为空 或者长度小于三 直接返回空 if(nums == null || len &lt;3) return ans; //对数组排序 Arrays.sort(nums); for(int i = 0 ; i &lt; len;i++)&#123; //如果当前最小的数大于0，直接结束循环 if(nums[i] &gt; 0) break; //去重 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; //设置左右指针 int left = i + 1; int right = len - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[left] + nums[right]; if( sum == 0)&#123; ans.add(Arrays.asList(nums[i],nums[left],nums[right])); //左边元素去重 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; //右边元素去重 while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; //移动左右指针 left++; right--; &#125; if(sum &gt; 0) right--; if(sum &lt; 0) left++; &#125; &#125; return ans; &#125;&#125; 18. 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 题解（排序，双指针）分析：此题要求出四个数的和为target的结果集，则只需对原数组排序，然后将四数之和降为三数之和，接着设置左右指针，如果当前四个数和为target，将这四个数加入结果集，继续寻找，如果当前四个数和大于target，右指针左移，小于0，左指针右移，具体步骤见代码注释。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 边界条件判断 if(nums == null || nums.length &lt; 4)&#123; return res; &#125; // 对原数组排序 Arrays.sort(nums); // 获取原数组长度 int l = nums.length; for(int i = 0; i &lt; l - 3; i++)&#123; // 去重 if( i &gt; 0 &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; // 如果当前数加上后面最小的三个数都比target大，直接跳出 if(nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target)&#123; break; &#125; // 如果当前数加上最大的三个数逗比target小，跳过当前数 if(nums[i] + nums[l - 3] + nums[l - 2] + nums[l - 1] &lt; target)&#123; continue; &#125; // 同上（n数之和直接重复此操作即可） for(int j = i + 1; j &lt; l - 2; j++)&#123; if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])&#123; continue; &#125; if(nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target)&#123; break; &#125; if(nums[i] + nums[j] + nums[l - 1] + nums[l - 2] &lt; target)&#123; continue; &#125; // 将n树之和转为两数之和 int left = j + 1; int right = l - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[j] + nums[left] + nums[right]; if(sum == target)&#123; // 加入结果集 res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); // 去重 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1])&#123; left++; &#125; left++; // 去重 while(left &lt; right &amp;&amp; nums[right] == nums[right - 1])&#123; right--; &#125; right--; &#125;else if(sum &gt; target)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; &#125; return res; &#125;&#125; 由三数之和和四数之和可以得出n数之和的解法，思想是一样的，都是枚举，去重，再将最后两个数的和转换为双指针，降低时间复杂度","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}],"author":"Marlowe"},{"title":"test","slug":"Java随笔/test","date":"2020-10-12T12:35:34.000Z","updated":"2020-12-02T15:04:50.067Z","comments":true,"path":"2020/10/12/Java随笔/test/","link":"","permalink":"http://example.com/2020/10/12/Java%E9%9A%8F%E7%AC%94/test/","excerpt":"","text":"testhexohello,world!","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"我的第一篇博客","slug":"Java随笔/我的第一篇博客","date":"2020-10-12T12:20:20.000Z","updated":"2020-12-02T15:04:50.094Z","comments":true,"path":"2020/10/12/Java随笔/我的第一篇博客/","link":"","permalink":"http://example.com/2020/10/12/Java%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"我的第一篇博客记录一下最近使用hexo搭建的博客 &ensp;&ensp;周六晚上开始搭建，安装node、npm等等，碰到了一系列问题，换了一个主题后，总算把博客整体框架搭建好了，接着周日本是完整的一天，但早上九点多才起床，到实验室接近10点了，继续研究配置文件，以及主题的源代码，但是没啥效果，github有时候也抽风，就问了问学长,最后重新配置了仓库，总算解决了。&ensp;&ensp;周一中午开始研究上传到github以及自动部署脚本文件，到了晚上都没解决，最后才知道博客仓库只是部署编译出来的网站静态文件，如果想要使用github进行代码托管，只有新建一个代码库，把所有文件上传上去。脚本文件如下 12345678910111213@echo offD:cd D:\\PersonalFile\\HexoBlogecho &#39;start git sync&#39;git add .git add -Agit add -ugit commit -m &quot;update...&quot;git pull HexoBlog mastergit push HexoBlog mastercall hexo ghexo d","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"春招面试","slug":"春招面试","permalink":"http://example.com/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"},{"name":"自定义工具类","slug":"自定义工具类","permalink":"http://example.com/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"JUC","slug":"JUC","permalink":"http://example.com/categories/JUC/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/categories/NoSQL/"},{"name":"学习方法","slug":"学习方法","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://example.com/categories/ElasticSearch/"},{"name":"环境配置之踩坑","slug":"环境配置之踩坑","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B8%A9%E5%9D%91/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"http://example.com/categories/LeetCode%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"volatile","slug":"volatile","permalink":"http://example.com/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"http://example.com/tags/synchronized/"},{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"},{"name":"线程安全","slug":"线程安全","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"},{"name":"I/O模型","slug":"I-O模型","permalink":"http://example.com/tags/I-O%E6%A8%A1%E5%9E%8B/"},{"name":"动态代理","slug":"动态代理","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"JDK","slug":"JDK","permalink":"http://example.com/tags/JDK/"},{"name":"关键字","slug":"关键字","permalink":"http://example.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"Arrays","slug":"Arrays","permalink":"http://example.com/tags/Arrays/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"并发","slug":"并发","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"http://example.com/tags/GC/"},{"name":"异常","slug":"异常","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8/"},{"name":"JWT","slug":"JWT","permalink":"http://example.com/tags/JWT/"},{"name":"辅助类","slug":"辅助类","permalink":"http://example.com/tags/%E8%BE%85%E5%8A%A9%E7%B1%BB/"},{"name":"Callable","slug":"Callable","permalink":"http://example.com/tags/Callable/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://example.com/tags/SpringBoot/"},{"name":"Jedis","slug":"Jedis","permalink":"http://example.com/tags/Jedis/"},{"name":"事务","slug":"事务","permalink":"http://example.com/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"数据类型","slug":"数据类型","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"效率","slug":"效率","permalink":"http://example.com/tags/%E6%95%88%E7%8E%87/"},{"name":"工作方法","slug":"工作方法","permalink":"http://example.com/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"ES","slug":"ES","permalink":"http://example.com/tags/ES/"},{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"},{"name":"Resuful","slug":"Resuful","permalink":"http://example.com/tags/Resuful/"},{"name":"踩坑","slug":"踩坑","permalink":"http://example.com/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面经","slug":"面经","permalink":"http://example.com/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"Swagger","slug":"Swagger","permalink":"http://example.com/tags/Swagger/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"},{"name":"注解","slug":"注解","permalink":"http://example.com/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"DI","slug":"DI","permalink":"http://example.com/tags/DI/"},{"name":"Bean","slug":"Bean","permalink":"http://example.com/tags/Bean/"},{"name":"IOC","slug":"IOC","permalink":"http://example.com/tags/IOC/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"list","slug":"list","permalink":"http://example.com/tags/list/"},{"name":"线程不安全","slug":"线程不安全","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"},{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://example.com/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"策略","slug":"策略","permalink":"http://example.com/tags/%E7%AD%96%E7%95%A5/"},{"name":"Json","slug":"Json","permalink":"http://example.com/tags/Json/"},{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"},{"name":"代理","slug":"代理","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://example.com/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"单例","slug":"单例","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"工厂","slug":"工厂","permalink":"http://example.com/tags/%E5%B7%A5%E5%8E%82/"},{"name":"模板","slug":"模板","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"插入排序","slug":"插入排序","permalink":"http://example.com/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"外观","slug":"外观","permalink":"http://example.com/tags/%E5%A4%96%E8%A7%82/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}