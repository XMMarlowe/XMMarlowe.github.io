{"meta":{"title":"Marlowe","subtitle":"","description":"","author":"John Doe","url":"https://xmmarlowe.github.io","root":"/"},"pages":[{"title":"","date":"2020-12-02T14:11:24.545Z","updated":"2020-12-02T14:11:24.545Z","comments":true,"path":"404.html","permalink":"https://xmmarlowe.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-10-12T12:20:20.000Z","updated":"2020-12-01T14:26:10.112Z","comments":true,"path":"about/index.html","permalink":"https://xmmarlowe.github.io/about/index.html","excerpt":"","text":"个人博客：Marlowe毕业学校：重庆理工大学本科专业：计算机科学与技术个人邮箱：marlowe246@qq.comGithub:Marlowe"},{"title":"所有分类","date":"2020-12-01T14:23:54.558Z","updated":"2020-12-01T14:23:54.558Z","comments":true,"path":"categories/index.html","permalink":"https://xmmarlowe.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-01T14:23:54.500Z","updated":"2020-12-01T14:23:54.500Z","comments":true,"path":"tags/index.html","permalink":"https://xmmarlowe.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP常见状态码","slug":"计算机网络/HTTP常见状态码","date":"2021-04-09T14:54:22.000Z","updated":"2021-04-09T14:59:34.305Z","comments":true,"path":"2021/04/09/计算机网络/HTTP常见状态码/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"常见的http状态码：100,200,202,204,301,404,500,503…","text":"常见的http状态码：100,200,202,204,301,404,500,503… 100： 这个状态码是告诉客户端应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应继续发送求请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果 200： 这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果 202： 表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定 204： 服务器成功处理了请求，但没有返回任何实体内容 ，可能会返回新的头部元信息 301： 客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果 404： 请求失败，客户端请求的资源没有找到或者是不存在 500： 服务器遇到未知的错误，导致无法完成客户端当前的请求。 503： 服务器由于临时的服务器过载或者是维护，无法解决当前的请求，以上http状态码是服务器经常返回的状态代码，用户只能通过浏览器的状态了解服务器是否正常运行，一般除了错误的状态码，都不会看到服务器的状态码的，","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xmmarlowe.github.io/tags/HTTP/"}],"author":"Marlowe"},{"title":"多线程和多进程及其应用场景","slug":"操作系统/多线程和多进程及其应用场景","date":"2021-04-09T14:45:58.000Z","updated":"2021-04-09T14:59:34.283Z","comments":true,"path":"2021/04/09/操作系统/多线程和多进程及其应用场景/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"多进程多线程的区别 进程是分配资源的基本单位；线程是系统调度和分派的基本单位。 属于同一进程的线程，堆是共享的，栈是私有的。 属于同一进程的所有线程都具有相同的地址空间。 多进程的优点：①编程相对容易；通常不需要考虑锁和同步资源的问题。 ②更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程。 ③有内核保证的隔离：数据和错误隔离。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）。 多线程的优点：①创建速度快，方便高效的数据共享 共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术。②较轻的上下文切换开销 - 不用切换地址空间，不用更改寄存器，不用刷新TLB。 ③提供非均质的服务。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率。 应用场景1. 多进程应用场景 nginx主流的工作模式是多进程模式（也支持多线程模型） 几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，例如apached,httpd等等以d结尾的进程包括init.d本身就是0级总进程，所有你认知的进程都是它的子进程； chrome浏览器也是多进程方式。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。②网页之间互相隔离，保证安全，不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。） redis也可以归类到“多进程单线程”模型（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程） 2. 多线程应用场景 线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）。 提供非均质的服务（有优先级任务处理）事件响应有优先级。 单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延。 与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应） 案例：桌面软件，响应用户输入的是一个线程，后台程序处理是另外的线程； memcached 3. 选什么？①需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大）这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的 ②需要进行大量计算的优先使用线程（CPU频繁切换）所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是图像处理、算法处理。 ③强相关的处理用线程，弱相关的处理用进程什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。 ④可能要扩展到多机分布的用进程，多核分布的用线程 ⑤都满足需求的情况下，用你最熟悉、最拿手的方式至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。 实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。 参考多线程和多进程及其应用场景","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://xmmarlowe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://xmmarlowe.github.io/tags/%E8%BF%9B%E7%A8%8B/"}],"author":"Marlowe"},{"title":"HTTP是不保存状态的协议,如何保存用户状态?","slug":"计算机网络/HTTP是不保存状态的协议-如何保存用户状态","date":"2021-04-09T14:42:30.000Z","updated":"2021-04-09T14:59:34.301Z","comments":true,"path":"2021/04/09/计算机网络/HTTP是不保存状态的协议-如何保存用户状态/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81/","excerpt":"","text":"HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。 在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。 Cookie 被禁用怎么办? 最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xmmarlowe.github.io/tags/HTTP/"}],"author":"Marlowe"},{"title":"HTTP 1.0和HTTP 1.1的主要区别是什么?","slug":"计算机网络/HTTP-1-0和HTTP-1-1的主要区别是什么","date":"2021-04-09T14:39:29.000Z","updated":"2021-04-09T14:59:34.294Z","comments":true,"path":"2021/04/09/计算机网络/HTTP-1-0和HTTP-1-1的主要区别是什么/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-1-0%E5%92%8CHTTP-1-1%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。 错误状态响应码: 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 缓存处理: 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用: HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xmmarlowe.github.io/tags/HTTP/"}],"author":"Marlowe"},{"title":"Cookie和Session","slug":"计算机网络/Cookie和Session","date":"2021-04-09T14:35:26.000Z","updated":"2021-04-09T14:59:34.297Z","comments":true,"path":"2021/04/09/计算机网络/Cookie和Session/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Cookie%E5%92%8CSession/","excerpt":"Cookie的作用是什么? 和Session有什么区别？","text":"Cookie的作用是什么? 和Session有什么区别？ Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。 Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://xmmarlowe.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://xmmarlowe.github.io/tags/Session/"}],"author":"Marlowe"},{"title":"进程间的通信方式","slug":"操作系统/进程间的通信方式","date":"2021-04-09T14:13:41.000Z","updated":"2021-04-09T14:59:34.291Z","comments":true,"path":"2021/04/09/操作系统/进程间的通信方式/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"进程间的7种通信方式概述…","text":"进程间的7种通信方式概述… 进程间通信的概念每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） 进程间通信模型 进程间通信的七种方式 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。 进程间管道通信模型 有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 信号的生命周期 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。 两个进程使用一个二值信号量 两个进程所以用一个Posix有名二值信号量 一个进程两个线程共享基于内存的信号量 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 Socket是应用层和传输层之间的桥梁 好文推荐进程间通信IPC (InterProcess Communication)","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://xmmarlowe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程通信","slug":"进程通信","permalink":"https://xmmarlowe.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"}],"author":"Marlowe"},{"title":"Java对象的创建过程","slug":"Java/Java对象的创建过程","date":"2021-04-09T07:30:21.000Z","updated":"2021-04-09T14:59:34.279Z","comments":true,"path":"2021/04/09/Java/Java对象的创建过程/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/Java/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/","excerpt":"","text":"参考Java对象的创建过程","categories":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"对象","slug":"对象","permalink":"https://xmmarlowe.github.io/tags/%E5%AF%B9%E8%B1%A1/"}],"author":"Marlowe"},{"title":"JVM垃圾回收算法","slug":"Java/JVM垃圾回收算法","date":"2021-04-09T07:13:36.000Z","updated":"2021-04-09T14:59:34.276Z","comments":true,"path":"2021/04/09/Java/JVM垃圾回收算法/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/Java/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","excerpt":"","text":"两个概念：新生代： 存放生命周期较短的对象的区域。老年代： 存放生命周期较长的对象的区域。 相同点： 都在Java堆上。 标记-清除算法标记-整理算法复制算法分代收集算法MinorGC和FullGC的区别参考JVM垃圾回收算法","categories":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://xmmarlowe.github.io/tags/JVM/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://xmmarlowe.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}],"author":"Marlowe"},{"title":"死锁产生的原因以及产生的必要条件","slug":"操作系统/死锁产生的原因以及产生的必要条件","date":"2021-04-09T05:41:29.000Z","updated":"2021-04-09T14:59:34.287Z","comments":true,"path":"2021/04/09/操作系统/死锁产生的原因以及产生的必要条件/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6/","excerpt":"","text":"死锁产生的原因 系统资源不足。 进程运行推进的顺序不合适。 资源分配不当。 死锁产生的四个必要条件 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已经获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。","categories":[],"tags":[],"author":"Marlowe"},{"title":"TCP和UDP的区别，以及使用场景","slug":"计算机网络/TCP和UDP的区别，以及使用场景","date":"2021-04-07T14:50:57.000Z","updated":"2021-04-09T14:58:35.223Z","comments":true,"path":"2021/04/07/计算机网络/TCP和UDP的区别，以及使用场景/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"","categories":[],"tags":[],"author":"Marlowe"},{"title":"研发高频算法题","slug":"研发高频算法题","date":"2021-04-01T09:08:20.000Z","updated":"2021-04-09T14:03:56.015Z","comments":true,"path":"2021/04/01/研发高频算法题/","link":"","permalink":"https://xmmarlowe.github.io/2021/04/01/%E7%A0%94%E5%8F%91%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"牛客研发最爱考","text":"牛客研发最爱考 字符串进制转换题目链接 代码如下： 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Solution &#123; /** * 进制转换 * @param M int整型 给定整数 * @param N int整型 转换到的进制 * @return string字符串 */ public String solve (int M, int N) &#123; if(M == 0)&#123; return &quot;0&quot;; &#125; // 存储各进制转换后的字符 String s = &quot;0123456789ABCDEF&quot;; // 判断是否为负数，如果为负数，则需要添加负号 boolean f = false; if(M &lt; 0)&#123; f = true; M = -M; &#125; StringBuilder sb = new StringBuilder(); // 得到进制转换逆序的结果 while(M != 0)&#123; sb.append(s.charAt(M%N)); M /= N; &#125; // 如果是负数，则添加负号 if(f)&#123; sb.append(&quot;-&quot;); &#125; return sb.reverse().toString(); &#125;&#125; 二分查找在转动过的有序数组中寻找目标值题目链接 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;public class Solution &#123; /** * * @param A int整型一维数组 * @param target int整型 * @return int整型 */ public int search (int[] A, int target) &#123; // 如果没有翻转，则直接二分查找 if(A[0] &lt; A[A.length - 1])&#123; return bsearch(A,target,0,A.length - 1); &#125; int left = 0; int right = A.length - 1; int mid; // 找到翻转点 while(left &lt;= right)&#123; mid = (left + right) / 2; if(A[mid] &gt;= A[0])&#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; // 如果要查找的值比最左边的大，则在翻转点左边二分查找 if(target &gt;= A[0])&#123; return bsearch(A,target,0,right); &#125;else&#123;// 反之 return bsearch(A,target,left,A.length - 1); &#125; &#125; // 二分查找标准代码 public int bsearch(int[] A,int target,int left, int right)&#123; int mid; while(left &lt;= right)&#123; mid = (left + right) / 2; if(target == A[mid])&#123; return mid; &#125;else if(target &gt; A[mid])&#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; return -1; &#125;&#125; 搜索旋转排序数组题目链接 代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int search(int[] nums, int target) &#123; int n = nums.length; if(nums == null || n == 0)&#123; return -1; &#125; if(n == 1)&#123; return nums[0] == target ? 0 : -1; &#125; int left = 0; int right = n - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; // 左边是有序的 if(nums[0] &lt;= nums[mid])&#123; if(nums[mid] &gt; target &amp;&amp; target &gt;= nums[0])&#123; right = mid - 1; &#125;else&#123; left = mid + 1; &#125; &#125;else&#123; // 右边是有序的 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n-1])&#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 搜索旋转排序数组 II题目链接 代码如下： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)&#123; return false; &#125; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = start + (end - start) / 2; if(nums[mid] == target)&#123; return true; &#125; // 去掉重复的 if(nums[start] == nums[mid])&#123; start++; continue; &#125; // 左边部分有序 if(nums[start] &lt; nums[mid])&#123; // target在左边 if(nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target)&#123; end = mid - 1; &#125;else&#123; start = mid + 1; &#125; &#125;else&#123; // target在右边 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[end])&#123; start = mid + 1; &#125;else&#123; end = mid - 1; &#125; &#125; &#125; return false; &#125;&#125; 寻找旋转排序数组中的最小值 II题目链接 代码如下： 12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; int left= 0; int right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right - left) / 2; if(nums[mid] == nums[right])&#123; right--; &#125;else if(nums[mid] &lt; nums[right])&#123; // 中间值比最右边的值小，而中间这个值可能是最小值，所以右指针为mid，不能为mid - 1 right = mid; &#125;else&#123; // 中间值比最右边的值大，因此左指针为mid + 1 left = mid + 1; &#125; &#125; return nums[left]; &#125;&#125; 链表两个链表生成相加链表 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;/* * public class ListNode &#123; * int val; * ListNode next = null; * &#125; */public class Solution &#123; /** * * @param head1 ListNode类 * @param head2 ListNode类 * @return ListNode类 */ public ListNode addInList (ListNode head1, ListNode head2) &#123; // write code here // 将两个链表反转 ListNode p1 = reverse(head1); ListNode p2 = reverse(head2); // 定义结果链表 ListNode res = new ListNode(-1); ListNode curr = res; // 进位 int carry = 0; while(p1 != null || p2 != null)&#123; int sum = 0; if(p1 != null)&#123; sum += p1.val; p1 = p1.next; &#125; if(p2 != null)&#123; sum += p2.val; p2 = p2.next; &#125; // 低位+进位 sum += carry; curr.next = new ListNode(sum % 10); // 从新计算进位 carry = sum / 10; curr = curr.next; &#125; // 如果有进位，直接加到结果链表尾部 if(carry &gt; 0)&#123; curr.next = new ListNode(carry); &#125; // 将结果链表反转 return reverse(res.next); &#125; // 翻转链表 public ListNode reverse(ListNode head)&#123; ListNode pre = null; ListNode next = null; while(head != null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125; 合并k个已排序的链表题目链接 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class Solution &#123; public ListNode mergeKLists(ArrayList&lt;ListNode&gt; lists) &#123; if(lists == null || lists.size() == 0)&#123; return null; &#125; return mergeKList(lists,0,lists.size() - 1); &#125; public ListNode mergeKList(ArrayList&lt;ListNode&gt; lists,int low, int high) &#123; // 左右相等说明不能再分 if(low &gt;= high)&#123; return lists.get(low); &#125; // 计算mid int mid = low + (high - low) / 2; ListNode l1 = mergeKList(lists,low,mid); ListNode l2 = mergeKList(lists,mid + 1,high); return merge(l1,l2); &#125; // 合并两个有序链表 public ListNode merge(ListNode node1,ListNode node2)&#123; ListNode node = new ListNode(-1); ListNode tmp = node; while(node1!=null &amp;&amp; node2!=null)&#123; if(node1.val &lt;= node2.val)&#123; tmp.next = node1; node1 = node1.next; &#125;else&#123; tmp.next = node2; node2 = node2.next; &#125; tmp = tmp.next; &#125; tmp.next = node1!=null?node1:node2; return node.next; &#125;&#125; 单链表的排序题目链接 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;/* * public class ListNode &#123; * int val; * ListNode next = null; * &#125; */public class Solution &#123; /** * * @param head ListNode类 the head node * @return ListNode类 */ public ListNode sortInList (ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; // 使用快慢指针找到链表中间部分 ListNode slow = head; ListNode fast = head.next; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; // 截取第二部分链表 ListNode newList = slow.next; slow.next = null; // 递归继续分割两个链表 ListNode left = sortInList(head); ListNode right = sortInList(newList); // 合并两个有序链表 ListNode dummy = new ListNode(-1); ListNode res = dummy; while(left != null &amp;&amp; right != null)&#123; if(left.val &lt; right.val)&#123; res.next = left; left = left.next; &#125;else&#123; res.next = right; right = right.next; &#125; res = res.next; &#125; res.next = left == null? right : left; return dummy.next; &#125;&#125; 大数加法 代码如下： 123456789101112131415161718192021222324252627import java.util.*;public class Solution &#123; /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算两个数之和 * @param s string字符串 表示第一个整数 * @param t string字符串 表示第二个整数 * @return string字符串 */ public String solve (String s, String t) &#123; // write code here int i = s.length() - 1; int j = t.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while(i &gt;= 0 || j &gt;= 0 || carry != 0)&#123; int x = i &lt; 0 ? 0 : s.charAt(i--) - &#x27;0&#x27;; int y = j &lt; 0 ? 0 : t.charAt(j--) - &#x27;0&#x27;; int sum = x + y + carry; sb.append(sum % 10); carry = sum / 10; &#125; return sb.reverse().toString(); &#125;&#125; 二叉树重建二叉树 代码如下： 123456789101112131415161718192021222324import java.util.*;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; Map&lt;Integer,Integer&gt; map = new HashMap(); for(int i = 0; i &lt; in.length; i++)&#123; map.put(in[i],i); &#125; return dfs(0,pre.length - 1,0,in.length - 1,pre,in,map); &#125; public TreeNode dfs(int pl,int pr,int il,int ir,int[] pre,int[] in,Map&lt;Integer,Integer&gt; map)&#123; if(pl &gt; pr)&#123; return null; &#125; // 根据先序遍历获得根节点 int k = map.get(pre[pl]); TreeNode root = new TreeNode(pre[pl]); // 递归构造左子树 root.left = dfs(pl + 1,pl + k -il,il,k-1,pre,in,map); // 递归构造右子树 root.right = dfs(pl + k- il + 1,pr,k+1,ir,pre,in,map); return root; &#125;&#125; 在二叉树中找到两个节点的最近公共祖先 以下图片来自于牛客￥ABCDEF题解代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;/* * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &#125; */public class Solution &#123; /** * * @param root TreeNode类 * @param o1 int整型 * @param o2 int整型 * @return int整型 */ public int lowestCommonAncestor (TreeNode root, int o1, int o2) &#123; // write code here return dfs(root,o1,o2).val; &#125; public TreeNode dfs(TreeNode root ,int o1,int o2)&#123; // 如果当前节点为空，或者当前节点等于o1或者等于o2就返回值给父亲节点 if(root == null || root.val == o1 || root.val == o2)&#123; return root; &#125; // 递归遍历左子树 TreeNode left = dfs(root.left,o1,o2); // 递归遍历右子树 TreeNode right = dfs(root.right,o1,o2); // 如果left、right都不为空，那么代表o1、o2在root的两侧，所以root为他们的公共祖先 if(left != null &amp;&amp; right != null)&#123; return root; &#125; // 如果left、right有一个为空，那么就返回不为空的那一个 return left == null? right : left; &#125;&#125; 对称的二叉树题目链接 代码如下： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return root == null ? true : recur(root.left,root.right); &#125; public boolean recur(TreeNode A,TreeNode B)&#123; // 左右子树都为空，则树是对称的 if(A == null &amp;&amp; B == null)&#123; return true; &#125; // 只有一边为空，且值不相等，则不对称 if(A == null || B == null || A.val != B.val)&#123; return false; &#125; // 递归判断左右子树，如果都对称，则树对称 return recur(A.left,B.right) &amp;&amp; recur(A.right,B.left); &#125;&#125; 二叉树的右视图题目链接 代码如下： 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList(); if(root == null)&#123; return res; &#125; Queue&lt;TreeNode&gt; q = new LinkedList(); q.offer(root); while(!q.isEmpty())&#123; int size = q.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = q.poll(); if(node.left != null)&#123; q.offer(node.left); &#125; if(node.right != null)&#123; q.offer(node.right); &#125; // 将每一层的最后一个加入结果集,即为右视图 if(i == size - 1)&#123; res.add(node.val); &#125; &#125; &#125; return res; &#125;&#125; 动态规划子数组的最大累加和问题 以下图片来自于牛客￥ABCDEF题解 代码如下： 123456789101112131415161718192021222324252627import java.util.*;public class Solution &#123; /** * max sum of the subarray * @param arr int整型一维数组 the array * @return int整型 */ public int maxsumofSubarray (int[] arr) &#123; // write code here //dp[i]代表到第i位的时侯,以arr[i]结尾的连续子数组最大累加和 int[] dp = new int[arr.length]; dp[0] = arr[0]; int res = arr[0]; for(int i = 1; i&lt; arr.length; i++)&#123; // 如果前面的子数组和大于0，则更新当前位置 if(dp[i-1] &gt; 0)&#123; dp[i] = dp[i-1] + arr[i]; &#125;else&#123; // 否则，更新当前dp值为当前数组值 dp[i] = arr[i]; &#125; res = Math.max(res,dp[i]); &#125; return res; &#125;&#125; 最长递增子序列1. 题目链接 代码如下: 1 2.题目链接 代码如下： 123456789101112131415161718192021222324class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int n = nums.length; // dp数组表示以nums[1]结尾的“最长上升子序列”的长度 int[] dp = new int[n]; // 初始化dp数组为1 Arrays.fill(dp,1); for(int i = 1; i &lt; n; i++)&#123; // 下标为i以前上升子序列 for(int j= 0; j &lt; i; j++)&#123; if(nums[j] &lt; nums[i])&#123; // 根据状态转换图更新最长上升子序列的长度 dp[i] = Math.max(dp[i],dp[j] + 1); &#125; &#125; &#125; // 找到最大值 int max = 0; for(int i = 0; i &lt; n; i++)&#123; max = Math.max(max,dp[i]); &#125; return max; &#125;&#125; 最长公共子序列题目链接 代码如下： 12345678910111213141516171819class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(); int n = text2.length(); int[][] dp = new int[m+1][n+1]; for(int i = 1; i &lt;= m; i++)&#123; char ch1 = text1.charAt(i-1); for(int j = 1; j &lt;= n; j++)&#123; char ch2 = text2.charAt(j-1); if(ch1 == ch2)&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 买卖股票的最佳时机题目链接 123456789101112131415161718192021222324import java.util.*;public class Solution &#123; /** * * @param prices int整型一维数组 * @return int整型 */ public int maxProfit (int[] prices) &#123; int min = Integer.MAX_VALUE; int maxProfit = 0; for(int i = 0; i &lt; prices.length; i++)&#123; // 记录历史最低价 if(prices[i] &lt; min)&#123; min = prices[i]; &#125;else if(prices[i] - min &gt; maxProfit)&#123; // 更新最大收益 maxProfit = prices[i] - min; &#125; &#125; return maxProfit; &#125;&#125; 买卖股票的最佳时机 II题目链接 代码如下： 1 编辑距离题目链接 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Solution &#123; /** * min edit cost * @param str1 string字符串 the string * @param str2 string字符串 the string * @param ic int整型 insert cost * @param dc int整型 delete cost * @param rc int整型 replace cost * @return int整型 */ public int minEditCost (String str1, String str2, int ic, int dc, int rc) &#123; int m = str1.length(); int n = str2.length(); int[][] dp = new int[m+1][n+1]; // 初始化第一行 for(int j = 1; j &lt;= n; j++)&#123; dp[0][j] = j * ic; &#125; // 初始化第一列 for(int i = 1; i &lt;= m; i++)&#123; dp[i][0] = i * dc; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(str1.charAt(i-1) == str2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125;else&#123; // 将i个字符串转变为前j-1个字符串在插入第j个字符 int insert = dp[i][j-1] + ic; // 将i-1个字符串转换为前j个字符串删除第i个字符 int delete = dp[i-1][j] + dc; int replace = dp[i-1][j-1] + rc; dp[i][j] = Math.min(Math.min(insert,delete),replace); &#125; &#125; &#125; return dp[m][n]; &#125;&#125; 中心扩散法最长回文子串 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;public class Solution &#123; public int getLongestPalindrome(String A, int n) &#123; int len = A.length(); if(len &lt; 2)&#123; return A.length(); &#125; int max = 0; for(int i = 0; i &lt; len - 1; i++)&#123; // 回文类型为奇数型 String s1 = helper(A,i,i); // 回文类型为偶数型 String s2 = helper(A,i,i+1); // 求出最长的回文串 String s3 = s1.length() &gt; s2.length()? s1: s2; if(max &lt; s3.length())&#123; max = s3.length(); &#125; &#125; return max; &#125; public String helper(String s, int left, int right)&#123; int len = s.length(); int i = left; int j = right; // 从中间向两边扩散 while(i &gt;= 0 &amp;&amp; j &lt; len)&#123; if(s.charAt(i) == s.charAt(j))&#123; i--; j++; &#125;else&#123; break; &#125; &#125; // 截取回文串 return s.substring(i+1,j); &#125; &#125; 单调栈直方图的水量题目链接 代码如下(双指针)： 12345678910111213141516171819202122232425class Solution &#123; public int trap(int[] height) &#123; int left = 0; int right = height.length - 1; int ans = 0; int leftMax = 0; int rightMax = 0; while(left &lt; right)&#123; // 更新左边的最大值 leftMax = Math.max(leftMax,height[left]); // 更新右边的最大值 rightMax = Math.max(rightMax,height[right]); if(height[left] &lt; height[right])&#123; // 用左边的最大值减去当前高度 ans += leftMax - height[left]; left++; &#125;else&#123; // 用右边的最大值减去当前高度 ans += rightMax - height[right]; right--; &#125; &#125; return ans; &#125;&#125; 代码如下(单调栈): 1234567891011121314151617181920class Solution &#123; public int trap(int[] height) &#123; int ans = 0; Deque&lt;Integer&gt; stack = new LinkedList(); for(int i = 0; i &lt; height.length; i++)&#123; while(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()] )&#123; int top = stack.pop(); if(stack.isEmpty())&#123; break; &#125; int left = stack.peek(); int width = i - left - 1; int currHeight = Math.min(height[i],height[left]) - height[top]; ans += currHeight * width; &#125; stack.push(i); &#125; return ans; &#125;&#125; 柱状图中最大的矩形题目链接 123456789101112131415161718192021222324252627282930313233343536public int largestRectangleArea(int[] heights) &#123; // 初始化最终结果为0 int res = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 将给定的原数组左右各添加一个元素0 int[] newHeights = new int[heights.length + 2]; newHeights[0] = 0; newHeights[newHeights.length-1] = 0; for (int i = 1; i &lt; heights.length + 1; i++) &#123; newHeights[i] = heights[i - 1]; &#125; // 开始遍历 for (int i = 0; i &lt; newHeights.length; i++) &#123; // 如果栈不为空且当前考察的元素值小于栈顶元素值， // 则表示以栈顶元素值为高的矩形面积可以确定 while (!stack.isEmpty() &amp;&amp; newHeights[i] &lt; newHeights[stack.peek()]) &#123; // 弹出栈顶元素 int cur = stack.pop(); // 获取栈顶元素对应的高 int curHeight = newHeights[cur]; // 栈顶元素弹出后，新的栈顶元素就是其左侧边界 int leftIndex = stack.peek(); // 右侧边界是当前考察的索引 int rightIndex = i; // 计算矩形宽度 int curWidth = rightIndex - leftIndex - 1; // 计算面积 res = Math.max(res, curWidth * curHeight); &#125; // 当前考察索引入栈 stack.push(i); &#125; return res; &#125; 栈设计getMin功能的栈题目链接 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class Solution &#123; public Deque&lt;Integer&gt; s = new LinkedList(); public Deque&lt;Integer&gt; min_s = new LinkedList(); /** * return a array which include all ans for op3 * @param op int整型二维数组 operator * @return int整型一维数组 */ public int[] getMinStack (int[][] op) &#123; List&lt;Integer&gt; res = new ArrayList(); for(int i = 0; i &lt; op.length; i++)&#123; if(op[i][0] == 1)&#123; Push(op[i][1]); &#125;else if(op[i][0] == 2)&#123; Pop(); &#125;else&#123; res.add(getMin()); &#125; &#125; int[] ans = new int[res.size()]; for(int i = 0; i &lt; ans.length; i++)&#123; ans[i] = res.get(i); &#125; return ans; &#125; // 如果最小栈为空，或者栈顶元素大于x，则加入最小栈 public void Push(int x)&#123; s.push(x); if(min_s.isEmpty() || min_s.peek() &gt; x)&#123; min_s.push(x); &#125; &#125; // 如果最小栈栈顶元素和栈s中要出栈的元素相等，那么也需要出栈 public void Pop()&#123; if(!s.isEmpty())&#123; if(s.peek().equals(min_s.peek()))&#123; min_s.pop(); &#125; s.pop(); &#125; &#125; // 获得最小栈栈顶元素 public int getMin()&#123; return min_s.peek(); &#125;&#125; 回溯字符串的排列题目链接 代码入下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; int len = str.length(); char[] strs = str.toCharArray(); // 对字符数组排序 Arrays.sort(strs); ArrayList&lt;String&gt; res = new ArrayList(); // 存放路径 Deque&lt;Character&gt; path = new ArrayDeque(); // 保存该字符是否用过 boolean[] used = new boolean[len]; // 深度有限遍历求得所有结果集 dfs(strs,len,0,used,res,path); return res; &#125; public void dfs(char[] strs,int len,int depth,boolean[] used,ArrayList&lt;String&gt; res,Deque&lt;Character&gt; path)&#123; // 如果到达最深的一层 if(len == depth)&#123; // 封装结果 StringBuilder sb = new StringBuilder(); for(char ch : path)&#123; sb.append(ch); &#125; res.add(new String(sb)); return; &#125; for(int i = 0; i &lt; len; i++)&#123; // 判断当前字符是否用过 if(used[i])&#123; continue; &#125; // 因为有重复元素，所以在下一层碰到相同元素将会使结果重复，相对于全排列，进一步剪枝 if(i &gt; 0 &amp;&amp; strs[i] == strs[i-1] &amp;&amp; !used[i-1])&#123; continue; &#125; // 回溯算法经典步骤 // 先将当前字符加入栈，并将使用过的元素标记为true path.addLast(strs[i]); used[i] = true; dfs(strs,len,depth + 1,used,res,path); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; 全排列 II题目链接 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 数组长度 int len = nums.length; Arrays.sort(nums); // 结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 布尔数组，保存改数字是否使用过 boolean[] used = new boolean[len]; // 深度优先遍历求所有结果集 dfs(nums,len,0,used,path,res); return res; &#125; public void dfs(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果到达最深的一层 if(depth == len)&#123; // 将当前路径加入结果集 res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; // 判断当前数字是否用过 if(used[i])&#123; continue; &#125; // 因为有重复元素，所以在下一层碰到相同元素将会使结果重复，相对于全排列，进一步剪枝 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://xmmarlowe.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://xmmarlowe.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://xmmarlowe.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://xmmarlowe.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"dp","slug":"dp","permalink":"https://xmmarlowe.github.io/tags/dp/"}],"author":"Marlowe"},{"title":"类加载过程","slug":"Java/类加载过程","date":"2021-03-31T13:54:49.000Z","updated":"2021-03-31T14:38:17.438Z","comments":true,"path":"2021/03/31/Java/类加载过程/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/31/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的生命周期一个类的完整生命周期如下： 类加载过程系统加载 Class 类型的文件主要三步:加载-&gt;连接-&gt;初始化。连接过程又可分为三步:验证-&gt;准备-&gt;解析。 加载类加载过程的第一步，主要完成下面3件事情： 通过全类名获取定义此类的二进制字节流 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。 验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。 这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。 综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。 初始化初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 ()方法的过程。 对于（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 （） 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。 对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)： 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。 当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。 当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。 当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。 当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。 使用 java.lang.reflect 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。M5. ethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。 「补充」 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。 卸载卸载类即该类的Class对象被GC。 卸载类需要满足3个要求: 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。 该类没有在其他任何地方被引用 该类的类加载器的实例已被GC 所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。 只要想通一点就好了，jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。 参考类的生命周期","categories":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://xmmarlowe.github.io/tags/JVM/"}],"author":"Marlowe"},{"title":"Leetcode-剑指offer 40.最小的K个数","slug":"题解/Leetcode-剑指offer-40-最小的K个数","date":"2021-03-27T11:51:16.000Z","updated":"2021-03-31T14:38:17.442Z","comments":true,"path":"2021/03/27/题解/Leetcode-剑指offer-40-最小的K个数/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/27/%E9%A2%98%E8%A7%A3/Leetcode-%E5%89%91%E6%8C%87offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/","excerpt":"","text":"输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]示例 2： 输入：arr = [0,1,2,1], k = 1输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 100000 &lt;= arr[i] &lt;= 10000 思路本题是求前 K 小，因此用一个容量为 K 的大根堆，每次 poll 出最大的数，那堆中保留的就是前 K 小。 若目前堆的大小小于K，将当前数字放入堆中。 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。 代码12345678910111213141516171819202122232425class Solution &#123; public int[] getLeastNumbers(int[] arr, int k) &#123; if (k == 0 || arr.length == 0) &#123; return new int[0]; &#125; // 默认是小根堆，实现大根堆需要重写一下比较器。 Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1); for (int num: arr) &#123; if (pq.size() &lt; k) &#123; pq.offer(num); &#125; else if (num &lt; pq.peek()) &#123; pq.poll(); pq.offer(num); &#125; &#125; // 返回堆中的元素 int[] res = new int[pq.size()]; int idx = 0; for(int num: pq) &#123; res[idx++] = num; &#125; return res; &#125;&#125; 参考4种解法秒杀TopK（快排/堆/二叉搜索树/计数排序）❤️","categories":[{"name":"题解","slug":"题解","permalink":"https://xmmarlowe.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"TopK","slug":"TopK","permalink":"https://xmmarlowe.github.io/tags/TopK/"}],"author":"Marlowe"},{"title":"富途笔试-找到搜索二叉树中两个错误的节点","slug":"题解/富途笔试-找到搜索二叉树中两个错误的节点","date":"2021-03-27T08:48:17.000Z","updated":"2021-03-31T14:38:17.445Z","comments":true,"path":"2021/03/27/题解/富途笔试-找到搜索二叉树中两个错误的节点/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/27/%E9%A2%98%E8%A7%A3/%E5%AF%8C%E9%80%94%E7%AC%94%E8%AF%95-%E6%89%BE%E5%88%B0%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请按升序输出这两个错误节点的值。(每个节点的值各不相同)示例1输入{1,2,3}返回值[1,2] 思路中序遍历可以得到搜索二叉树的升序遍历结果，题目描述其中两个节点交换了位置，因此只需在中序遍历中找到异常数据即可。 中序遍历二叉树 从前面往后找，发现当前数比后一个数大，则是异常数据，放在结果集下标为1的位置 从后面往前找，发现当前数比前一个数小，则是异常数据，放在结果集下标为0的位置 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;/* * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &#125; */public class Solution &#123; /** * * @param root TreeNode类 the root * @return int整型一维数组 */ List&lt;Integer&gt; res = new ArrayList(); public int[] findError (TreeNode root) &#123; // write code here int[] r = new int[2]; dfs(root); for(int i = 0; i &lt; res.size(); i++)&#123; if(res.get(i) &gt; res.get(i+1))&#123; r[1] = res.get(i); break; &#125; &#125; for(int j = res.size() - 1; j &gt;= 0; j--)&#123; if(res.get(j) &lt; res.get(j-1))&#123; r[0] = res.get(j); break; &#125; &#125; return r; &#125; public void dfs(TreeNode root)&#123; if(root != null)&#123; dfs(root.left); res.add(root.val); dfs(root.right); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://xmmarlowe.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://xmmarlowe.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Marlowe"},{"title":"初始CAS与ABA问题","slug":"JUC/初始CAS与ABA问题","date":"2021-03-25T12:34:19.000Z","updated":"2021-03-26T14:44:46.497Z","comments":true,"path":"2021/03/25/JUC/初始CAS与ABA问题/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/25/JUC/%E5%88%9D%E5%A7%8BCAS%E4%B8%8EABA%E9%97%AE%E9%A2%98/","excerpt":"","text":"什么是CAS？CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 +1 操作 获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令 伪代码： 123456789101112// 需要不断尝试while(true) &#123; int 旧值 = 共享变量;//比如拿到了当前值 0 int 结果 = 旧值 + 1;//在旧值 0 的基础上增加 1 ，正确结果是 1 //这时候如果别的线程把共享变量改成了 5，本线程的正确结果 1 就作 //废了，这时候 compareAndSwap 返回 false，重新尝试，直到： compareAndSwap 返回 //true，表示我本线程做修改的同时，别的线程没有干扰 */ if( compareAndSwap ( 旧值, 结果 )) &#123; // 成功，退出循环 &#125;&#125; 代码示例： 1234567891011121314public class CASDemo &#123; public static void main(String[] args) &#123; AtomicInteger atomicInteger = new AtomicInteger(2020); // public final boolean compareAndSet(int expect, int update) // 如果我的期望值达到了，就更新，否则不更新 CAS是CPU的并发原语！ System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(2020, 2021)); System.out.println(atomicInteger.get()); &#125;&#125; 结果： 1234true2021false2021 CAS 缺点CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。 循环会耗时 一次性只能保证一个共享变量的原子性 ABA问题 CAS:ABA问题(狸猫换太子)参考认识CAS与ABA问题","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"CAS","slug":"CAS","permalink":"https://xmmarlowe.github.io/tags/CAS/"},{"name":"ABA","slug":"ABA","permalink":"https://xmmarlowe.github.io/tags/ABA/"}],"author":"Marlowe"},{"title":"异步回调","slug":"JUC/异步回调","date":"2021-03-25T08:15:43.000Z","updated":"2021-03-25T15:06:53.495Z","comments":true,"path":"2021/03/25/JUC/异步回调/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/25/JUC/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/","excerpt":"","text":"Future 设计初衷：对将来的某个事件的结果进行建模 To be continue…","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"异步","slug":"异步","permalink":"https://xmmarlowe.github.io/tags/%E5%BC%82%E6%AD%A5/"}],"author":"Marlowe"},{"title":"ForkJoin","slug":"JUC/ForkJoin","date":"2021-03-25T05:37:54.000Z","updated":"2021-03-25T15:06:53.489Z","comments":true,"path":"2021/03/25/JUC/ForkJoin/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/25/JUC/ForkJoin/","excerpt":"ForkJoin 在JDK1.7， 并行执行任务！ 在大数据量下提高效率。","text":"ForkJoin 在JDK1.7， 并行执行任务！ 在大数据量下提高效率。 ForkJoin特点：工作窃取 里面维护的是双端队列。 代码示例：ForkJoinDemo.java: 12345678910111213141516171819202122232425262728293031323334public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private Long start; private Long end; private Long temp = 10000L; public ForkJoinDemo(Long start, Long end) &#123; this.start = start; this.end = end; &#125; /** * The main computation performed by this task. * * @return the result of the computation */ @Override protected Long compute() &#123; if ((end - start) &lt; temp) &#123; Long sum = 0L; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125; else &#123; long mid = (start + end) / 2; ForkJoinDemo task1 = new ForkJoinDemo(start, mid); task1.fork(); ForkJoinDemo task2 = new ForkJoinDemo(mid + 1, end); task2.fork(); return task1.join() + task2.join(); &#125; &#125;&#125; 12345678910public static void test1() throws ExecutionException, InterruptedException &#123; long start = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinDemo(0L, 10_0000_0000L); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task); Long sum = submit.get(); long end = System.currentTimeMillis(); System.out.println(&quot;sum = &quot; + sum); System.out.println(&quot;耗时：&quot; + (end - start));&#125; 结果： 12sum = 500000000500000000耗时：4950 并行流 1234567public static void test2() &#123; long start = System.currentTimeMillis(); long sum = LongStream.rangeClosed(0L, 10_0000_0000L).parallel().reduce(0, Long::sum); long end = System.currentTimeMillis(); System.out.println(&quot;sum = &quot; + sum); System.out.println(&quot;耗时：&quot; + (end - start));&#125; 结果： 12sum = 500000000500000000耗时：271","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://xmmarlowe.github.io/tags/ForkJoin/"}],"author":"Marlowe"},{"title":"四大函数式接口","slug":"JUC/四大函数式接口","date":"2021-03-25T05:00:01.000Z","updated":"2021-03-25T15:06:53.485Z","comments":true,"path":"2021/03/25/JUC/四大函数式接口/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/25/JUC/%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"只有一个方法的接口叫做函数式接口。Consumer、Function、Predicate、Supplier","text":"只有一个方法的接口叫做函数式接口。Consumer、Function、Predicate、Supplier 函数式接口的作用：简化编程模型，在新版本的框架底层大量应用！ 12345@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125;// foreach（消费者类型的函数式接口） Function函数型接口：有一个输入参数，有一个输出。 源码： 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t);&#125; 代码示例： 123456789101112131415161718// 只要是函数型接口，可以用lambda表达式简化public static void main(String[] args) &#123; Function function = new Function&lt;String, String&gt;() &#123; @Override public String apply(String string) &#123; return string; &#125; &#125;; System.out.println(function.apply(&quot;hello&quot;)); &#125;// 简化写法public static void main(String[] args) &#123; Function&lt;String, String&gt; function = (str) -&gt; &#123; return str; &#125;; System.out.println(function.apply(&quot;hello&quot;)); &#125; 结果： 1hello Predicate断定型接口：有一个输入参数，返回值只能是布尔值。 源码： 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return &#123;@code true&#125; if the input argument matches the predicate, * otherwise &#123;@code false&#125; */ boolean test(T t);&#125; 代码示例： 12345678910/** * 判断字符串是否为空 * @param args */public static void main(String[] args) &#123; Predicate&lt;String&gt; predicate = (str) -&gt;&#123; return str.isEmpty(); &#125;; System.out.println(predicate.test(&quot;11&quot;));&#125; 结果： 12falsetrue Consumer消费型接口：只有输入，没有返回值。 源码： 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t);&#125; 代码示例： 1234567891011/** * 打印字符串 * * @param args */public static void main(String[] args) &#123; Consumer&lt;String&gt; consumer = str -&gt; &#123; System.out.println(str); &#125;; consumer.accept(&quot;consumer&quot;);&#125; 结果： 1consumer Supplier供给型接口：没有参数，只有返回值。 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125; 代码示例： 1234567891011/** * 返回固定值 1024 * * @param args */public static void main(String[] args) &#123; Supplier&lt;Integer&gt; supplier = () -&gt; &#123; return 1024; &#125;; System.out.println(supplier.get());&#125; 结果： 11024","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"函数式接口","slug":"函数式接口","permalink":"https://xmmarlowe.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"}],"author":"Marlowe"},{"title":"Redis 相关知识点总结","slug":"NoSQL/Redis-相关知识点总结","date":"2021-03-22T17:01:53.000Z","updated":"2021-03-24T14:41:26.955Z","comments":true,"path":"2021/03/23/NoSQL/Redis-相关知识点总结/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/23/NoSQL/Redis-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[],"tags":[],"author":"Marlowe"},{"title":"JVM GC调优","slug":"Java/JVM-GC调优","date":"2021-03-22T16:46:49.000Z","updated":"2021-03-24T14:41:26.953Z","comments":true,"path":"2021/03/23/Java/JVM-GC调优/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/23/Java/JVM-GC%E8%B0%83%E4%BC%98/","excerpt":"","text":"参考JVM GC调优入门","categories":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://xmmarlowe.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://xmmarlowe.github.io/tags/GC/"}],"author":"Marlowe"},{"title":"浅谈DNS协议","slug":"计算机网络/浅谈DNS协议","date":"2021-03-22T16:40:29.000Z","updated":"2021-04-08T02:36:10.449Z","comments":true,"path":"2021/03/23/计算机网络/浅谈DNS协议/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%B0%88DNS%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"参考浅谈DNS协议","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://xmmarlowe.github.io/tags/DNS/"}],"author":"Marlowe"},{"title":"B+树对比B树的好处","slug":"算法与数据结构/B-树对比B树的好处","date":"2021-03-22T16:32:18.000Z","updated":"2021-04-09T07:58:32.598Z","comments":true,"path":"2021/03/23/算法与数据结构/B-树对比B树的好处/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B-%E6%A0%91%E5%AF%B9%E6%AF%94B%E6%A0%91%E7%9A%84%E5%A5%BD%E5%A4%84/","excerpt":"","text":"B+树的磁盘读写代价更低B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部 结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 B+树的数据信息遍历更加方便B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作（或者说效率太低），而且 在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树。 B+树的查询效率更加稳定由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xmmarlowe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"BTree","slug":"BTree","permalink":"https://xmmarlowe.github.io/tags/BTree/"},{"name":"B+Tree","slug":"B-Tree","permalink":"https://xmmarlowe.github.io/tags/B-Tree/"}],"author":"Marlowe"},{"title":"TCP流量控制、拥塞控制","slug":"计算机网络/TCP流量控制、拥塞控制","date":"2021-03-22T16:24:56.000Z","updated":"2021-04-09T05:37:09.322Z","comments":true,"path":"2021/03/23/计算机网络/TCP流量控制、拥塞控制/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一、流量控制什么是流量控制？流量控制的目的？如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。 如何实现流量控制？由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。 流量控制引发的死锁？怎么避免死锁的发生？当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。 二、拥塞控制和流量控制的区别拥塞控制： 拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。 流量控制： 流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。 三、拥塞控制的算法（一）慢开始算法：发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。 慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。 这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。如下图： 从上图可以看到，一个传输轮次所经历的时间其实就是往返时间RTT，而且每经过一个传输轮次（transmission round），拥塞窗口cwnd就加倍。 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：当cwnd&lt;ssthresh时，使用慢开始算法。当cwnd&gt;ssthresh时，改用拥塞避免算法。当cwnd=ssthresh时，慢开始与拥塞避免算法任意 注意，这里的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。 （二）拥塞避免算法：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 整个拥塞控制的流程如下图： （1）拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16（2）执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长（3）假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。当cwnd=12=ssthresh时，改为执行拥塞避免算法 关于 乘法减小（Multiplicative Decrease）和加法增大（Additive Increase）： “乘法减小”指的是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法，所以当网络频繁出现拥塞时，ssthresh下降的很快，以大大减少注入到网络中的分组数。“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止过早出现拥塞。常合起来成为AIMD算法。 注意：“拥塞避免”并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。 （三）快重传算法：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 如下图： （四）快恢复算法：快重传配合使用的还有快恢复算法，有以下两个要点： 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法，考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如下图：TCP Reno版本是目前使用最广泛的版本。 注意：在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。 参考TCP流量控制、拥塞控制","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://xmmarlowe.github.io/tags/TCP/"}],"author":"Marlowe"},{"title":"HTTP 和 HTTPS","slug":"计算机网络/HTTP-和-HTTPS-","date":"2021-03-22T14:11:06.000Z","updated":"2021-04-09T14:12:28.055Z","comments":true,"path":"2021/03/22/计算机网络/HTTP-和-HTTPS-/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-%E5%92%8C-HTTPS-/","excerpt":"","text":"HTTPHTTPS区别 端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。 安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等； 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。 Https为什么安全？因为HTTPS保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。 HTTPS的传输过程是怎样的?客户端发起HTTPS请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。 为什么需要证书?防止”中间人“攻击，同时可以为网站提供身份证明。 使用Https会被抓包吗？会被抓包，HTTPS只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xmmarlowe.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://xmmarlowe.github.io/tags/HTTPS/"}],"author":"Marlowe"},{"title":"TCP三次握手、四次挥手","slug":"计算机网络/TCP三次握手、四次挥手","date":"2021-03-22T13:47:45.000Z","updated":"2021-04-09T06:25:41.999Z","comments":true,"path":"2021/03/22/计算机网络/TCP三次握手、四次挥手/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"","text":"三次握手客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 为什么不两次握手？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 为什么不四次握手？四次握手的过程就是把第二次握手拆分成了两次，一次服务器响应ACK，再一次发回SYN来确定客户端的接收是否正常。因为握手没有数据传输，所以可以放在一次就可以完成的没有必要用两次。 四次挥手 为什么需要四次挥手？任何⼀⽅都可以在数据传送结束后发出连接释放的通知，待对⽅确认后进⼊半关闭状态。当另⼀⽅也没有数据再发送的时候，则发出连接释放通知，对⽅确认后就完全关闭了TCP连接。 举个例⼦：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 &gt;B 跟着⾃⼰的节奏结束通话，于是 B 可能⼜巴拉巴拉说了⼀通，最后B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 问题TCP初始序列号为什么是随机的？在TCP的三次握手中，采用随机产生的初始化序列号进行请求，这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，并且伪造序列号进行攻击，这已经成为一种很常见的网络攻击手段。 参考TCP的三次握手与四次挥手两张动图-彻底明白TCP的三次握手与四次挥手","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://xmmarlowe.github.io/tags/TCP/"}],"author":"Marlowe"},{"title":"进程和线程相关知识点","slug":"操作系统/进程和线程相关知识点","date":"2021-03-22T13:42:24.000Z","updated":"2021-04-09T07:37:42.898Z","comments":true,"path":"2021/03/22/操作系统/进程和线程相关知识点/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"何为进程？进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 何为线程？线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 何为协程？协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。 线程和进程的区别是什么？总结: 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护;而进程正相反。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://xmmarlowe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://xmmarlowe.github.io/tags/%E8%BF%9B%E7%A8%8B/"}],"author":"Marlowe"},{"title":"网络5层模型和7层模型","slug":"计算机网络/网络5层模型和7层模型","date":"2021-03-22T12:51:17.000Z","updated":"2021-03-24T14:41:26.997Z","comments":true,"path":"2021/03/22/计算机网络/网络5层模型和7层模型/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C5%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C7%E5%B1%82%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"体系结构图 七层OSI 参考OSI的七层模型","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"OSI","slug":"OSI","permalink":"https://xmmarlowe.github.io/tags/OSI/"}],"author":"Marlowe"},{"title":"操作系统之内存管理","slug":"操作系统/操作系统之内存管理","date":"2021-03-22T11:58:34.000Z","updated":"2021-03-24T14:41:26.958Z","comments":true,"path":"2021/03/22/操作系统/操作系统之内存管理/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"虚拟地址转换为物理地址 第一步，先将虚拟地址转换为逻辑地址： 根据程序中的虚拟地址得出其所在的段，然后加上段偏移，我们就能得到一个逻辑地址 第二步，再将逻辑地址转换为线型地址： 有了逻辑地址之后，我们需要将逻辑地址转换为线型地址（因为线型地址是逻辑地址转换到物理地址的一个中间层），只需要把逻辑地址加上段的基地址就能生成一个线型地址 第三步，再将线型地址再转换为物理地址： 如果启用了分页机制，那么就需要将需要找到段中对应页的地址，然后再找到页内偏移地址，最后得到物理地址 如果没有启用分页机制，那么线型地址直接就是物理地址了 参考操作系统之内存管理","categories":[],"tags":[],"author":"Marlowe"},{"title":"线程之间同步的机制","slug":"操作系统/线程之间同步的机制","date":"2021-03-22T11:41:19.000Z","updated":"2021-04-08T06:45:36.950Z","comments":true,"path":"2021/03/22/操作系统/线程之间同步的机制/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%9C%BA%E5%88%B6/","excerpt":"待完善…","text":"待完善… 临界区：不可以跨进程，忘记解锁会无限等待，要么存在要么没有，多线程访问独占性共享资源 互斥量：可以跨进程，忘记解锁会自动释放，要么存在要么没有 事件：又叫线程触发器，不可以跨进程，要么存在要么没有，一个线程来唤醒另一个线程（包括自动和人工两种方式） 信号量：可以跨进程，始终代表可用资源数量，当资源数为0时，线程阻塞，允许多个线程同时访问一个共享资源","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"常用排序算法Java实现","slug":"算法与数据结构/常用排序算法Java实现","date":"2021-03-20T07:14:27.000Z","updated":"2021-03-22T08:03:50.777Z","comments":true,"path":"2021/03/20/算法与数据结构/常用排序算法Java实现/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/20/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/","excerpt":"排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。","text":"排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 算法概览 排序算法1 冒泡排序算法思想从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。动图演示最好情况当输入的数据已经是正序最差情况当输入的数据是反序代码实现 1234567891011121314151617181920/** * 冒泡排序 * * @param nums */public static void bubbleSort(int[] nums) &#123; int n = nums.length; boolean flag = false; for (int i = 0; i &lt; n - 1 &amp;&amp; !flag; i++) &#123; flag = true; for (int j = 0; j &lt; n - 1 - i; j++) &#123; // 如果全都排好，则flag = true,跳出循环 if (nums[j] &gt; nums[j + 1]) &#123; flag = false; swap(nums, j, j + 1); &#125; &#125; &#125; System.out.println(Arrays.toString(nums));&#125; 2 选择排序算法思想每一次从未排序的集合中选出最小的数，依次放在第1、2、3…位置处动图演示 最好情况当输入的数据已经是正序最差情况当输入的数据是反序 代码实现 1234567891011121314151617181920212223/** * 选择排序 * * @param nums */public static void selectSort(int[] nums) &#123; int n = nums.length; // 比较n - 1 轮 for (int i = 0; i &lt; n - 1; i++) &#123; int min = i; // 每一轮找到最小值的下标 for (int j = i + 1; j &lt; n; j++) &#123; if (nums[j] &lt; nums[min]) &#123; min = j; &#125; &#125; // 找到最小值与当前值交换 if (min != i) &#123; swap(nums, i, min); &#125; &#125; System.out.println(Arrays.toString(nums));&#125; 3 插入排序算法思想将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动图演示 最好情况如果序列是完全有序的，插入排序只要比较n次，无需移动，时间复杂度为O(N)最差情况如果序列是逆序的，插入排序要比较O（N2）和移动O(N2)代码实现 1234567891011121314/** * 插入排序 * @param nums */public static void insertSort(int[] nums) &#123; int n = nums.length; for (int i = 1; i &lt; n; i++) &#123; // 从后往前找，如果当前元素比最后一个元素都大，则当前轮次排序结束 for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j - 1]; j--) &#123; swap(nums, j, j - 1); &#125; &#125; System.out.println(Arrays.toString(nums));&#125; 4 希尔排序算法思想希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。动图演示最好情况序列是正序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)最差情况O(nlog2n)代码实现 123456789101112131415161718192021/** * 希尔排序 * * @param nums */public static void shellSort(int[] nums) &#123; int n = nums.length; // gap： 增量，每次减半 for (int gap = n / 2; gap &gt; 0; gap /= 2) &#123; // i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标 for (int i = gap; i &lt; n; i++) &#123; // j:代表与i同一组的数组元素角标 for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (nums[j] &gt; nums[j + gap]) &#123; swap(nums, j, j + gap); &#125; &#125; &#125; &#125; System.out.println(Arrays.toString(nums));&#125; 5 归并排序算法思想归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示最好情况O(nlogn)最差情况O(nlogn)代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 合并两个有序子数组 * @param nums * @param low * @param mid * @param high * @param tmp */public static void merge(int[] nums, int low, int mid, int high, int[] tmp) &#123; int i = 0; int j = low; int k = mid + 1; while (j &lt;= mid &amp;&amp; k &lt;= high) &#123; if (nums[j] &lt; nums[k]) &#123; tmp[i++] = nums[j++]; &#125; else &#123; tmp[i++] = nums[k++]; &#125; &#125; while (j &lt;= mid) &#123; tmp[i++] = nums[j++]; &#125; while (k &lt;= high) &#123; tmp[i++] = nums[k++]; &#125; for (int l = 0; l &lt; i; l++) &#123; nums[low + l] = tmp[l]; &#125;&#125;/** * 左右子数组分别递归分 * @param nums * @param low * @param high * @param tmp */public static void mergeSort(int[] nums, int low, int high, int[] tmp) &#123; if (low &lt; high) &#123; int mid = (low + high) &gt;&gt; 1; mergeSort(nums, low, mid, tmp); mergeSort(nums, mid + 1, high, tmp); merge(nums, low, mid, high, tmp); &#125;&#125; 6 快速排序算法思想快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。算法步骤： 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 动图演示最好情况最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)最差情况最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)代码实现 1234567891011121314151617181920212223242526272829303132333435363738/** * 快速排序 * * @param nums * @param low * @param high */public static void quickSort(int[] nums, int low, int high) &#123; int i, j, tmp; if (low &gt; high) &#123; return; &#125; i = low; j = high; //tmp就是基准位 tmp = nums[low]; while (i &lt; j) &#123; //先看右边，依次往左递减 while (tmp &lt;= nums[j] &amp;&amp; i &lt; j) &#123; j--; &#125; //再看左边，依次往右递增 while (tmp &gt;= nums[i] &amp;&amp; i &lt; j) &#123; i++; &#125; //如果满足条件则交换 if (i &lt; j) &#123; swap(nums, i, j); &#125; &#125; //最后将基准为与i和j相等位置的数字交换 nums[low] = nums[i]; nums[i] = tmp; //递归调用左半数组 quickSort(nums, low, j - 1); //递归调用右半数组 quickSort(nums, j + 1, high);&#125; 7 堆排序算法思想堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 动图演示最好情况O(nlogn)最差情况O(nlogn)代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class HeapSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;88, 11, 22, 3, 5, 1, 19&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int[] arr) &#123; int len = arr.length; buildHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; //首尾交换 swap(arr, 0, i); //重新维护堆性质 heapify(arr, 0, --len); &#125; &#125; private static void buildHeap(int[] arr, int len) &#123; for (int i = 0; i &lt; len / 2; i++) &#123; heapify(arr, i, len); &#125; &#125; private static void heapify(int[] arr, int index, int len) &#123; int left = 2 * index + 1; int right = 2 * index + 2; int max = index; if (left &lt; len &amp;&amp; arr[left] &gt; arr[max]) &#123; max = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[max]) &#123; max = right; &#125; if (max != index) &#123; swap(arr, max, index); heapify(arr, max, len); &#125; &#125; /** * 交换 * * @param arr 数组 * @param self 自身 * @param other 另一个 */ private static void swap(int[] arr, int self, int other) &#123; int tmp = arr[self]; arr[self] = arr[other]; arr[other] = tmp; &#125;&#125; 8 计数排序算法思想计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法的步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 动图演示 代码实现 1234567891011121314151617181920212223242526/** * 计数排序 * * @param nums */public static void countSort(int[] nums) &#123; int max = Integer.MIN_VALUE; // 找到最大值 for (int num : nums) &#123; if (num &gt; max) &#123; max = num; &#125; &#125; int[] bucket = new int[max + 1]; // 统计每个元素的个数 for (int num : nums) &#123; bucket[num]++; &#125; int index = 0; for (int i = 0; i &lt; bucket.length; i++) &#123; while (bucket[i] &gt; 0) &#123; nums[index++] = i; bucket[i]--; &#125; &#125;&#125; 9 桶排序算法思想桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 动图演示元素分布在桶中：然后，元素在每个桶中排序： 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class BucketSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;5, 11, 7, 9, 2, 3, 12, 8, 6, 1, 4, 10&#125;; sort(arr, 5); System.out.println(Arrays.toString(arr)); &#125; private static void sort(int[] arr, int bucketSize) &#123; if (arr.length == 0) &#123; return; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (maxValue - minValue) / bucketSize + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int item : arr) &#123; int index = (item - minValue) / bucketSize; buckets[index] = arrAppend(buckets[index], item); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了归并排序 MergeSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; &#125; /** * 自动扩容，并保存数据 */ private static int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 10 基数排序算法思想基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 动图演示 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;5, 11, 7, 9, 2, 3, 12, 8, 6, 1, 4, 10&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static int[] sort(int[] arr) &#123; int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private static int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLength(maxValue); &#125; private static int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected static int getNumLength(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private static int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private static int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://xmmarlowe.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://xmmarlowe.github.io/tags/%E6%8E%92%E5%BA%8F/"}],"author":"Marlowe"},{"title":"JUC 核心之AQS介绍","slug":"并发/JUC-核心之AQS介绍","date":"2021-03-19T14:19:40.000Z","updated":"2021-03-21T03:31:42.961Z","comments":true,"path":"2021/03/19/并发/JUC-核心之AQS介绍/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/19/%E5%B9%B6%E5%8F%91/JUC-%E6%A0%B8%E5%BF%83%E4%B9%8BAQS%E4%BB%8B%E7%BB%8D/","excerpt":"AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。","text":"AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。 1、简介AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。 2、AQS原理分析2.1 AQS原理概览AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。 看个 AQS(AbstractQueuedSynchronizer)原理图： AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。 1private volatile int state;//共享变量，使用volatile修饰保证线程可见性 状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作 12345678910111213//返回同步状态的当前值protected final int getState() &#123; return state;&#125; // 设置同步状态的值protected final void setState(int newState) &#123; state = newState;&#125;//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 2.2 AQS 对资源的共享方式AQS 定义两种资源共享方式 Exclusive（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 Share（共享）：多个线程可同时执行，如 CountDownLatch、Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。 2.3 AQS 底层使用了模板方法模式AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法： 12345isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。 默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。 再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 3、AQS 组件总结 Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 CountDownLatch （倒计时器）： CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 CyclicBarrier (循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。 参考","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"AQS","slug":"AQS","permalink":"https://xmmarlowe.github.io/tags/AQS/"},{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/tags/JUC/"}],"author":"Marlowe"},{"title":"Atomic 原子类","slug":"并发/Atomic-原子类","date":"2021-03-19T13:03:15.000Z","updated":"2021-03-19T14:31:01.462Z","comments":true,"path":"2021/03/19/并发/Atomic-原子类/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/19/%E5%B9%B6%E5%8F%91/Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB/","excerpt":"Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。","text":"Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 1、简介原子类说简单点就是具有原子/原子操作特征的类。 2、JUC 包中的原子类是哪 4 类?基本类型 使用原子的方式更新基本类型 AtomicInteger：整形原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型 使用原子的方式更新数组里的某个元素 AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater：原子更新引用类型字段的更新器 3、讲讲 AtomicInteger 的使用AtomicInteger 类常用方法 1234567public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 AtomicInteger 类的使用示例使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。 1234567891011class AtomicIntegerTest &#123; private AtomicInteger count = new AtomicInteger(); //使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。 public void increment() &#123; count.incrementAndGet(); &#125; public int getCount() &#123; return count.get(); &#125;&#125; 4、 AtomicInteger 类的原理AtomicInteger 类的部分源码： 123456789101112// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value; AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。 参考Atomic 原子类","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"原子类","slug":"原子类","permalink":"https://xmmarlowe.github.io/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"}],"author":"Marlowe"},{"title":"线程池原理分析","slug":"并发/线程池原理分析","date":"2021-03-19T12:38:30.000Z","updated":"2021-03-19T12:43:24.306Z","comments":true,"path":"2021/03/19/并发/线程池原理分析/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/19/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"execute方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; private final BlockingQueue&lt;Runnable&gt; workQueue; public void execute(Runnable command) &#123; // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // ctl 中保存的线程池当前的一些状态信息 int c = ctl.get(); // 下面会涉及到 3 步 操作 // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里 // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。 if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 如果当前线程池为空就新创建一个线程并执行。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command); &#125; 具体流程见图解：","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"author":"Marlowe"},{"title":"线程池","slug":"并发/线程池","date":"2021-03-18T08:11:53.000Z","updated":"2021-03-25T04:56:53.228Z","comments":true,"path":"2021/03/18/并发/线程池/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/18/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。三大创建方法、七大参数、四种拒绝策略…","text":"池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。三大创建方法、七大参数、四种拒绝策略… 1、为什么要用线程池？ 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 2、实现 Runnable 接口和 Callable 接口的区别Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口， 这样代码看起来会更加简洁。 工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable（Runnable task）或 Executors.callable（Runnable task，Object resule））。 Runnable.java 1234567@FunctionalInterfacepublic interface Runnable &#123; /** * 被线程执行，没有返回值也无法抛出异常 */ public abstract void run();&#125; Callable.java 123456789@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * 计算结果，或在无法这样做时抛出异常。 * @return 计算得出的结果 * @throws 如果无法计算结果，则抛出异常 */ V call() throws Exception;&#125; 3、执行 execute()方法和 submit()方法的区别是什么呢？ execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功， 并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 4、ThreadPoolExecutor 类分析ThreadPoolExecutor 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么）。 123456789101112131415161718192021222324/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 4.1 ThreadPoolExecutor构造函数重要参数分析ThreadPoolExecutor 3 个最重要的参数： corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。 maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。 workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。 ThreadPoolExecutor其他常见参数: keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁； unit : keepAliveTime 参数的时间单位。 threadFactory :executor 创建新线程的时候会用到。 handler :饱和策略。关于饱和策略下面单独介绍一下。 4.2 ThreadPoolExecutor 饱和策略(4z种拒绝策略)ThreadPoolExecutor 饱和策略定义: 如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略: ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。 举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。 编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。 ThreadPoolExecutorDemo.java 1234567891011121314151617181920212223242526272829303132333435import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolExecutorDemo &#123; private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int QUEUE_CAPACITY = 100; private static final Long KEEP_ALIVE_TIME = 1L; public static void main(String[] args) &#123; //使用阿里巴巴推荐的创建线程池的方式 //通过ThreadPoolExecutor构造函数自定义参数创建 ThreadPoolExecutor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY), new ThreadPoolExecutor.CallerRunsPolicy()); for (int i = 0; i &lt; 10; i++) &#123; //创建WorkerThread对象（WorkerThread类实现了Runnable 接口） Runnable worker = new MyRunnable(&quot;&quot; + i); //执行Runnable executor.execute(worker); &#125; //终止线程池 executor.shutdown(); while (!executor.isTerminated()) &#123; &#125; System.out.println(&quot;Finished all threads&quot;); &#125;&#125; 可以看到我们上面的代码指定了： corePoolSize: 核心线程数为 5。 maximumPoolSize ：最大线程数 10 keepAliveTime : 等待时间为 1L。 unit: 等待时间的单位为 TimeUnit.SECONDS。 workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100; handler:饱和策略为 CallerRunsPolicy。 5、线程池原理分析为了搞懂线程池的原理，我们需要首先分析一下 execute方法。看看它的源码： 12345678910111213141516171819202122232425262728293031323334353637383940// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; private final BlockingQueue&lt;Runnable&gt; workQueue; public void execute(Runnable command) &#123; // 如果任务为null，则抛出异常。 if (command == null) throw new NullPointerException(); // ctl 中保存的线程池当前的一些状态信息 int c = ctl.get(); // 下面会涉及到 3 步 操作 // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里 // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。 if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 如果当前线程池为空就新创建一个线程并执行。 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。 //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。 else if (!addWorker(command, false)) reject(command); &#125; 图解： 小结线程池最大线程数到底该如何定义： CPU 密集型：电脑是几核，就是几，可以保持CPU的效率最高。12// 获取CPU核心数Runtime.getRuntime().availableProcessors() IO 密集型：判断程序中十分耗IO的线程有多少个，大于这个数（或者2倍） 参考线程池","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"author":"Marlowe"},{"title":"volatile 关键字","slug":"并发/volatile-关键字","date":"2021-03-18T02:30:02.000Z","updated":"2021-04-08T07:16:01.318Z","comments":true,"path":"2021/03/18/并发/volatile-关键字/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/18/%E5%B9%B6%E5%8F%91/volatile-%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"volatile 是Java虚拟机提供的轻量级同步机制，保证可见性，不保证原子性，禁止指令重排。","text":"volatile 是Java虚拟机提供的轻量级同步机制，保证可见性，不保证原子性，禁止指令重排。 1、CPU缓存模型为什么要弄一个 CPU 高速缓存呢？类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。 我们甚至可以把 内存可以看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。 总结： CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。 CPU Cache 的工作方式： 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 内存缓存不一致性的问题 ！ 比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。 CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。 2、讲一下 JMM(Java 内存模型)在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 所以，volatile 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。 关于JMM的一些同步约定： 线程解锁前，必须把共享变量立刻刷回主存。 线程加锁前，必须读取主存中的最新值到工作内存中。 加锁和解锁是同一把锁。 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成： lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则： 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 代码示例：开启两个线程，一个主线程，一个新线程。 1234567891011121314151617181920public class Test3 &#123; private static int num = 0; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; // 线程1对主内存的变化是不知道的 while (num == 0) &#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 结果： 1231// 程序一直执行 问题：程序不知道主内存的值已经被修改为1 3、volatile 保证可见性 代码示例： 1234567891011121314151617181920212223public class Test3 &#123; /** * 不加 volatile 程序会死循环！ * 加 volatile 可以保证变量可见性 */ private volatile static int num = 0; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while (num == 0) &#123; &#125; &#125;).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; num = 1; System.out.println(num); &#125;&#125; 结果： 1231Process finished with exit code 0 不保证原子性 原子性：不可分割线程A在执行任务的时候，是不能被打扰的，也不能被分割，要么同时成功，要么同时失败。 代码示例： 1234567891011121314151617181920212223242526public class TestVolatile &#123; // volatile 不保证原子性 private volatile static int num = 0; public static void add() &#123; // 不是原子性操作 num++; &#125; public static void main(String[] args) &#123; // 理论上num结果应该为2w for (int i = 1; i &lt;= 20; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 结果： 1main 19782 // 结果每次可能不一样，但不会变为2w 如果不加lock和synchronized,怎么样保证原子性? 使用原子类解决原子性问题 代码示例: 1234567891011121314151617181920212223242526public class TestVolatile &#123; // volatile 不保证原子性 private volatile static AtomicInteger num = new AtomicInteger(); public static void add() &#123; // AtomicInteger +1 方法 不是简单的 +1 操作，而是用的CAS num.getAndIncrement(); &#125; public static void main(String[] args) &#123; // 理论上num结果应该为2w for (int i = 1; i &lt;= 20; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; add(); &#125; &#125;).start(); &#125; while (Thread.activeCount() &gt; 2) &#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + &quot; &quot; + num); &#125;&#125; 结果： 1main 20000 这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在。 禁止指令重排 什么是指令重排：你写的程序，计算机并不是按照你写的那样去执行的。源代码–&gt; 编译器优化的重排–&gt; 指令并行也可能重排–&gt; 内存系统也会重排–&gt; 执行. 前提：处理器在进行指令重排的时候，会考虑数据之间的依赖性！ 123456int x = 1; // 1int y = 2; // 2x = x + 5; // 3y = x * x; // 4我们所期望的：1234 但是可能执行的时候会变成 2134 1324 volatile可以避免指令重排：内存屏障，CPU指令。 作用： 保证特定操作的执行顺序。 可以保证某些变量的内存可见性（利用这些特性，volatile实现了可见性）。 volatile 可以保证可见性，不能保证原子性，由于内存屏障，可以保证避免指令重排的现象产生！ 4、并发编程的三个重要特性 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。synchronized 可以保证代码片段的原子性。 可见性 ： 当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。 有序性 ： 代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。 5、说说 synchronized 关键字和 volatile 关键字的区别synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！ volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比synchronized关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。 synchronized 关键字两者都能保证。 volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 5、参考volatile 关键字","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"volatile","slug":"volatile","permalink":"https://xmmarlowe.github.io/tags/volatile/"}],"author":"Marlowe"},{"title":"synchronized相关知识点","slug":"春招面试/synchronized相关知识点","date":"2021-03-17T14:39:35.000Z","updated":"2021-03-18T14:37:05.033Z","comments":true,"path":"2021/03/17/春招面试/synchronized相关知识点/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/17/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/synchronized%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1、synchronized 关键字 1.1 synchronized 关键字简介synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。 为什么呢？因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。 庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 synchronized 关键字。 2、synchronized 关键字使用方式synchronized 关键字最主要的三种使用方式： 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁123synchronized void method() &#123; //业务代码&#125; 修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。123synchronized static void method() &#123;//业务代码&#125; 修饰代码块： 指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进入同步代码前要获得 当前 class 的锁 123synchronized(this) &#123; //业务代码&#125; 总结： synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。 synchronized 关键字加到实例方法上是给对象实例上锁。 尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！ 重点：面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全） 1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 构造方法不能使用synchronized 关键词修饰。因为构造方法本身就属于线程安全的，不存在同步的构造方法一说。 2.1 synchronized 关键字的底层原理2.1.1 synchronized 同步语句块的情况1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; 从上面我们可以看出： synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。 在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。 在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 2.1.2 synchronized 修饰方法的的情况12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(&quot;synchronized 方法&quot;); &#125;&#125; synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 2.1.3 总结synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。 不过两者的本质都是对对象监视器 monitor 的获取。 2.2 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 2.3 谈谈 synchronized 和 ReentrantLock 的区别2.3.1 两者都是可重入锁“可重入锁” 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。 2.3.2 synchronized 依赖于 JVM 而 ReentrantLock 依赖于 APIsynchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。 2.3.3 ReentrantLock 比 synchronized 增加了一些高级功能相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点： 等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。 可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。 Condition是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个 Lock 对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 3、参考synchronized 关键字","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"synchronized","slug":"synchronized","permalink":"https://xmmarlowe.github.io/tags/synchronized/"}],"author":"Marlowe"},{"title":"HashMap扩容机制","slug":"春招面试/HashMap扩容机制","date":"2021-03-16T02:33:21.000Z","updated":"2021-03-16T12:55:24.851Z","comments":true,"path":"2021/03/16/春招面试/HashMap扩容机制/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/16/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/","excerpt":"聊聊HashMap扩容机制","text":"聊聊HashMap扩容机制 1、什么时候才需要扩容 在首次调用put方法的时候，初始化数组table 当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。 什么是红黑树：红黑树是一种自平衡的二叉查找树。 性质： 节点是红色或黑色。 根节点是黑色。 每个叶子节点都是黑色的空节点（NIL节点）。 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 红黑树相比于BST和AVL树有什么优点？ 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。 相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。 2、HashMap的扩容是什么进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”原位置+旧容量“这个位置。 说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”原位置+旧容量”这个位置。 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(原位置+旧容量)”。 正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。 resize()方法源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105final Node&lt;K,V&gt;[] resize() &#123; //得到当前数组 Node&lt;K,V&gt;[] oldTab = table; //如果当前数组等于null长度返回0，否则返回当前数组的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前阀值点 默认是12(16*0.75) int oldThr = threshold; int newCap, newThr = 0; //如果老的数组长度大于0 //开始计算扩容后的大小 if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //修改阈值为int的最大值 threshold = Integer.MAX_VALUE; return oldTab; &#125; /* 没超过最大值，就扩充为原来的2倍 1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量 2)oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16 */ else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //阈值扩大一倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; //老阈值点大于0 直接赋值 else if (oldThr &gt; 0) // 老阈值赋值给新的数组长度 newCap = oldThr; else &#123;// 直接使用默认值 newCap = DEFAULT_INITIAL_CAPACITY;//16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize最大上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //新的阀值 默认原来是12 乘以2之后变为24 threshold = newThr; //创建新的哈希表 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) //newCap是新的数组长度--》32 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //判断旧数组是否等于空 if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 //遍历旧的哈希表的每个桶，重新计算桶里元素的新位置 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; //原来的数据赋值为null 便于GC回收 oldTab[j] = null; //判断数组是否有下一个引用 if (e.next == null) //没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入 newTab[e.hash &amp; (newCap - 1)] = e; //判断是否是红黑树 else if (e instanceof TreeNode) //说明是红黑树来处理冲突的，则调用相关方法把树分开 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 采用链表处理冲突 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //通过上述讲解的原理来计算节点的新位置 do &#123; // 原索引 next = e.next; //这里来判断如果等于true e这个节点在resize之后不需要移动位置 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 参考面试题：HashMap扩容机制","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"}],"author":"Marlowe"},{"title":"ConcurrentHashMap 线程安全的具体实现方式/底层具体实现","slug":"春招面试/ConcurrentHashMap-线程安全的具体实现方式-底层具体实现","date":"2021-03-16T01:57:08.000Z","updated":"2021-03-16T12:46:53.468Z","comments":true,"path":"2021/03/16/春招面试/ConcurrentHashMap-线程安全的具体实现方式-底层具体实现/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/16/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"JDK1.7 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。 Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。 12static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;&#125; 一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。 JDK1.8ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))） synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"},{"name":"线程安全","slug":"线程安全","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"}],"author":"Marlowe"},{"title":"ConcurrentHashMap 和 Hashtable 的区别","slug":"春招面试/ConcurrentHashMap-和-Hashtable-的区别","date":"2021-03-16T01:56:52.000Z","updated":"2021-03-16T12:11:10.042Z","comments":true,"path":"2021/03/16/春招面试/ConcurrentHashMap-和-Hashtable-的区别/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/16/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。","text":"ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 两者的对比图：HashTable: JDK1.7 的 ConcurrentHashMap： JDK1.8 的 ConcurrentHashMap：JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"},{"name":"线程安全","slug":"线程安全","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"}],"author":"Marlowe"},{"title":"HashMap 和 Hashtable 的区别","slug":"春招面试/HashMap-和-Hashtable-的区别","date":"2021-03-15T13:21:12.000Z","updated":"2021-03-15T14:35:59.037Z","comments":true,"path":"2021/03/15/春招面试/HashMap-和-Hashtable-的区别/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）； 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它； 对 Null key 和 Null value 的支持： HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。 初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 HashMap 中带有初始容量的构造函数： 12345678910111213141516public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。 12345678910111213/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"}],"author":"Marlowe"},{"title":"ArrayList和LinkedList的区别","slug":"春招面试/ArrayList和LinkedList的区别","date":"2021-03-15T06:23:58.000Z","updated":"2021-03-15T14:35:59.010Z","comments":true,"path":"2021/03/15/春招面试/ArrayList和LinkedList的区别/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Arraylist 与 LinkedList 区别? 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。） 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 参考Arraylist 与 LinkedList 区别?","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"List","slug":"List","permalink":"https://xmmarlowe.github.io/tags/List/"}],"author":"Marlowe"},{"title":"ArrayList扩容机制","slug":"春招面试/ArrayList扩容机制","date":"2021-03-15T06:23:43.000Z","updated":"2021-03-15T14:35:59.030Z","comments":true,"path":"2021/03/15/春招面试/ArrayList扩容机制/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/","excerpt":"","text":"1234567891、添加元素时，首先进行判断是否大于默认容量102、如果，小于默认容量，直接在原来基础上+1，元素添加完毕3、如果，大于默认容量，则需要进行扩容，扩容核心是grow()方法 3.1 扩容之前，首先创建一个新的数组，且旧数组被复制到新的数组中 这样就得到了一个全新的副本，我们在操作时就不会影响原来数组了 3.2 然后通过位运算符将新的容量更新为旧容量的 1.5 倍 3.3 如果新的容量比最小需要容量小，则最小需要容量为当前数组新容量， 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 grow()方法： 12345678910111213141516171819202122232425/** * 要分配的最大数组大小 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"List","slug":"List","permalink":"https://xmmarlowe.github.io/tags/List/"}],"author":"Marlowe"},{"title":"HashMap是线程安全的吗？","slug":"春招面试/HashMap是线程安全的吗？","date":"2021-03-15T06:23:22.000Z","updated":"2021-03-16T12:01:45.285Z","comments":true,"path":"2021/03/15/春招面试/HashMap是线程安全的吗？/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/","excerpt":"HashMap的线程不安全体现在会造成死循环、数据丢失、数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖这样的问题。","text":"HashMap的线程不安全体现在会造成死循环、数据丢失、数据覆盖这些问题。其中死循环和数据丢失是在JDK1.7中出现的问题，在JDK1.8中已经得到解决，然而1.8中仍会有数据覆盖这样的问题。 扩容引发的线程不安全HashMap的线程不安全主要是发生在扩容函数中，即根源是在transfer函数中，JDK1.7中HashMap的transfer函数如下： 123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; 这段代码是HashMap的扩容操作，重新定位每个桶的下标，并采用头插法将元素迁移到新数组中。头插法会将链表的顺序翻转，这也是形成死循环的关键点。 JDK1.8中的线程不安全根据上面JDK1.7出现的问题，在JDK1.8中已经得到了很好的解决，如果你去阅读1.8的源码会发现找不到transfer函数，因为JDK1.8直接在resize函数中完成了数据迁移。另外说一句，JDK1.8在进行元素插入时使用的是尾插法。 为什么说JDK1.8会出现数据覆盖的情况喃，我们来看一下下面这段JDK1.8中的put操作代码： 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果没有hash碰撞则直接插入元素 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 其中第六行代码是判断是否出现hash碰撞，假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。 除此之前，还有就是代码的第38行处有个++size，我们这样想，还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到第38行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时，线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。 总结HashMap的线程不安全主要体现在下面两个方面： 在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。 在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。 参考HashMap的实现原理，以及在JDK1.7和1.8的区别","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"}],"author":"Marlowe"},{"title":"HashMap底层原理","slug":"春招面试/HashMap底层原理","date":"2021-03-15T06:23:01.000Z","updated":"2021-03-16T02:14:19.317Z","comments":true,"path":"2021/03/15/春招面试/HashMap底层原理/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","excerpt":"","text":"JDK1.7数据结构则是采用的位桶和链表相结合的形式完成了，即拉链法。具体如下图所示： HashMap里面存储的是静态内部类Entry的对象，这个对象其实也是一个key-value的结构。 hash源码： 12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; JDK1.8相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 hash源码： 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 HashMap 的长度为什么是 2 的幂次方为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。 这个算法应该如何设计呢？ 我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"}],"author":"Marlowe"},{"title":"常见的IO模型有哪些？Java中的BIO，NIO，AIO的区别","slug":"春招面试/常见的IO模型有哪些？Java中的BIO，NIO，AIO的区别","date":"2021-03-15T06:22:22.000Z","updated":"2021-03-15T14:35:59.033Z","comments":true,"path":"2021/03/15/春招面试/常见的IO模型有哪些？Java中的BIO，NIO，AIO的区别/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9FJava%E4%B8%AD%E7%9A%84BIO%EF%BC%8CNIO%EF%BC%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。","text":"从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。 简介当应用程序发起I/O调用后，会经历两个步骤： 内核等待 I/O 设备准备好数据 内核将数据从内核空间拷贝到用户空间。 UNIX系统5种I/O模型： 同步阻塞 I/O 同步非阻塞 I/O I/O 多路复用 信号驱动 I/O 异步 I/O Java中三种常见的I/O模型BIO (Blocking I/O)BIO 属于同步阻塞 IO 模型 。 同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。 在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (Non-blocking/New I/O)Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。 Java 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。 同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。 但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。 这个时候，I/O 多路复用模型 就上场了。 IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。 IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。 Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。 AIO (Asynchronous I/O)AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。 异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。 最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。 参考京东数科二面:常见的10模型有哪些? Java中的BIO、NIO、 AIO有啥区别?","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"I/O模型","slug":"I-O模型","permalink":"https://xmmarlowe.github.io/tags/I-O%E6%A8%A1%E5%9E%8B/"}],"author":"Marlowe"},{"title":"JDK动态代理和CGLIB动态代理","slug":"春招面试/JDK动态代理和CGLIB动态代理","date":"2021-03-15T06:21:31.000Z","updated":"2021-03-17T07:39:58.775Z","comments":true,"path":"2021/03/15/春招面试/JDK动态代理和CGLIB动态代理/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"1、代理模式简介我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。 作用代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。 2、静态代理静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码_），非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。 上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 静态代理实现步骤: 定义一个接口及其实现类； 创建一个代理类同样实现这个接口 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。 见下面代码展示：1.定义发送短信的接口 123public interface SmsService &#123; String send(String message);&#125; 2.实现发送短信的接口 123456public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 3.创建代理类并同样实现发送短信的接口 123456789101112131415161718public class SmsProxy implements SmsService &#123; private final SmsService smsService; public SmsProxy(SmsService smsService) &#123; this.smsService = smsService; &#125; @Override public String send(String message) &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method send()&quot;); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method send()&quot;); return null; &#125;&#125; 4.实际使用 123456789101112131415161718public class SmsProxy implements SmsService &#123; private final SmsService smsService; public SmsProxy(SmsService smsService) &#123; this.smsService = smsService; &#125; @Override public String send(String message) &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method send()&quot;); smsService.send(message); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method send()&quot;); return null; &#125;&#125; 运行上述代码之后，控制台打印出： 123before method send()send message:javaafter method send() 通过输出结果看出，我们已经增加了SmsServiceImpl 的send()方法。 3、动态代理3.1、JDK动态代理机制3.1.1 介绍：在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。这个方法一共有 3 个参数： loader :类加载器，用于加载代理对象。 interfaces : 被代理类实现的一些接口。 h : 实现了 InvocationHandler 接口的对象。 要实现动态代理的话，还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。 也就是说：你通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情。 3.1.2 JDK 动态代理类使用步骤 定义一个接口及其实现类； 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象； 3.1.3 代码示例1.定义发送短信的接口 123public interface SmsService &#123; String send(String message);&#125; 2.实现发送短信的接口 123456public class SmsServiceImpl implements SmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 3.定义一个 JDK 动态代理类 12345678910111213141516171819202122232425import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class DebugInvocationHandler implements InvocationHandler &#123; /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) &#123; this.target = target; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object result = method.invoke(target, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return result; &#125;&#125; invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。4.获取代理对象的工厂类 123456789public class JdkProxyFactory &#123; public static Object getProxy(Object target) &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), // 目标类的类加载 target.getClass().getInterfaces(), // 代理需要实现的接口，可指定多个 new DebugInvocationHandler(target) // 代理对象对应的自定义 InvocationHandler ); &#125;&#125; getProxy() ：主要通过Proxy.newProxyInstance（）方法获取某个类的代理对象5.实际使用 12SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());smsService.send(&quot;java&quot;); 运行上述代码之后，控制台打印出： 123before method sendsend message:javaafter method send 3.2、CGLIB 动态代理机制3.2.1 介绍JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。 为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。 CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。 在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。 你需要自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法。 123456public interface MethodInterceptorextends Callback&#123; // 拦截被代理类中的方法 public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable;&#125; obj :被代理的对象（需要增强的对象） method :被拦截的方法（需要增强的方法） args :方法入参 methodProxy :用于调用原始方法 你可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法。 3.2.2 CGLIB 动态代理类使用步骤 定义一个类； 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 通过 Enhancer 类的 create()创建代理类 3.2.3 代码示例不同于 JDK 动态代理不需要额外的依赖。CGLIB(Code Generation Library) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 1.实现一个使用阿里云发送短信的类 12345678package github.javaguide.dynamicProxy.cglibDynamicProxy;public class AliSmsService &#123; public String send(String message) &#123; System.out.println(&quot;send message:&quot; + message); return message; &#125;&#125; 2.自定义 MethodInterceptor（方法拦截器） 12345678910111213141516171819202122232425262728import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 自定义MethodInterceptor */public class DebugMethodInterceptor implements MethodInterceptor &#123; /** * @param o 被代理的对象（需要增强的对象） * @param method 被拦截的方法（需要增强的方法） * @param args 方法入参 * @param methodProxy 用于调用原始方法 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; //调用方法之前，我们可以添加自己的操作 System.out.println(&quot;before method &quot; + method.getName()); Object object = methodProxy.invokeSuper(o, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(&quot;after method &quot; + method.getName()); return object; &#125;&#125; 3.获取代理类import net.sf.cglib.proxy.Enhancer; public class CglibProxyFactory { public static Object getProxy(Class&lt;?&gt; clazz) &#123; // 创建动态代理增强类 Enhancer enhancer = new Enhancer(); // 设置类加载器 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new DebugMethodInterceptor()); // 创建代理类 return enhancer.create(); &#125; } 12345```**4.实际使用**```javaAliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);aliSmsService.send(&quot;java&quot;); 运行上述代码之后，控制台打印出： 123before method sendsend message:javaafter method send 3.3 JDK 动态代理和 CGLIB 动态代理对比 JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。 静态代理和动态代理的对比 灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 参考代理模式详解","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"https://xmmarlowe.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"JDK","slug":"JDK","permalink":"https://xmmarlowe.github.io/tags/JDK/"}],"author":"Marlowe"},{"title":"代理模式之静态代理和动态代理","slug":"春招面试/代理模式之静态代理和动态代理","date":"2021-03-15T06:20:34.000Z","updated":"2021-03-16T01:57:29.483Z","comments":true,"path":"2021/03/15/春招面试/代理模式之静态代理和动态代理/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/15/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[],"author":"Marlowe"},{"title":"final,static,this,super关键字总结","slug":"春招面试/final-static-this-super关键字总结","date":"2021-03-13T07:55:17.000Z","updated":"2021-03-15T06:20:56.208Z","comments":true,"path":"2021/03/13/春招面试/final-static-this-super关键字总结/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/final-static-this-super%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/","excerpt":"","text":"final 关键字final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点： final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法； final修饰的方法不能被重写； final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。 说明： 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 static 关键字static 关键字主要有以下四种使用场景： 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次. 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 this 关键字this关键字用于引用类的当前实例。例如： 1234567891011class Manager &#123; Employees[] employees; void manageEmployees() &#123; int totalEmp = this.employees.length; System.out.println(&quot;Total employees: &quot; + totalEmp); this.report(); &#125; void report() &#123; &#125;&#125; 在上述代码中，this关键字运用于两个地方: this.employees.length：访问Manager的当前实例的变量。 this.report（）：调用类Manager的当前实例的方法。此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。super 关键字 使用 this 和 super 要注意的问题： 在构造器中使用 super() 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。 简单解释一下： 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。 参考final,static,this,super 关键字总结","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"关键字","slug":"关键字","permalink":"https://xmmarlowe.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"}],"author":"Marlowe"},{"title":"Arrays.asList()使用指南","slug":"春招面试/Arrays-asList-使用指南","date":"2021-03-13T02:40:40.000Z","updated":"2021-03-15T06:21:03.042Z","comments":true,"path":"2021/03/13/春招面试/Arrays-asList-使用指南/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/13/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Arrays-asList-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","excerpt":"Arrays.asList()将数组转换为集合后,底层其实还是数组","text":"Arrays.asList()将数组转换为集合后,底层其实还是数组 1234567891011public class Test1 &#123; public static void main(String[] args) &#123; String[] str = new String[]&#123;&quot;111&quot;, &quot;222&quot;&#125;; List&lt;String&gt; list = Arrays.asList(str); list.add(&quot;333&quot;); list.forEach(a-&gt;&#123; System.out.println(a); &#125;); &#125;&#125; 12345运行报错：Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) at test.Test1.main(Test1.java:16) 使用注意事项传递的数组必须是对象数组，而不是基本类型 1234567int[] myArray = &#123;1, 2, 3&#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//1System.out.println(myList.get(0));//数组地址值System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException: 1int[] array = (int[]) myList.get(0);System.out.println(array[0]);//1 当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。 我们使用包装类型数组就可以解决这个问题。 12345Integer[] myArray = &#123;1, 2, 3&#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size());//3System.out.println(myList.get(0));//1System.out.println(myList.get(1));//2 使用集合的修改方法:add()、remove()、clear()会抛出异常。 1234List myList = Arrays.asList(1, 2, 3);myList.add(4);//运行时报错：UnsupportedOperationExceptionmyList.remove(1);//运行时报错：UnsupportedOperationExceptionmyList.clear();//运行时报错：UnsupportedOperationException Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。 12List myList = Arrays.asList(1, 2, 3);System.out.println(myList.getClass());//class java.util.Arrays$ArrayList 查看remove() 方法，可以知道为啥抛出UnsupportedOperationException。 123public E remove(int index) &#123; throw new UnsupportedOperationException();&#125; 如何正确的将数组转换为ArrayList？1、最简便的方法1List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 2、使用Java8的Stream12345Integer [] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());//基本类型也可以实现转换（依赖boxed的装箱操作）int [] myArray2 = &#123; 1, 2, 3 &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); 参考Arrays.asList()使用指南","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Arrays","slug":"Arrays","permalink":"https://xmmarlowe.github.io/tags/Arrays/"}],"author":"Marlowe"},{"title":"Spring是什么？","slug":"春招面试/Spring是什么？","date":"2021-03-11T07:42:30.000Z","updated":"2021-03-23T02:06:36.067Z","comments":true,"path":"2021/03/11/春招面试/Spring是什么？/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/11/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"轻量级的开源的J2EE框架。它是一个容器框架，用来装JavaBean，也是一个中间层框架，可以起连接作用。","text":"轻量级的开源的J2EE框架。它是一个容器框架，用来装JavaBean，也是一个中间层框架，可以起连接作用。 Spring是什么？Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架。 1、Spring的核心是一个轻量级（Lightweight）的容器（Container）。2、Spring是实现IoC（Inversion of Control）容器和非入侵性（No intrusive）的框架。3、Spring提供AOP（Aspect-oriented programming）概念的实现方式。4、Spring提供对持久层（Persistence）、事物（Transcation）的支持。5、Spring供MVC Web框架的实现，并对一些常用的企业服务API（Application Interface）提供一致的模型封装。6、Spring提供了对现存的各种框架（Structs、JSF、Hibernate、Ibatis、Webwork等）相整合的方案。总之，Spring是一个全方位的应用程序框架。 对AOP的理解AOP:将程序中的交叉业务逻辑(比如安全，日志，事务等)，封装成一个切面,然后注入到目标对象(具体业务逻辑)中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情。 对IoC的理解IOC:控制反转也叫依赖注入，IOC利用java反射机制，所谓控制反转是指，本来被调用者的实例是由调用者来创建的，这样的缺点是耦合性太强，IOC则是统一交给spring来管理创建，将对象交给容器管理，你只需要在spring配置文件中配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。 控制反转:没有引入IOC容器之前，对象A依赖于对象B,那么对象A在初始化或者运行到某一点的时候， 自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B,控制权都在自己手上。 引入IOC容器之后,对象A与对象B之间失去了直接联系,当对象A运行到需要对象B的时候，IOC容器 会主动创建一个对象B注入到对象A需要的地方。 通过前后的对比，不难看出来:对象A获得依赖对象B的过程,由主动行为变为了被动行为,控制权颠倒过来，这就是”控制反转”这个名称的由来。 全部对象的控制权全部上缴给”第三方”IOC容器,所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个”粘合剂”，对象与对象之间会彼此失去联系,这就是有人把IOC容器比喻成”粘合剂”的由来。 依赖注入:“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法,就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/tags/Spring/"}],"author":"Marlowe"},{"title":"线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?线程池中线程复用原理","slug":"并发/线程池中阻塞队列的作用-为什么是先添加列队而不是先创建最大线程-线程池中线程复用原理","date":"2021-03-11T06:35:10.000Z","updated":"2021-03-19T12:59:32.022Z","comments":true,"path":"2021/03/11/并发/线程池中阻塞队列的作用-为什么是先添加列队而不是先创建最大线程-线程池中线程复用原理/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/11/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%88%E6%B7%BB%E5%8A%A0%E5%88%97%E9%98%9F%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%88%E5%88%9B%E5%BB%BA%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"线程池中阻塞队列的作用?一般的队列只能保证作为一个有限长度的缓冲区,如果超出了缓冲长度,就无法保留当前的任务了,阻塞队列通过阻塞可以保留住当前想要继续入队的任务。阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程,使得线程进入wait状态,释放cpu资源。阻塞队列自带阻塞和唤醒的功能,不需要额外处理,无任务执行时,线程池利用阻塞队列的take方法挂起,从而维持核心线程的存活、不至于一直占用cpu资源 为什么是先添加列队而不是先创建最大线程?在创建新线程的时候,是要获取全局锁的,这个时候其它的就得阻塞,影响了整体效率。 就好比一个饭店里面有10个(core)正式工的名额,最多招10个正式工,要是任务超过正式工人数(task&gt;core)的情况下,工厂领导(线程池)不是首先扩招工人,还是这10人,但是任务可以稍微积压一下,即先放到队列去(代价低) 。10个正式工慢慢干,迟早会千完的,要是任务还在继续增加,超过正式工的加班忍耐极限了(队列满了) ,就的招外包帮忙了(注意是临时工)要是正式工加上外包还是不能完成任务,那新来的任务就会被领导拒绝了(线程池的拒绝策略) 线程池中线程复用原理线程池将线程和任务进行解耦,线程是线程,任务是任务,摆脱了之前通过Thread创建线程时的一个线程必须对应一个任务的限制。 在线程池中,同一个线程可以从阻塞队列中不断获取新任务来执行,其核心原理在于线程池对Thread进行了封装,并不是每次执行任务都会调用Thread.start（)来创建新线程,而是让每个线程去执行一个”循环任务”,在这个”循环任务”中不停检查是否有任务需要被执行,如果有则直接执行,也就是调用任务中的run方法,将run方法当成一个普通的方法执行,通过这种方式只使用固定的线程就将所有任务的run方法串联起来。 参考线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?线程池中线程复用原理","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"为什么用线程池？线程池参数解释","slug":"并发/为什么用线程池？线程池参数解释","date":"2021-03-11T02:26:10.000Z","updated":"2021-03-19T12:59:25.220Z","comments":true,"path":"2021/03/11/并发/为什么用线程池？线程池参数解释/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/11/%E5%B9%B6%E5%8F%91/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/","excerpt":"","text":"为什么使用线程池? 1、降低资源消耗;提高线程利用率,降低创建和销毁线程的消耗。 2、提高响应速度;任务来了,直接有线程可用可执行,而不是先创建线程,再执行。 3、提高线程的可管理性;线程是稀缺资源,使用线程池可以统一分配调优监控。 corePoolsize代表核心线程数,也就是正常情况下创建工作的线程数,这些线程创建后并不会消除,而是一种常驻线程 maxinumPoolsize代表的是最大线程数,它与核心线程数相对应,表示最大允许被创建的线程数,比如当前任务较多,将核心线程数都用完了,还无法满足需求时,此时就会创建新的线程,但是线程池内线程总数不会超过最大线程数 keepAliverime, unit表示超出核心线程数之外的线程的空闲存活时间,也就是核心线程不会消除,但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过setKeepAliveTime来设置空闲时间 workQueue用来存放待执行的任务,假设我们现在核心线程都已被使用,还有任务进来则全部放入队列,直到整个队列被放满但任务还再持续进入则会开始创建新的线程 ThreadFactory实际上是一个线程工厂,用来生产线程执行任务。我们可以选择使用默认的创建工厂,产生的线程都在同一个组内,拥有相同的优先级,且都不是守护线程。当然我们也可以选择自定义线程工厂,一般我们会根据业务来制定不同的线程工厂 Handler任务拒绝策略,有两种情况,第一种是当我们调用shutdown等方法关闭线程池后,这时候即使线程池内部还有没执行完的任务正在执行,但是由于线程池已经关闭,我们再继续想线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数,线程池已经没有能力继续处理新提交的任务时,这时也就拒绝 执行线程池的流程线程池任务开始执行时，会先判断线程池是否已满，如果没有满则创建核心线程执行，如果核心线程已满那么就判断任务队列是否已满，未满则将任务放入到队列中，如果已满则判断最大线程数是否打到，未达到则创建临时线程执行，临时吸线程如果空闲时我们可以设置超时时间也就是KeepAliveTime，当达到超时时间临时线程则被回收。如果全部线程空间都满了那么我们可设置拒绝策略来处理。 参考文档为什么要用线程池，线程池的参数解释","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"并发的三大特性","slug":"并发/并发的三大特性","date":"2021-03-11T00:31:23.000Z","updated":"2021-03-19T12:59:14.699Z","comments":true,"path":"2021/03/11/并发/并发的三大特性/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/11/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"原子性定义：原子性是指在一个操作中cpu不可以在中途暂停然后再调度,即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作:从账户A减去1000元,往账户B加上1000元。2个操作必须全部完成。 关键字：synchronized 1234private long count = 0;public void calc()&#123; count++;&#125; 在上述代码中，将执行以下步骤： 将count从主存读取到工作内存中的副本 +1运算 将结果写入工作内存 将工作内存中的值刷回主存(什么时候刷入由操作系统决定，不确定的) 可见性定义：当一个线程修改了共享变量的值，其他线程会马上知道这个修改。当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从缓存中读取。 关键字：volatile、synchronized、final 有序性定义：虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题。 1234567891011121314int a = 0;boolean flag = false;public void write()&#123; a = 2; //1 //1 flag = true; //2 //4&#125; public void multiply()&#123; if(flag)&#123; //3 //2 int res = a * a; //4 //3 &#125; &#125; 1234567如果按照1234执行，结果为：a = 2;res = 4;如果按照1423执行，结果为：a = 2;res = 0; 关键字：volatile、synchronized volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则明确的。 小结： synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。 在某些情况下，volatile的同步机制的性能确实要优于锁(使用synchronized关键字或java.util.concurrent包里面的锁)，因为volatile的总开销要比锁低。 我们判断使用volatile还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性) 参考文档高并发的三大特性—原子性、有序性、可见性","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/tags/%E5%B9%B6%E5%8F%91/"}],"author":"Marlowe"},{"title":"ThreadLocal原理和使用场景","slug":"并发/ThreadLocal原理和使用场景","date":"2021-03-10T07:31:01.000Z","updated":"2021-03-19T12:59:41.939Z","comments":true,"path":"2021/03/10/并发/ThreadLocal原理和使用场景/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/10/%E5%B9%B6%E5%8F%91/ThreadLocal%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals,它存储本线程中所有ThreadLocal对象及其对应的值。","text":"每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals,它存储本线程中所有ThreadLocal对象及其对应的值。 简介：ThreadLocal保存当前线程的变量，当前线程内，可以任意获取，但每个线程往ThreadLocal中读写数据是线程隔离，互不影响。 1234567891011ThreadLocalMap源码：static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ThreadLocalMap由一个个Entry对象构成Entry继承自WeakReference&lt;ThreadLoca1&lt;?&gt;&gt;,一个Entry由ThreadLocal对象和Object构成。由此可见，Entry 的key是ThreadLocal对象,并且是一个弱引用。 当没指向key的强引用后, 该key就会被垃圾收集器回收。 注意 ThreadLocal存在内存泄露： 强引用(StrongReference)： 使用最普遍的引用(new),一个对象具有强引用，不会被GC回收。当JVM的内存空间不足时，宁愿抛出OutOfMemoryError使得程序异常终止也不愿意回收具有强引用的存活着的对象。如果想取消强引用和某个对象之间的关联，可以显式的将引用赋值为null，这样可以是JVM在合适的时候回收该对象。 弱引⽤(WeakReference)：在GC的时候，不管内存空间足不足都会回收这个对象。可以在缓存中使用弱引用。 当我们了解完，ThreadLocalMap 中使⽤的 key是以弱引用指向ThreadLocal，这时候垃圾回收器线程运行，发现弱引用就回收，key被回收。ThreadLocalMap里对应的Entry的key会变成null。这时候尴尬出现了，ThreadLocalMap里对应的Entry的value则无法被访问到，value作为一个强引用垃圾回收不到也不能被访问，即造成了内存溢出。 ThreadLocal正确的使用方法 在使用完ThreadLocal后，主动调用remove方法进行清理。 将ThreadLocal变量定义成private static, 这样就一 直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值， 进而清除掉。 123456789ThreadLocal set()方法public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key,将值存储进ThreadLocalMap对象中。 1234567891011121314ThreadLocal get()方法public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; get方法执行过程类似。ThreadLocal首先会获取当前线程对象,然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key,获取对应的value。 由于每一条线程均含有各自私有的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。 使用场景：1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。2、线程间数据隔离。3、进行事务操作，用于存储线程事务信息。4、数据库连接，Session会话管理。","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"浅谈对守护线程的理解","slug":"并发/浅谈对守护线程的理解","date":"2021-03-10T07:13:51.000Z","updated":"2021-03-19T12:59:19.012Z","comments":true,"path":"2021/03/10/并发/浅谈对守护线程的理解/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/10/%E5%B9%B6%E5%8F%91/%E6%B5%85%E8%B0%88%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"为所有非守护线程提供服务的线程，也称后台线程，任何一个守护线程都是整个JVM中所有非守护线程的保姆。","text":"为所有非守护线程提供服务的线程，也称后台线程，任何一个守护线程都是整个JVM中所有非守护线程的保姆。 守护线程的作用：举例，GC垃圾回收线程:就是一个经典的守护线程, 当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做,所以当垃圾回收线程是JVM.上仅剩的线程时,垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 （守护线程必须在线程开启前设置！）thread.setDaemon(true)必须在thread.start()之前设置,否则会抛出一个llegalThreadStateException异常。 你不能把正在运行的常规线程设置为守护线程。 在守护(deamon)线程中产生的新线程也是守护线程","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"浅谈对线程安全的理解","slug":"并发/浅谈对线程安全的理解","date":"2021-03-10T06:46:58.000Z","updated":"2021-03-19T12:59:22.085Z","comments":true,"path":"2021/03/10/并发/浅谈对线程安全的理解/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/10/%E5%B9%B6%E5%8F%91/%E6%B5%85%E8%B0%88%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"当多个线程访问一个对象时，如果不进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。","text":"当多个线程访问一个对象时，如果不进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。 简单来说，多线程情况下和单线程执行结果一样，就是线程安全的。 堆是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆,但是用完了要还给操作系统，要不然就是内存泄漏。 在Java中，堆是Java虚拟机所管理的内存中最大的一块,是所有线程共享的一块内存区域，在虚拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例， 几乎所有的对象实例以及数组都在这里分配内存。 栈是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立,因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"sleep(),wait(),join(),yield()的区别","slug":"春招面试/sleep-wait-join-yield-的区别","date":"2021-03-09T09:12:15.000Z","updated":"2021-03-10T14:29:28.636Z","comments":true,"path":"2021/03/09/春招面试/sleep-wait-join-yield-的区别/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/sleep-wait-join-yield-%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"锁池所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。 等待池当我们调用wait()方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify()或notifyAll()后等待的线程才会开始去竞争锁，notify()是随机从等待池中选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中。 sleep是Thread类的静态本地方法，wait是Object类的本地方法。 sleep方法不会释放lock，但wait会释放，而且会加入到等待队列中。1sleep就是把cpu的执行资格和执行权释放出去，不在运行此线程，当定时时间结束后再取回cpu资源，参与cpu的调度，获取到cpu资源后就可以继续运行了。而如果sleep时线程有所，那么sleep不会释放这个锁，而是把锁带着进入了冻结状态，也就是说其他需要这个锁的线程根本不可能获取到这个锁。也即无法执行程序。如果在睡眠期间其他线程调用了这个线程的interrupt方法，那么这个线程也会抛出interruptexception异常返回，这个点和wait是一样的。 sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。 sleep不需要被唤醒(休眠之后退出阻塞),但是wait需要(不指定时间需要被别人中断)。 sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信。 sleep会放出cpu执行时间且强制上下文切换，而wait则不一定，wait后可能还是有机会重新竞争到锁继续执行的。 yield() 执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行。 join() 执行后线程进入阻塞状态，例如在线程B中调用线程A的join()，则线程B会进入到阻塞队列，直到线程A结束或中断线程。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;222222&quot;); &#125; &#125;); t1.start(); t1.join(); // 这行代码需等t1线程执行结束才会继续执行 System.out.println(&quot;11111&quot;); &#125; 123结果：22222211111","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"线程的生命周期包括哪几个阶段","slug":"并发/线程的生命周期包括哪几个阶段","date":"2021-03-09T08:49:03.000Z","updated":"2021-03-19T12:59:33.916Z","comments":true,"path":"2021/03/09/并发/线程的生命周期包括哪几个阶段/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/09/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%85%E6%8B%AC%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5/","excerpt":"线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。","text":"线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。 新建（New）：就是刚使用new方法，new出来的线程。 就绪（Runnable）：就是调用的线程的start()方法。该状态的线程位于可运行线程池中，等待获取CPU的使用权。 运行（Running）：当就绪的线程被调度并获得CPU资源时，便进入运行状态。 阻塞（Blocked）：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态。 销毁（Dead）：线程执行完了或者因异常退出了run方法，该线程结束生命周期。","categories":[{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"GC如何判断对象可以被回收","slug":"春招面试/GC如何判断对象可以被回收","date":"2021-03-09T08:26:44.000Z","updated":"2021-03-10T14:29:28.603Z","comments":true,"path":"2021/03/09/春招面试/GC如何判断对象可以被回收/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6/","excerpt":"","text":"引用计数法方式：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。优点：实现简单，效率高。缺点：无法解决循环引用。 可达性分析法方式：从一系列被称为GC ROOT的对象开始，向下搜索，搜索走过的路径称为引用链，当一个对象到GC ROOT之间没有引用链，说明这个对象不可用。 GC ROOT对象： 虚拟机栈中引用的对象 方法区内类的静态属性引用的对象 方法区常量引用的对象 本地方法栈中引用的对象 finalize()当一个对象被判定为不可达对象后，也并不是非死不可。在通过可达性分析算法判断没有引用链使之与GC ROOT相连，会判断该对象是否有必要执行finalize方法:假如重写了finalize，并且未调用过，则说明有必要执行。 判断有必要执行finalize的对象，会被放入一个队列，有jvm建立的低优先级的Finalizer线程去执行。 当在finalize中自救成功的对象，就会在第二次标记时移除即将回收的集合。自救失败的就会被回收，不会再执行finalize。 所谓自救就是把自己与引用链上的一个对象关联起来。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://xmmarlowe.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://xmmarlowe.github.io/tags/GC/"}],"author":"Marlowe"},{"title":"Java中的异常体系","slug":"春招面试/Java中的异常体系","date":"2021-03-09T07:58:09.000Z","updated":"2021-03-10T14:29:28.607Z","comments":true,"path":"2021/03/09/春招面试/Java中的异常体系/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","excerpt":"","text":"所有异常类都是Throwable的子类 异常可分为Error(错误)和Exception(异常)两类 Exception又可分为RuntimeException(运行时异常)和非运行时异常两类 Error是程序无法处理的错误，一旦出现这个错误，则程序被迫停止运行。 Exception不会导致程序停止，分为RuntimeException运行时异常和CheckedException检查异常。 RuntimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"异常","slug":"异常","permalink":"https://xmmarlowe.github.io/tags/%E5%BC%82%E5%B8%B8/"}],"author":"Marlowe"},{"title":"Java类加载机制和类加载器概述","slug":"Java/Java类加载机制和类加载器概述","date":"2021-03-09T05:44:40.000Z","updated":"2021-04-09T06:53:21.705Z","comments":true,"path":"2021/03/09/Java/Java类加载机制和类加载器概述/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/09/Java/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%A6%82%E8%BF%B0/","excerpt":"当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时候也把这3个步骤统称为类加载或类初始化。","text":"当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时候也把这3个步骤统称为类加载或类初始化。 一、类加载过程1. 加载加载指的是将类的Class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。 2. 链接当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。 3. 初始化初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 二、类加载时机 创建类的实例，也即new一个对象 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（Class.forName(“com.lyj.load”)） 初始化一个类的子类（会首先初始化子类的父类） JVM启动时标明的启动类，即文件名和类名相同的那个类 除此之外，下面几种情形需要特别指出： 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。 三、类加载器 根类加载器（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展类加载器（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。 系统类加载器（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。 四、类加载机制 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。 双亲委派机制 工作原理双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 优势采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。 好处 主要是为了安全性，避免用户自己编写的类动态替换Java的一些核心类，比如String，Integer。 同时避免了类的重新加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类。 不想用双亲委派模型怎么办？自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法 五、参考文档jvm之java类加载机制和类加载器(ClassLoader)的详解","categories":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://xmmarlowe.github.io/tags/JVM/"}],"author":"Marlowe"},{"title":"什么是字节码？采用字节码的好处是什么？","slug":"春招面试/什么是字节码？采用字节码的好处是什么？","date":"2021-03-09T02:43:58.000Z","updated":"2021-03-10T14:29:28.660Z","comments":true,"path":"2021/03/09/春招面试/什么是字节码？采用字节码的好处是什么？/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/09/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"字节码：在Java中，供虚拟机理解的代码叫做字节码(也就是Java代码编译后的.class文件),他不面向任何特定的处理器，只面向虚拟机。","text":"字节码：在Java中，供虚拟机理解的代码叫做字节码(也就是Java代码编译后的.class文件),他不面向任何特定的处理器，只面向虚拟机。 Java中的编译器和解释器Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。 采用字节码的好处Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。","categories":[{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"}],"tags":[],"author":"Marlowe"},{"title":"JWTUtils","slug":"自定义工具类/JWTUtils","date":"2021-03-02T06:36:50.000Z","updated":"2021-03-02T06:45:38.286Z","comments":true,"path":"2021/03/02/自定义工具类/JWTUtils/","link":"","permalink":"https://xmmarlowe.github.io/2021/03/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/JWTUtils/","excerpt":"Jwt 学习","text":"Jwt 学习 引入jwt依赖12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 编写JWTUtils工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JWTUtils &#123; private static final String SIGN = &quot;!QDJHFKSHFK:&quot;; /** * 生成token header.payload.sign * * @param map * @return */ public static String getToken(Map&lt;String, String&gt; map) &#123; Calendar instance = Calendar.getInstance(); // 默认7天过期 instance.add(Calendar.DATE, 7); // 创建jwt builder JWTCreator.Builder builder = JWT.create(); // payload map.forEach((k, v) -&gt; &#123; builder.withClaim(k, v); &#125;); // 指定令牌过期时间和签名 String token = builder.withExpiresAt(instance.getTime()) .sign(Algorithm.HMAC256(SIGN)); return token; &#125; /** * 验证token 合法性 * * @param token */ public static void verify(String token) &#123; JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token); &#125; /** * 获取token信息 * * @param token * @return */ public static DecodedJWT getTokenInfo(String token) &#123; DecodedJWT verify = JWT.require(Algorithm.HMAC256(SIGN)).build().verify(token); return verify; &#125;&#125; 编写JWTinterceptor类12345678910111213141516171819202122232425262728293031public class JWTInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); // 获取请求头令牌 String token = request.getHeader(&quot;token&quot;); try &#123; // 验证令牌 JWTUtils.verify(token); // 放行请求 return true; &#125; catch (SignatureVerificationException e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;无效签名&quot;); &#125; catch (TokenExpiredException e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;token过期&quot;); &#125; catch (AlgorithmMismatchException e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;token算法不一致&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;msg&quot;, &quot;token 无效&quot;); &#125; map.put(&quot;state&quot;, false); String json = new ObjectMapper().writeValueAsString(map); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().println(json); return false; &#125;&#125; 编写拦截器配置类123456789@Configurationpublic class InterceptorConfig implements WebMvcConfigurer&#123; @Override public vpid addInterceptors(InterceptorRegistry registry)&#123; registry.addInterceptor(new JWTInterceptor()) .addPathPatterns(&quot;/xxx&quot;) .excludePathPatterns(&quot;/xxx&quot;); &#125;&#125;","categories":[{"name":"自定义工具类","slug":"自定义工具类","permalink":"https://xmmarlowe.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://xmmarlowe.github.io/tags/JWT/"}],"author":"Marlowe"},{"title":"常用的辅助类","slug":"JUC/常用的辅助类","date":"2020-12-26T17:13:41.000Z","updated":"2021-03-09T07:58:25.123Z","comments":true,"path":"2020/12/27/JUC/常用的辅助类/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/27/JUC/%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB/","excerpt":"","text":"countDownLatch12345678910111213141516public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot; Go out&quot;); countDownLatch.countDown(); &#125;, String.valueOf(i)).start(); &#125; // 等待计数器归零，然后再向下执行 countDownLatch.await(); System.out.println(&quot;close door&quot;); &#125;&#125; 原理：countDownLatch.countDown(); // 数量-1countDownLatch.await(); // 等待计数器归零，然后向下执行每次有线程调用countDown(),数量减一，假设计数器变为0,countDownLatch.await();就会被唤醒，继续执行！ CyclicBarrierdemo: 123456789101112131415161718192021public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙成功！&quot;); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; final int temp = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;收集了&quot; + temp + &quot;个龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 结果 12345678Thread-1收集了2个龙珠Thread-2收集了3个龙珠Thread-0收集了1个龙珠Thread-3收集了4个龙珠Thread-4收集了5个龙珠Thread-5收集了6个龙珠Thread-6收集了7个龙珠召唤神龙成功！ SemaphoreSemaphore：信号量 123456789101112131415161718192021public class SemaphoreDemo &#123; public static void main(String[] args) &#123; // 线程数量，停车位，限流 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 原理：semaphore.acquire() // 获得，假设已经满了，等待，等待被释放为止semaphore.release() // 释放，会将当前的信号量释放 + 1，然后唤醒等待线程！作用：多个共享资源互斥使用，开发限流！","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"辅助类","slug":"辅助类","permalink":"https://xmmarlowe.github.io/tags/%E8%BE%85%E5%8A%A9%E7%B1%BB/"}],"author":"Marlowe"},{"title":"Callable","slug":"JUC/Callable","date":"2020-12-26T12:29:25.000Z","updated":"2020-12-28T01:28:39.878Z","comments":true,"path":"2020/12/26/JUC/Callable/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/26/JUC/Callable/","excerpt":"","text":"Callable简介： 可以有返回值 可以抛出异常 方法不同，Runnable 是 run()， Callable 是call() 1234567891011121314151617181920212223242526public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyThread thread = new MyThread(); // 适配类 FutureTask futureTask = new FutureTask(thread); new Thread(futureTask, &quot;A&quot;).start(); new Thread(futureTask, &quot;B&quot;).start(); // get方法可能会产生阻塞 Integer s = (Integer) futureTask.get(); System.out.println(s); &#125;&#125;class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(&quot;call()&quot;); // 耗时的操作 return 1024; &#125;&#125; 注意： 有缓存 结果可能需要等待，会阻塞！","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"Callable","slug":"Callable","permalink":"https://xmmarlowe.github.io/tags/Callable/"}],"author":"Marlowe"},{"title":"Redis 发布与订阅","slug":"NoSQL/Redis-发布与订阅","date":"2020-12-25T03:59:32.000Z","updated":"2020-12-25T04:00:13.281Z","comments":true,"path":"2020/12/25/NoSQL/Redis-发布与订阅/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/25/NoSQL/Redis-%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/","excerpt":"","text":"Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接受消息。微博、微信、关注系统！Redis客户端可以订阅任意数量的频道。订阅/发布消息图：第一个：消息发送者，第二个：频道，第三个：消息订阅者使用场景 实时消息系统 实时聊天(频道当做聊天室，将信息回显给所有人即可) 订阅，关注系统 稍微复杂的场景就会使用消息中间件MQ","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"}],"author":"Marlowe"},{"title":"Redis 缓存穿透与雪崩(面试高频)","slug":"NoSQL/Redis-缓存穿透与雪崩-面试高频","date":"2020-12-24T09:07:26.000Z","updated":"2020-12-24T19:48:15.612Z","comments":true,"path":"2020/12/24/NoSQL/Redis-缓存穿透与雪崩-面试高频/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/24/NoSQL/Redis-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E9%9B%AA%E5%B4%A9-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/","excerpt":"","text":"","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"}],"author":"Marlowe"},{"title":"Redis 持久化","slug":"NoSQL/Redis-持久化","date":"2020-12-24T03:28:46.000Z","updated":"2020-12-24T07:42:41.845Z","comments":true,"path":"2020/12/24/NoSQL/Redis-持久化/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/24/NoSQL/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能！","text":"Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以Redis提供了持久化功能！ RDB(Redis DataBase)简介：在指定的时间间隔内将内存中的数据集写入磁盘，也就是行话讲的Snapshot快照，它恢复时时将快照文件直接读到内存里。Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ 在生产环境我们会将这个文件进行备份！ rdb保存的文件是dump.rdb 都是在配置文件中 快照中进行配置的！触发机制 save的规则满足情况下，会自动触发rdb规则 执行flushall命令，也会触发我们的rdb规则！ 退出redis，也会产生rdb文件备份就自动生成一个dump.rdb 如何恢复rdb文件？ 只需将rdb文件放在redis启动目录就可以，redis启动的时候就会自动检查dump.rdb，并恢复其中的数据。 查看需要存放的位置123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;D:\\\\Program Files\\\\redis-2.8.9&quot; 优点： 适合大规模的数据恢复！ 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了！ fork进程的时候，会占用一定的内存空间！ AOF(Append Only File)简介将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍！以日志的形式来记录每个读写操作，将Redis执行过的所有指令记录下来(读操作不记录),只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据,换言之，redis重启的话就根据日志文件的内容将写指令从前往后执行一次以完成数据的恢复工作Aof保存的是appendonly.aof文件 默认是不开启的，需要手动进行配置，只需要将appendonly改为yes就可以开启aof！ 重启redis就可以生效如果这个aof文件有错，redis将无法启动，需要修复这个aof文件redis提供了一个工具 redis-check-aof --fix如果文件正常，重启就可以直接恢复了！ 重写规则说明：aof默认就是文件的无限追加，文件会越来越大!如果aof文件大于64m，太大了，会fork一个新的进程来将文件重写！ 优点： 每一次修改都同步，文件的完整性会更加好！ 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点： 相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢 Aof运行效率比rdb慢，所以redis默认的配置就是rdb持久化","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://xmmarlowe.github.io/tags/redis/"}],"author":"Marlowe"},{"title":"SpringBoot整合Redis","slug":"NoSQL/SpringBoot整合Redis","date":"2020-12-23T13:59:54.000Z","updated":"2020-12-24T02:14:15.077Z","comments":true,"path":"2020/12/23/NoSQL/SpringBoot整合Redis/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/23/NoSQL/SpringBoot%E6%95%B4%E5%90%88Redis/","excerpt":"","text":"说明：SpringBoot2.x之后，原来使用jedis被替换为了lettucejedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用jedis pool连接池！ 更像BIO模式lettuce：采用netty，示例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式原码分析： 12345678910111213141516171819@Bean@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)// 我们可以自定义一个redisTemplate来替换这个默认的！@ConditionalOnSingleCandidate(RedisConnectionFactory.class)public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; // 默认的RedisTemplate没有过多的设置，redis对象都是需要序列化！ // 两个泛型都是Object，Object的类型，我们使用需要强制转换&lt;String,Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); return template;&#125;@Bean@ConditionalOnMissingBean // 由于tring是redis中最常使用的类型，所以单独提取出来了一个bean！@ConditionalOnSingleCandidate(RedisConnectionFactory.class)public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template;&#125; 整合测试 导入依赖12345&lt;!--操作redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置连接12spring.redis.host=127.0.0.1spring.redis.port=6379 测试12345678910@Testvoid contextLoads() &#123; // 获取redis的连接对象 // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(&quot;mykey&quot;, &quot;kuangshen&quot;); System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));&#125;","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xmmarlowe.github.io/tags/SpringBoot/"},{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"}],"author":"Marlowe"},{"title":"Jedis","slug":"NoSQL/Jedis","date":"2020-12-23T13:19:43.000Z","updated":"2020-12-24T02:14:15.073Z","comments":true,"path":"2020/12/23/NoSQL/Jedis/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/23/NoSQL/Jedis/","excerpt":"…","text":"… 简介Jedis 是 Redis官方推荐的Java连接开发工具，使用Java操作Redis中间件。 测试 导入对应的依赖12345678910111213&lt;!--导入jedis的依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编码测试 连接数据库 操作命令 断开连接12345678910public class TestPing &#123; public static void main(String[] args) &#123; // 1、new Jedis对象 Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); System.out.println(jedis.ping()); &#125;&#125; 输出： 操作事务： 12345678910111213141516171819202122232425262728293031public class TestTx &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379); jedis.flushDB(); JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;hello&quot;, &quot;world&quot;); jsonObject.put(&quot;name&quot;, &quot;marlowe&quot;); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); try &#123; multi.set(&quot;user1&quot;, result); multi.set(&quot;user2&quot;, result); // 代码抛出异常，事务执行失败 int i = 1 / 0; // 执行事务 multi.exec(); &#125; catch (Exception e) &#123; // 放弃事务 multi.discard(); e.printStackTrace(); &#125; finally &#123; System.out.println(jedis.get(&quot;user1&quot;)); System.out.println(jedis.get(&quot;user2&quot;)); jedis.close(); &#125; &#125;&#125; 输出：","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"},{"name":"Jedis","slug":"Jedis","permalink":"https://xmmarlowe.github.io/tags/Jedis/"}],"author":"Marlowe"},{"title":"Redis 事务","slug":"NoSQL/Redis-事务","date":"2020-12-20T03:46:30.000Z","updated":"2020-12-23T12:19:32.013Z","comments":true,"path":"2020/12/20/NoSQL/Redis-事务/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/20/NoSQL/Redis-%E4%BA%8B%E5%8A%A1/","excerpt":"Redis 事务简介","text":"Redis 事务简介 Redis 事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！一次性，顺序性，排他性 执行一系列的命令！ 1-----队列 set set set 执行----- Redis事务没有隔离级别的概念所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！ExecRedis单条命令是保证原子性的，但是事务不保证原子性Redis的事务： 开启事务() 命令入队() 执行事务() 正常执行事务 123456789101112131415127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec # 执行事务1) OK2) OK3) &quot;v2&quot;4) OK 放弃事务 123456789101112127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; discard # 取消事务OK127.0.0.1:6379&gt; get k4 # 事务队列中的命令都不会被执行(nil) 编译型异常，事务中的所有命令都不会被执行！ 123456789101112131415161718127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for &#x27;getset&#x27; command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v5QUEUED127.0.0.1:6379&gt; exec # 执行命令的时候报错(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 # 所有的命令都不会执行(nil) 运行时异常如果事务队列中存在与发行，那么执行命令的时候，其他命令是可以正常执行，错误命令抛出异常！ 1234567891011121314151617181920127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 &quot;v1&quot;QUEUED127.0.0.1:6379&gt; incr k1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec1) OK2) (error) ERR value is not an integer or out of range # 第一条命令报错，但是依旧正常执行成功了！3) OK4) OK5) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot; 监控 Watch 悲观锁 很悲观，认为什么时候都会出问题，无论做什么都会加锁！ 乐观锁 很乐观，认为什么时候都不会出问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version Redis 监视测试正常执行成功！ 123456789101112131415127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money # 监视money对象OK127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功OK127.0.0.1:6379&gt; decrby money 20QUEUED127.0.0.1:6379&gt; incrby out 20QUEUED127.0.0.1:6379&gt; exec1) (integer) 802) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"},{"name":"事务","slug":"事务","permalink":"https://xmmarlowe.github.io/tags/%E4%BA%8B%E5%8A%A1/"}],"author":"Marlowe"},{"title":"Redis 三种特殊数据类型","slug":"NoSQL/Redis-三种特殊数据类型","date":"2020-12-20T02:58:35.000Z","updated":"2020-12-20T15:40:18.878Z","comments":true,"path":"2020/12/20/NoSQL/Redis-三种特殊数据类型/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/20/NoSQL/Redis-%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Radis 三种特殊数据类型…","text":"Radis 三种特殊数据类型… 三种特殊数据类型geospatial12345678geoadd # 添加位置geopos #获得当前定位 一定是一个坐标值geodist # 两人之间的距离georadius # 以给定的经纬度为中心，找出某一半径内的元素可以加参数 withdist 显示距离， withcoord 显示经纬度， count x 限制个数georadiusbymember 找出指定元素周围的其他元素geohash 返回11个字符串的geohash字符串geo底层的实现原理就是zset！我们可以通过zset命令来操作geo Hyperloglog1234567891011Redis Hyperloglog 基数统计的算法！优点:占用的内存固定，2^64不同的元素基数，只需要12KB内存！如果要从内存角度来比较的话Hyperloglog首选！网页UV（一个人访问一个网站多次，但是还是算作一个人！）传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断！这个方式如果保存大量的用户id，就会比较麻烦！ 我们的目的是为了计数，而不是保存用户id；0.81误错率！ 统计UV任务，可以忽略不计的！pfcount 统计元素的基数数量pfmearge mykey3 mykey mykey2 #合并两组mykey mykey2 =&gt; mykey3 并集如果允许容错，使用Hyperloglog；如果不允许容错，就使用set或者自己的数据类型即可 Bitmap 位存储 12345678910111213141516171819统计用户信息，活跃 不活跃！ 登录 未登录! 打卡 未打卡！ 两个状态的，都可以使用BitmapsBitmaps 位图，数据结构！ 都是操作二进制来进行记录，就只有0和1两个状态！365天=365bit 1字节=8比特 46比特左右！使用bitmap来记录 周一到周日的打卡！127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 0(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0 查看某一天是否打卡！ 1234127.0.0.1:6379&gt; getbit sign 3(integer) 1127.0.0.1:6379&gt; getbit sign 6(integer) 0 统计操作，统计打卡的天数！ 12127.0.0.1:6379&gt; bitcount sign # 统计这周的打卡记录，可以看到是否全勤(integer) 3","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"},{"name":"数据类型","slug":"数据类型","permalink":"https://xmmarlowe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"author":"Marlowe"},{"title":"Redis 五大数据类型","slug":"NoSQL/Redis-五大数据类型","date":"2020-12-19T09:10:33.000Z","updated":"2020-12-20T15:40:18.890Z","comments":true,"path":"2020/12/19/NoSQL/Redis-五大数据类型/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/19/NoSQL/Redis-%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Redis 五大数据类型详述…","text":"Redis 五大数据类型详述… Redis-keyString（字符串）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127.0.0.1:6379&gt; set key1 v1OK127.0.0.1:6379&gt; get key1&quot;v1&quot;127.0.0.1:6379&gt; keys *1) &quot;key1&quot;127.0.0.1:6379&gt; exists key1(integer) 1127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 如果当前key不存在，就相当于set key(integer) 7127.0.0.1:6379&gt; get key1&quot;v1hello&quot;127.0.0.1:6379&gt; strlen key1(integer) 7########################################### i++127.0.0.1:6379&gt; set views 0OK127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incr views(integer) 1127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; decr views(integer) 0127.0.0.1:6379&gt; decr views(integer) -1127.0.0.1:6379&gt; get views&quot;-1&quot;127.0.0.1:6379&gt; incr views(integer) 0127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; incrby views 10(integer) 10127.0.0.1:6379&gt; decrby views 5(integer) 5########################################### 字符串范围 range127.0.0.1:6379&gt; set key1 &quot;hello,kuangshen&quot;OK127.0.0.1:6379&gt; get key1&quot;hello,kuangshen&quot;127.0.0.1:6379&gt; getrange key1 0 3&quot;hell&quot;127.0.0.1:6379&gt; getrange key1 0 -1&quot;hello,kuangshen&quot;# 替换127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2&quot;abcdefg&quot;127.0.0.1:6379&gt; setrange key2 1 xx(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;########################################### setex(set with expire) # 设置过期时间# setnx(set if not exist) # 不存在再设置(在分布式锁中常常使用！)127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;OK127.0.0.1:6379&gt; ttl key3(integer) 26127.0.0.1:6379&gt; get key3&quot;hello&quot;127.0.0.1:6379&gt; setnx mykey &quot;redis&quot;(integer) 1127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;3) &quot;mykey&quot;4) &quot;key3&quot;127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot;3) &quot;mykey&quot;127.0.0.1:6379&gt; setnx mykey &quot;MongoDB&quot;(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;##########################################127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;3) &quot;k1&quot;127.0.0.1:6379&gt; get k1 k2 k3(error) ERR wrong number of arguments for &#x27;get&#x27; command127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获得多个值1) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4 # msetnx是一个原子性操作，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379&gt; get k4(nil)# 对象set user:1&#123;name:zhangsan,age:3&#125; # 设置一个user：1对象，值为json字符来保存一个对象# 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125;127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:11) (nil)127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;##########################################getset # 先get再set127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回nil(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db mongodb # 如果存在值，则获取原来的值&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mongodb&quot; String类似的使用场景：value除了是字符串还可以是数字 计数器 统计多单位的数量 粉丝数 对象缓存存储！ List基本数据类型，列表所有的list命令都是以l开头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163##########################################127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; lpush list one # 将一个值或者多个值，插到列表的头部(左)(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;127.0.0.1:6379&gt; rpush list rigth # 将一个值或者多个值，插到列表的尾部(右)(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;rigth&quot;##########################################lpoprpop127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;3) &quot;one&quot;4) &quot;rigth&quot;127.0.0.1:6379&gt; lpop list # 移除列表的第一个元素&quot;three&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;rigth&quot;127.0.0.1:6379&gt; rpop list # 移除列表的最后一个元素&quot;rigth&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;##########################################lindex127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; lindex list 0 # 通过下标获得list中的某一个值&quot;two&quot;127.0.0.1:6379&gt; lindex list 1&quot;one&quot;##########################################llen127.0.0.1:6379&gt; lpush list one(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; llen list(integer) 3##########################################移除指定的值！取关 uidlrem127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;4) &quot;one&quot;127.0.0.1:6379&gt; lrem list 1 one # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; lrem list 1 three(integer) 1127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;two&quot;127.0.0.1:6379&gt; lpush list three(integer) 3127.0.0.1:6379&gt; keys *1) &quot;list&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;three&quot;2) &quot;three&quot;3) &quot;two&quot;127.0.0.1:6379&gt; lrem list 2 three(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) &quot;two&quot;##########################################trim：修剪 list：截断127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush list &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpush list &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; rpush list &quot;hello4&quot;(integer) 5127.0.0.1:6379&gt; ltrim list 0 1 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素！OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;hello1&quot;##########################################rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;hello1&quot;(integer) 2127.0.0.1:6379&gt; rpush list &quot;hello2&quot;(integer) 3127.0.0.1:6379&gt; rpush list &quot;hello3&quot;(integer) 4127.0.0.1:6379&gt; rpoplpush list list1 # 移除列表的最后一个元素，将他移动到新的列表中&quot;hello3&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;hello1&quot;3) &quot;hello2&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;hello3&quot;##########################################lset # 将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379&gt; lset list 0 itemOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;item&quot;2) &quot;hello1&quot;3) &quot;hello2&quot;127.0.0.1:6379&gt; lset list 1 item1OK127.0.0.1:6379&gt; lrange list 0 -11) &quot;item&quot;2) &quot;item1&quot;3) &quot;hello2&quot;##########################################linsert # 将某个具体的value插入到列表中某个元素的前面或者后面！127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;world&quot;(integer) 2127.0.0.1:6379&gt; linsert list before world other(integer) 3127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;127.0.0.1:6379&gt; linsert list after world other1(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;hello&quot;2) &quot;other&quot;3) &quot;world&quot;4) &quot;other1&quot; ########################################## 小结 实际上是一个链表，before Node after， left right都可以插入值 如果key不存在，创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在！ 在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点~ 消息排队！ 消息队列 （lpush rpop），栈（lpush lpop） Set(集合)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104##########################################127.0.0.1:6379&gt; sadd myset hello(integer) 1127.0.0.1:6379&gt; sadd myset kuangshen(integer) 1127.0.0.1:6379&gt; sadd myset lovekuangshen(integer) 1127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen&quot;2) &quot;hello&quot;3) &quot;kuangshen&quot;127.0.0.1:6379&gt; sismember myset hello(integer) 1127.0.0.1:6379&gt; sismember myset world(integer) 0##########################################127.0.0.1:6379&gt; scard myset # 获取set集合中的内容元素个数(integer) 4##########################################srem 127.0.0.1:6379&gt; scard myset(integer) 4127.0.0.1:6379&gt; srem myset hello # 移除set集合中指定的元素(integer) 1127.0.0.1:6379&gt; scard myset(integer) 3127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen2&quot;2) &quot;lovekuangshen&quot;3) &quot;kuangshen&quot;##########################################set 无序不重复集合，抽随机！127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen2&quot;2) &quot;lovekuangshen&quot;3) &quot;kuangshen&quot;127.0.0.1:6379&gt; srandmember myset # 随机抽选出一个元素&quot;lovekuangshen2&quot;127.0.0.1:6379&gt; srandmember myset # 随机抽选出一个元素&quot;lovekuangshen2&quot;127.0.0.1:6379&gt; srandmember myset # 随机抽选出一个元素&quot;kuangshen&quot;127.0.0.1:6379&gt; srandmember myset 2 # 随机抽选出指定个数的元素1) &quot;lovekuangshen&quot;2) &quot;kuangshen&quot;##########################################删除指定的key，随机删除key127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen2&quot;2) &quot;lovekuangshen&quot;3) &quot;kuangshen&quot;127.0.0.1:6379&gt; spop myset #随机删除一些set中的元素&quot;kuangshen&quot;127.0.0.1:6379&gt; spop myset&quot;lovekuangshen2&quot;127.0.0.1:6379&gt; smembers myset1) &quot;lovekuangshen&quot;##########################################将一个指定的值，移动到另外一个set集合！127.0.0.1:6379&gt; sadd myset hello(integer) 1127.0.0.1:6379&gt; sadd myset world(integer) 1127.0.0.1:6379&gt; sadd myset kuangshen(integer) 1127.0.0.1:6379&gt; sadd myset2 set2(integer) 1127.0.0.1:6379&gt; smove myset myset2 kuangshen # 将一个指定的值，移动到另外一个set集合(integer) 1127.0.0.1:6379&gt; smembers(error) ERR wrong number of arguments for &#x27;smembers&#x27; command127.0.0.1:6379&gt; smembers myset1) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; smembers myset21) &quot;set2&quot;2) &quot;kuangshen&quot;##########################################微博，b站，共同关注(交集)127.0.0.1:6379&gt; sadd key1 a(integer) 1127.0.0.1:6379&gt; sadd key1 b(integer) 1127.0.0.1:6379&gt; sadd key1 c(integer) 1127.0.0.1:6379&gt; sadd key2 c(integer) 1127.0.0.1:6379&gt; sadd key2 d(integer) 1127.0.0.1:6379&gt; sadd key2 e(integer) 1127.0.0.1:6379&gt; sdiff key1 key21) &quot;b&quot;2) &quot;a&quot;127.0.0.1:6379&gt; sinter key1 key21) &quot;c&quot;127.0.0.1:6379&gt; sunion key1 key21) &quot;c&quot;2) &quot;a&quot;3) &quot;b&quot;4) &quot;d&quot;5) &quot;e&quot;########################################## 微博，A用户将所有关注的人放在一个set集合中！ 将他的粉丝也放在一个集合中！共同关注，共同爱好，二度好友，推荐好友！(六度分割理论) Hash(哈希)Map 集合，key-map! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556127.0.0.1:6379&gt; hset myhash field1 kuangshen(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;kuangshen&quot;127.0.0.1:6379&gt; hmset myhash field1 hello field2 worldOK127.0.0.1:6379&gt; hmget myhash field1 field21) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field1&quot;4) &quot;hello&quot;5) &quot;field2&quot;6) &quot;world&quot;127.0.0.1:6379&gt; hdel myhash field1(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field2&quot;4) &quot;world&quot;##########################################hlen127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field2&quot;4) &quot;world&quot;127.0.0.1:6379&gt; hlen myhash # 获取hash表的字段数量(integer) 2##########################################127.0.0.1:6379&gt; hexists myhash field1 # 判断hash中指定字段是否存在！(integer) 0127.0.0.1:6379&gt; hexists myhash field2(integer) 1127.0.0.1:6379&gt; hgetall myhash1) &quot;field&quot;2) &quot;kuangshen&quot;3) &quot;field2&quot;4) &quot;world&quot;########################################### 只获取所有的field127.0.0.1:6379&gt; hkeys myhash1) &quot;field&quot;2) &quot;field2&quot;# 只获取所有的value127.0.0.1:6379&gt; hvals myhash1) &quot;kuangshen&quot;2) &quot;world&quot;########################################## hash变更的数据 user name age，尤其是用户信息之类的，经常变动的数据！hash更适合于对象的存储，String更加适合字符串存储！ Zset(有序集合)123456zaddzrangezrangebyscore xxx -inf +inf withscores # 显示全部的用户并且附带成绩zrevrange # 从大到小排序zrem # 移除元素zcount # 获取指定区间的成员数量 其余API，查官方文档案例思路：set 排序 存储班级成绩表，工资排序表！普通消息：1 重要消息：2 带权重进行判断！排行榜应用实现，取TOP 10","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"},{"name":"数据类型","slug":"数据类型","permalink":"https://xmmarlowe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"author":"Marlowe"},{"title":"Redis 基础知识","slug":"NoSQL/Redis-基础知识","date":"2020-12-19T08:19:14.000Z","updated":"2020-12-20T15:40:18.893Z","comments":true,"path":"2020/12/19/NoSQL/Redis-基础知识/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/19/NoSQL/Redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"Redis 基础知识","text":"Redis 基础知识 Redis 是单线程的！ Redis 是很快的，官方表示，Redis 是基于内存操作，CPU 不是Redis性能瓶颈，Redis 的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程实现，就使用单线程了。 Redis 是C语言写的，官方提供的数据位100000+的QPS，完全不比同样的使用key-value的Memecache差。 Redis 单线程为什么还这么快？ 误区1： 高性能服务器一定是多线程的？ 误区2： 多线程(CPU上下文会切换)一定比单线程效率高？ 核心：Redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程(CPU上下文切换：耗时的操作！！)对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上，在内存情况下，这就是最佳的方案！","categories":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"}],"author":"Marlowe"},{"title":"高效的一天","slug":"学习方法/高效的一天","date":"2020-12-19T01:18:48.000Z","updated":"2020-12-20T15:40:18.911Z","comments":true,"path":"2020/12/19/学习方法/高效的一天/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/19/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/%E9%AB%98%E6%95%88%E7%9A%84%E4%B8%80%E5%A4%A9/","excerpt":"大佬高效工作的一天…","text":"大佬高效工作的一天… 半小时整理每日重点和待办事项12整理每日计划，梳理一下今天大概要做什么事情，思考每件事情的优先级软件推荐：Notion 独立的工作区 回想昨天的工作，处理邮件 提前准备会议内容1Visio or PPT 整理要说的内容 避免多任务切换1和计算机类似，在计算机里切换任务，或者发生中断，要保存各种状态，上下文和数据，完成中断之后，还要恢复之前保存的数据，保存和恢复的过程，都要花费大量的计算，想办法尽量避免中断 在家工作划分工作和生活的界限 必要的生产力工具1iPad Pro + Notability + Notion 琐碎任务集中处理","categories":[{"name":"学习方法","slug":"学习方法","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://xmmarlowe.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"效率","slug":"效率","permalink":"https://xmmarlowe.github.io/tags/%E6%95%88%E7%8E%87/"},{"name":"工作方法","slug":"工作方法","permalink":"https://xmmarlowe.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"}],"author":"Marlowe"},{"title":"ES 文档的API操作详情","slug":"ElasticSearch/ES-文档的API操作详情","date":"2020-12-08T11:16:02.000Z","updated":"2020-12-10T00:43:37.401Z","comments":true,"path":"2020/12/08/ElasticSearch/ES-文档的API操作详情/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/08/ElasticSearch/ES-%E6%96%87%E6%A1%A3%E7%9A%84API%E6%93%8D%E4%BD%9C%E8%AF%A6%E6%83%85/","excerpt":"…","text":"… 编写ElasticSearchConfig 配置文件，将ES交给Spring托管 ElasticSearchConfig.java 1234567891011@Configurationpublic class ElasticSearchConfig &#123; @Bean public RestHighLevelClient restHighLevelClient() &#123; RestHighLevelClient restHighLevelClient = new RestHighLevelClient( RestClient.builder( new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;))); return restHighLevelClient; &#125;&#125; ES部分APIKuangEsApiApplicationTests.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173@SpringBootTestclass KuangEsApiApplicationTests &#123; @Autowired @Qualifier(&quot;restHighLevelClient&quot;) private RestHighLevelClient client; /** * 测试索引的创建 Request PUT kuang_index */ @Test void testCreateIndex() throws IOException &#123; // 1.创建索引请求 CreateIndexRequest request = new CreateIndexRequest(&quot;kuang_index&quot;); // 2.客户端执行请求 IndicesClient 请求后获得相应 CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); System.out.println(createIndexResponse); &#125; /** * 测试获取索引,判断其是否存在 */ @Test void testExistsIndex() throws IOException &#123; GetIndexRequest request = new GetIndexRequest(&quot;kuang_index&quot;); boolean exists = client.indices().exists(request, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * 测试删除索引，判断是否存在 * * @throws IOException */ @Test void testDeleteIndex() throws IOException &#123; DeleteIndexRequest request = new DeleteIndexRequest(&quot;kuang_index&quot;); AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT); System.out.println(delete.isAcknowledged()); &#125; /** * 测试添加文档 */ @Test void testAddDocument() throws IOException &#123; // 创建对象 User user = new User(&quot;狂神说&quot;, 3); // 创建请求 IndexRequest request = new IndexRequest(&quot;kuang_index&quot;); // 规则 put /kuang_index/_doc/1 request.id(&quot;1&quot;); request.timeout(TimeValue.timeValueSeconds(1)); request.timeout(&quot;1s&quot;); // 将我们的数据放入请求 json IndexRequest source = request.source(JSON.toJSONString(user), XContentType.JSON); // 客户端发送请求,获取响应的结果 IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT); System.out.println(indexResponse.toString()); System.out.println(indexResponse.status()); &#125; /** * 获取文档，判断是否存在 */ @Test void testIsExists() throws IOException &#123; GetRequest getRequest = new GetRequest(&quot;kuang_index&quot;, &quot;1&quot;); // 不获取返回的_source的上下文了 getRequest.fetchSourceContext(new FetchSourceContext(false)); getRequest.storedFields(&quot;_none_&quot;); boolean exists = client.exists(getRequest, RequestOptions.DEFAULT); System.out.println(exists); &#125; /** * 获取文档的信息 */ @Test void testGetDocument() throws IOException &#123; GetRequest getRequest = new GetRequest(&quot;kuang_index&quot;, &quot;1&quot;); GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT); // 打印文档的内容 System.out.println(getResponse.getSourceAsString()); // 返回的全部内容和命令是一样的 System.out.println(getResponse); &#125; /** * 更新文档的信息 */ @Test void testUpdateDocument() throws IOException &#123; UpdateRequest updateRequest = new UpdateRequest(&quot;kuang_index&quot;, &quot;1&quot;); updateRequest.timeout(&quot;1s&quot;); User user = new User(&quot;狂神说Java&quot;, 18); updateRequest.doc(JSON.toJSONString(user), XContentType.JSON); UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT); System.out.println(updateResponse.status()); &#125; /** * 删除文档的信息 */ @Test void testDeleteDocument() throws IOException &#123; DeleteRequest deleteRequest = new DeleteRequest(&quot;kuang_index&quot;, &quot;1&quot;); deleteRequest.timeout(&quot;1s&quot;); DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT); System.out.println(deleteResponse); &#125; /** * 批量插入数据 */ @Test void testBulkRequest() throws IOException &#123; BulkRequest bulkRequest = new BulkRequest(); bulkRequest.timeout(&quot;10s&quot;); List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;kuangshen1&quot;, 3)); userList.add(new User(&quot;kuangshen2&quot;, 3)); userList.add(new User(&quot;kuangshen3&quot;, 3)); userList.add(new User(&quot;qinjiang1&quot;, 3)); userList.add(new User(&quot;qinjiang2&quot;, 3)); userList.add(new User(&quot;qinjiang3&quot;, 3)); // 批处理请求 for (int i = 0; i &lt; userList.size(); i++) &#123; bulkRequest.add( new IndexRequest(&quot;kuang_index&quot;) .id(&quot;&quot; + (i + 1)) .source(JSON.toJSONString(userList.get(i)), XContentType.JSON)); &#125; BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT); System.out.println(bulkResponse.hasFailures()); &#125; /** * 查询 * searchRequest 搜索请求 * SearchSourceBuilder 条件构造 * HighlightBuilder 构建高亮 * TermQueryBuilder 精确查询 */ @Test void testSearch() throws IOException &#123; SearchRequest searchRequest = new SearchRequest(ESConst.ES_INDEX); // 构建搜索条件 SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); // 查询条件，我们可以使用QueryBuilder 工具来实现 TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;name&quot;, &quot;qinjiang1&quot;); sourceBuilder.query(termQueryBuilder); sourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS)); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); System.out.println(JSON.toJSONString(searchResponse.getHits())); System.out.println(&quot;======================&quot;); for (SearchHit documentFields : searchResponse.getHits().getHits()) &#123; System.out.println(documentFields.getSourceAsMap()); &#125; &#125;&#125;","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://xmmarlowe.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://xmmarlowe.github.io/tags/ES/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xmmarlowe.github.io/tags/SpringBoot/"},{"name":"API","slug":"API","permalink":"https://xmmarlowe.github.io/tags/API/"}],"author":"Marlowe"},{"title":"Rest风格操作","slug":"ElasticSearch/Rest风格操作","date":"2020-12-08T04:24:51.000Z","updated":"2020-12-09T08:26:40.796Z","comments":true,"path":"2020/12/08/ElasticSearch/Rest风格操作/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/08/ElasticSearch/Rest%E9%A3%8E%E6%A0%BC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"关于索引的基本操作12PUT /索引名/~类型名~/文档id&#123;请求体&#125; 完成了自动增加索引！数据也成功的添加了 指定字段的类型 12345678910111213141516PUT /test2&#123; &quot;mappings&quot;: &#123; &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;birthday&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125;&#125; 创建规则 可以通过GET请求获取具体信息 查看默认信息 如果自己的文档字段没有指定，那么es会给我们默认配置字段类型！ 扩展：通过命令elasticsearch索引情况！通过GET _cat/ 可以获得es当前的很多信息！ 更新方法 以前的方法 现在的方法 删除索引通过DELETE命令删除、根据你的请求来判断是删除索引还是删除文档记录！使用RESTFUL风格是ES推荐大家使用的！ 关于文档的基本操作(重点)基本操作 添加数据 1234567PUT /kuangshen/user/2&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;desc&quot;: &quot;法外狂徒张三&quot;, &quot;tags&quot;: [&quot;旅游&quot;,&quot;温暖&quot;,&quot;渣男&quot;]&#125; 获取数据 GET 1GET /kuangshen/user/1 更新数据 PUT POST _updatePUT如果不传递值就会被覆盖，POST灵活度更高 简单的搜索 1GET /kuangshen/user/1 简单的条件查询,可以根据默认的映射规则，产生基本的查询！ 1GET /kuangshen/user/_search?q=name:狂神说java 复杂操作搜索select(排序，分页，高亮，模糊查询，精准查询！) hits：索引和文档的信息查询的结果总数然后就是查询出来的具体的文档数据中心的所有东西都可以遍历出来了分数：我们可以通过分数来判断谁更加符合搜索结果 输出结果，只需要指定的字段 之后Java操作es，所有的方法和对象就是这里面的key！ 排序 分页查询数据下标还是从0开始的，和学的所有的数据结构是一样的！/search/{current}/{pagesize}布尔值查询must（and）,所有的条件都要符合 where id = 1 and name = xxx多条件查询 should（or）,所有的条件都要符合 where id = 1 or name = xxx must_not (not) 过滤器 filter 匹配多个条件 term查询是直接通过倒排索引指定的词条进行精确的查找！ 关于分词 term，直接查询精确的 match，会使用分词器解析！(先分析文档，然后再通过分析的文档进行查询！) 两个类型 text keyword keyword 字段类型不会被分词器解析 多个值匹配的精确查询 高亮查询 自定义搜索高亮条件 这些MySQL也能做，只是MySQL效率比较低！ 匹配 按照条件匹配 精确匹配 区间范围匹配 区间字段匹配 多条件查询 高亮查询","categories":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://xmmarlowe.github.io/categories/ElasticSearch/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://xmmarlowe.github.io/tags/ES/"},{"name":"Resuful","slug":"Resuful","permalink":"https://xmmarlowe.github.io/tags/Resuful/"}],"author":"Marlowe"},{"title":"ElasticSearch之ik插件之究极大坑","slug":"环境配置之踩坑/ElasticSearch之ik插件之究极大坑","date":"2020-12-07T17:10:24.000Z","updated":"2020-12-07T17:25:12.629Z","comments":true,"path":"2020/12/08/环境配置之踩坑/ElasticSearch之ik插件之究极大坑/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/08/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B8%A9%E5%9D%91/ElasticSearch%E4%B9%8Bik%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%A9%B6%E6%9E%81%E5%A4%A7%E5%9D%91/","excerpt":"由于最近要做搜索引擎课设，可以用ElasticSearch做，因此，开启了ES的学习之路，也开启了ES踩坑之路，入门一小时，配环境两小时！！~","text":"由于最近要做搜索引擎课设，可以用ElasticSearch做，因此，开启了ES的学习之路，也开启了ES踩坑之路，入门一小时，配环境两小时！！~ 在elasticsearch中安装ik中文分词器，使用的elasticsearch版本是7.10.0，elasticsearch-analysis-ik版本是7.10.0。 安装后，重新启动报错，报错信息为： 12[2020-11-18T17:14:56,012][WARN ][o.e.c.r.a.AllocationService] [LAPTOP-TLVIFKFC] failing shard [AccessControlException[access denied (&quot;java.io.FilePermission&quot; &quot;D:\\Program%20Files\\elasticsearch\\elasticsearch-7.10.0\\plugins\\ik\\config\\IKAnalyzer.cfg.xml&quot; &quot;read&quot;)]], markAsStale [true]]java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;D:\\Program%20Files\\elasticsearch\\elasticsearch-7.10.0\\plugins\\ik\\config\\IKAnalyzer.cfg.xml&quot; &quot;read&quot;) 原因是：elasticsearch安装路径中有空格造成的，如安装路径为D:\\Program Files\\elasticsearch\\elasticsearch-7.10.0，其中”Program Files”两个词中间有空格 解决方法：elasticsearch选择没有空格的文件目录下安装 前前后后下载了很多版本的插件，以及找同学烤文件，都没能解决这个问题，在百度重新搜索elasticsearch ik 7.10.0 下载的时候，出现了一篇拯救我的文章，重新安装好es所需要的文件后，将整个文件移动到没有空格的文件夹，问题才得以解决！ 参考：elasticsearch-7.10.0使用elasticsearch-analysis-ik-7.10.0分词器插件后启动报错 ES学习教程:【狂神说Java】ElasticSearch7.6.x最新完整教程通俗易懂","categories":[{"name":"环境配置之踩坑","slug":"环境配置之踩坑","permalink":"https://xmmarlowe.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"ES","slug":"ES","permalink":"https://xmmarlowe.github.io/tags/ES/"},{"name":"踩坑","slug":"踩坑","permalink":"https://xmmarlowe.github.io/tags/%E8%B8%A9%E5%9D%91/"}],"author":"Marlowe"},{"title":"Java中如何跳出多重循环","slug":"Java/Java中如何跳出多重循环","date":"2020-12-07T00:20:29.000Z","updated":"2021-03-19T13:00:33.354Z","comments":true,"path":"2020/12/07/Java/Java中如何跳出多重循环/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/07/Java/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF/","excerpt":"Java 基础回顾…","text":"Java 基础回顾… 在JAVA中如何跳出当前的多重嵌套循环在java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的的break语句，即可跳出 1234567891011public static void main(String[] args) &#123; ok: while (true) &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); if (i == 200) &#123; break ok; &#125; &#125; &#125; &#125; return和 break区别breakbreak语句虽然可以独立使用，但通常主要用于switch语句中，控制程序的执行流程转移。在switch语句中，其作用是强制退出switch结构，执行switch结构之后的语句。其本质就是在单层循环结构体系中，其作用是强制退出循环结构。 returnreturn语句用来明确地从一个方法返回。也就是，return 语句使程序控制返回到调用它方法。因此，将它分类为跳转语句.有两个作用，一个是返回方法指定类型的值（这个值总是确定的）;一个是结束方法的执行（仅仅一个return语句）。return 语句可以使其从当前方法中退出，返回到调用该方法的语句处，继续程序的执行 。 exit()函数 和 return 区别exit(0)：正常运行程序并退出程序；exit(1)：非正常运行导致退出程序；return()：返回函数，若在主函数中，则会退出函数并返回一值。 具体来说： return返回函数值，是关键字； exit 是一个函数。 return是语言级别的，它表示了调用堆栈的返回；而exit是系统调用级别的，它表示结束一个进程 。 return是函数的退出(返回)；exit是进程的退出。 return是C语言提供的，exit是操作系统提供的（或者函数库中给出的）。 return用于结束一个函数的执行，将函数的执行信息传出个其他调用函数使用；exit函数是退出应用程序，删除进程使用的内存空间，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息，这个信息和机器和操作系统有关，一般是 0 为正常退出， 非0 为非正常退出。 非主函数中调用return和exit效果很明显，但是在main函数中调用return和exit的现象就很模糊，多数情况下现象都是一致的。 参考在java中如何跳出当前的多重嵌套循环？","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://xmmarlowe.github.io/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://xmmarlowe.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面经","slug":"面经","permalink":"https://xmmarlowe.github.io/tags/%E9%9D%A2%E7%BB%8F/"}],"author":"Marlowe"},{"title":"Swagger在线文档","slug":"Spring/Swagger在线文档","date":"2020-12-06T10:30:51.000Z","updated":"2020-12-18T02:35:43.038Z","comments":true,"path":"2020/12/06/Spring/Swagger在线文档/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/06/Spring/Swagger%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3/","excerpt":"Swagger在线文档使用教程…","text":"Swagger在线文档使用教程… SpringBoot集成Swagger 新建一个SpringBoot项目==&gt;web 导入相关依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 编写HelloWorld 配置Swagger1234@Configuration@EnableSwagger2public class SwaggerConfig &#123;&#125; 测试运行 http://localhost:8080/swagger-ui.html 配置Swagger信息Swagger的bean示例Docket 123456789101112131415161718192021222324252627@Configuration@EnableSwagger2public class SwaggerConfig &#123; /** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()); &#125; public ApiInfo apiInfo() &#123; // 作者信息 Contact contact = new Contact(&quot;Marlowe&quot;, &quot;https://xmmarlowe.github.io&quot;, &quot;marlowe246@qq.com&quot;); return new ApiInfo(&quot;Visit CQUT Swagger API Documentation&quot;, &quot;Api Documentation&quot;, &quot;v1.0&quot;, &quot;urn:tos&quot;, contact, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); &#125;&#125; Swagger配置扫描接口Docket.select() 1234567891011121314151617181920212223/** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() /** * RequestHandlerSelectors，配置要扫描接口的方式 * basePackage:指定要扫描的包 * any():扫描全部 * none():不扫描 * withClassAnnotation:扫描类上的注解，参数是一个注解的反射对象 * withMethodAnnotation：扫描方法上的注解 */ .apis(RequestHandlerSelectors.basePackage(&quot;com.marlowe.swagger.controller&quot;)) // paths(): 过滤什么路径 .paths(PathSelectors.ant(&quot;/marlowe/**&quot;)) .build(); &#125; 配置是否启动swagger 123456789101112131415/** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) // enable是否启动Swagger，如果为false，则swagger不能在浏览器中访问 .enable(false) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.marlowe.swagger.controller&quot;)) .build(); &#125; 我只希望我的Swagger在生产环境中使用，在发布的时候不使用？ 判断是不是生产环境 flag = false 注入enable(flag)123456789101112131415161718192021/** * 配置了Swagger的Docket的bean实例 * * @return */ @Bean public Docket docket(Environment environment) &#123; // 设置要现实的swagger环境 Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;); // 获取项目的环境： boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) // enable是否启动Swagger，如果为false，则swagger不能在浏览器中访问 .enable(flag) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.marlowe.swagger.controller&quot;)) .build(); &#125; 配置API文档的分组1.groupName(&quot;Marlowe&quot;) 如何配置多个分组；多个Docket实例即可1234567891011121314@Beanpublic Docket docket1() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;);&#125;@Beanpublic Docket docket2() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;);&#125;@Beanpublic Docket docket3() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;C&quot;);&#125; 实体类配置12345678910111213141516171819package com.marlowe.swagger.pojo;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * @program: swagger-demo * @description: * @author: Marlowe * @create: 2020-12-06 19:39 **/@ApiModel(&quot;用户实体类&quot;)public class User &#123; @ApiModelProperty(&quot;用户名&quot;) public String username; @ApiModelProperty(&quot;密码&quot;) public String password;&#125; controller12345678910111213141516171819202122232425262728293031323334353637383940414243package com.marlowe.swagger.controller;import com.marlowe.swagger.pojo.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;/** * @program: swagger-demo * @description: * @author: Marlowe * @create: 2020-12-06 18:07 **/@Api(tags = &quot;hello控制类&quot;)@RestControllerpublic class HelloController &#123; @GetMapping(value = &quot;/hello&quot;) public String hello() &#123; return &quot;hello&quot;; &#125; @PostMapping(value = &quot;/user&quot;) public User user() &#123; return new User(); &#125; @ApiOperation(&quot;Hello 控制类&quot;) @GetMapping(value = &quot;/hello2&quot;) public String hello2(@ApiParam(&quot;用户名&quot;) String username) &#123; return &quot;hello&quot; + username; &#125; @ApiOperation(&quot;Post 控制类&quot;) @GetMapping(value = &quot;/postt&quot;) public User post(@ApiParam(&quot;用户&quot;) User user) &#123; return user; &#125;&#125; 总结： 可以通过Swagger给一些比较难理解的属性或者接口，增加注释信息 接口文档实时更新 可以在线测试 【注意点】在正式发布的时候，关闭Swagger！！！ 处于安全考虑，并且节省内存！","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/categories/Spring/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xmmarlowe.github.io/tags/SpringBoot/"},{"name":"Swagger","slug":"Swagger","permalink":"https://xmmarlowe.github.io/tags/Swagger/"},{"name":"配置","slug":"配置","permalink":"https://xmmarlowe.github.io/tags/%E9%85%8D%E7%BD%AE/"}],"author":"Marlowe"},{"title":"使用注解开发","slug":"Spring/使用注解开发","date":"2020-12-05T05:40:10.000Z","updated":"2020-12-05T06:18:50.748Z","comments":true,"path":"2020/12/05/Spring/使用注解开发/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/05/Spring/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"使用注解开发…","text":"使用注解开发… 在Spring4之后，使用注解开发，必须要保证aop的包导入了使用注解需要导入context约束，增加注解的支持！ 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 1.bean2.属性如何注入12345678910@Componentpublic class User &#123; public String name; // 相当于&lt;property name=&quot;name&quot; value=&quot;marlowe2&quot;&gt; @Value(&quot;marlowe2&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 3.衍生的注解@Component有几个衍生注解，我们再web开发中，会按照mvc三层架构分层！ dao【@Repository】 service【@Service】 controller【@Service】这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配Bean 4.自动装配1234- @Autowired:自动装配通过类型。名字 如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value=&quot;xxx&quot;)- @Nullable： 字段标记了这个注解，说明这个字段可以为null- @Resource： 自动装配通过名字。类型 5.作用域1234567891011@Component@Scope(&quot;prototype&quot;)public class User &#123; public String name; // 相当于&lt;property name=&quot;name&quot; value=&quot;marlowe2&quot;&gt; @Value(&quot;marlowe2&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 6.小结xml与注解： xml： 更加万能，适用于任何场合！维护简单方便 注解： 不是自己的类使用不了，维护相对复杂！ xml与注解最佳实践： xml用来管理bean 注解只负责完成属性的注入 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持 123&lt;!--指定要扫描的包，这个包下面的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;com.marlowe&quot;/&gt;&lt;context:annotation-config/&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/tags/Spring/"},{"name":"注解","slug":"注解","permalink":"https://xmmarlowe.github.io/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"Marlowe"},{"title":"依赖注入","slug":"Spring/依赖注入","date":"2020-12-05T04:50:54.000Z","updated":"2020-12-05T04:55:07.288Z","comments":true,"path":"2020/12/05/Spring/依赖注入/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/05/Spring/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"简述依赖注入的三种方式","text":"简述依赖注入的三种方式 构造器注入见文章《IOC创建对象的方式》 Set方式注入【重点】 依赖注入：Set注入！ 依赖：bean对象的创建依赖于容器！ 注入：bean对象中的所有属性，由容器来注入！ 【环境搭建】 复杂类型123456789101112public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 真实测试对象 12345678910public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info;&#125; beans.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--第一种，普通值注入，value--&gt; &lt;bean id=&quot;student&quot; class=&quot;com.marlowe.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;marlowe&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 1234567public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.getName()); &#125;&#125; 完善注入信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.marlowe.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;China&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.marlowe.pojo.Student&quot;&gt; &lt;!--第一种，普通值注入，value--&gt; &lt;property name=&quot;name&quot; value=&quot;marlowe&quot;/&gt; &lt;!--第二种，Bean注入，ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--数组--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;11111111&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;22222222&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LoL&lt;/value&gt; &lt;value&gt;DNF&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--Properties--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driver&quot;&gt;11111&lt;/prop&gt; &lt;prop key=&quot;url&quot;&gt;marlowe&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 扩展方式注入我们可以使用p命名空间和c命名空间进行注入官方解释： 使用: 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot; p:name=&quot;marlowe&quot; p:age=&quot;18&quot;&gt;&lt;/bean&gt; &lt;!--c命名空间注入，可以通过构造器注入：construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.marlowe.pojo.User&quot; c:name=&quot;marlowe&quot; c:age=&quot;18&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 测试： 123456@Testpublic void test2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;); User user = (User) context.getBean(&quot;user2&quot;); System.out.println(user.toString());&#125; 注意点：p命名和c命名不能直接使用，需要导入xml约束！ 12xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; bean的作用域 单例模式（spring默认机制）1&lt;bean id=&quot;user2&quot; class=&quot;com.marlowe.pojo.User&quot; c:name=&quot;marlowe&quot; c:age=&quot;18&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 原型模式：每次从容器中get的时候，都会产生一个新对象！1&lt;bean id=&quot;user2&quot; class=&quot;com.marlowe.pojo.User&quot; c:name=&quot;marlowe&quot; c:age=&quot;18&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; 其余的request、session、application 这些只能在web开发中使用到！","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"https://xmmarlowe.github.io/tags/DI/"}],"author":"Marlowe"},{"title":"Bean的自动装配","slug":"Spring/Bean的自动装配","date":"2020-12-05T03:55:53.000Z","updated":"2020-12-05T05:38:33.810Z","comments":true,"path":"2020/12/05/Spring/Bean的自动装配/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/05/Spring/Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/","excerpt":"bean的三种自动装配方式…","text":"bean的三种自动装配方式… 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring中有三种装配方式 在xml中显示的配置 在java中显示配置 隐式的自动装配bean【重要】 测试环境搭建：一个人有两个宠物 12345public class People &#123; private String name; private Cat cat; private Dog dog;&#125; byName自动装配123456&lt;!--byName:会自动在容器上下文中查找和自己对象set方法后面的值对应的bean id！--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.marlowe.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;陈浩南&quot;/&gt;&lt;/bean&gt; byType自动装配123456789&lt;bean class=&quot;com.marlowe.pojo.Cat&quot;/&gt;&lt;bean class=&quot;com.marlowe.pojo.Dog&quot;/&gt;&lt;!--byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean！--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.marlowe.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;陈浩南&quot;/&gt;&lt;/bean&gt; 小结： byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！（原理是将set方法后面部分转换成小写，再与id进行比对，例如：setDog ==&gt; id = “dog”、setdog1 ==&gt; id = “dog1”等可以自动注入、但是setDog ==&gt; id = “Dog”就不行） byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！ 使用注解实现自动装配JDK1.5支持的注解，Spring2.5就支持注解了！要使用注解须知： 导入约束。context约束 配置注解的支持 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方式上使用！ 使用Autowired，我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在，且符合名字byName！ 科普： 1@Nullable 字段标记了这个注解，说明这个字段可以为null 123 public @interface Autowired &#123; boolean required() default true;&#125; 测试代码 12345678public class People &#123; // 如果显示定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name;&#125;如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成额时候、我们可以使用@Qualifier(value = “xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 1234567@Autowired@Qualifier(value = &quot;cat11&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog11&quot;)private Dog dog; @Resource注解 1234567public class People &#123; @Resource(name = &quot;cat1&quot;) private Cat cat; @Resource private Dog dog;&#125; 小结：@Autowired和@Resource的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired 通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired 通过byType的方式实现。@Resource默认通过byName的方式实现。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/categories/Spring/"}],"tags":[{"name":"Bean","slug":"Bean","permalink":"https://xmmarlowe.github.io/tags/Bean/"},{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/tags/Spring/"}],"author":"Marlowe"},{"title":"IOC创建对象的方式","slug":"Spring/IOC创建对象的方式","date":"2020-12-04T13:02:41.000Z","updated":"2020-12-05T04:49:49.390Z","comments":true,"path":"2020/12/04/Spring/IOC创建对象的方式/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/04/Spring/IOC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"IOC创建对象的三种方式…","text":"IOC创建对象的三种方式… 下标 1234&lt;!--第一种方式：下标赋值--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;狂神说Java&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 类型 1234&lt;!--第二种方式：不建议使用！通过类型创建--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;狂神&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 参数名 1234&lt;!--第三种方式，直接通过参数名来设置--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.marlowe.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;狂神说Java&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！","categories":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"https://xmmarlowe.github.io/tags/IOC/"}],"author":"Marlowe"},{"title":"集合类不安全","slug":"JUC/集合类不安全","date":"2020-12-03T13:49:32.000Z","updated":"2020-12-05T06:30:38.804Z","comments":true,"path":"2020/12/03/JUC/集合类不安全/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/03/JUC/%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8/","excerpt":"111","text":"111 List不安全12345678910111213141516171819202122232425262728293031323334353637383940package com.marlowe.unsafe;import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;/** * @program: juc * @description: java.util.ConcurrentModificationException 并发修改异常 * @author: Marlowe * @create: 2020-12-03 21:00 **/public class ListTest &#123; public static void main(String[] args) &#123; /** * 并发下ArrayList 不安全的 * * 解决方法： * 1、List&lt;String&gt; list = new Vector&lt;&gt;(); * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); */ /** * CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略 * 多个线程调用的时候，list，读取的时候，固定的，写入的（覆盖） * 在写入的时候避免覆盖，造成数据问题！ * CopyOnWriteArrayList 比 Vector 好在那里 前者是lock，后者是是synchronized */ List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; Set不安全123456789101112131415161718192021222324252627282930package com.marlowe.unsafe;import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;/** * @program: juc * @description: 同理可证 ：java.util.ConcurrentModificationException * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); * 2、Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); * @author: Marlowe * @create: 2020-12-03 21:53 **/public class SetTest &#123; public static void main(String[] args) &#123; // Set&lt;String&gt; set = new HashSet&lt;&gt;(); // Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; set.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(set); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; HashSet 底层是什么？1234567891011public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;// add set本质就是map key是无法重复的public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;// PRESENTprivate static final Object PRESENT = new Object(); Map 不安全回顾Map基本操作 12345678910111213141516171819202122232425import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;/** * @program: juc * @description: java.util.ConcurrentModificationException * @author: Marlowe * @create: 2020-12-03 22:11 **/public class MapTest &#123; public static void main(String[] args) &#123; // map是这样用的吗？不是，工作中不用HashMap // HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); System.out.println(map); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125;","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://xmmarlowe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"list","slug":"list","permalink":"https://xmmarlowe.github.io/tags/list/"},{"name":"线程不安全","slug":"线程不安全","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"}],"author":"Marlowe"},{"title":"8锁问题","slug":"JUC/8锁问题","date":"2020-12-03T12:08:54.000Z","updated":"2020-12-05T05:29:29.769Z","comments":true,"path":"2020/12/03/JUC/8锁问题/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/03/JUC/8%E9%94%81%E9%97%AE%E9%A2%98/","excerpt":"待完善…","text":"待完善… 小结 new this 具体的一个手机static Class 唯一的一个模板","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://xmmarlowe.github.io/tags/%E9%94%81/"},{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://xmmarlowe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"synchronized和Lock区别","slug":"JUC/synchronized和Lock区别","date":"2020-12-02T14:19:29.000Z","updated":"2020-12-05T05:29:42.139Z","comments":true,"path":"2020/12/02/JUC/synchronized和Lock区别/","link":"","permalink":"https://xmmarlowe.github.io/2020/12/02/JUC/synchronized%E5%92%8CLock%E5%8C%BA%E5%88%AB/","excerpt":"简述 synchronized 和 Lock 区别…","text":"简述 synchronized 和 Lock 区别… synchronized 内置的Java关键字；Lock 是一个Java类 synchronized 无法判断获取锁的状态；Lock 可以判断是否获取了锁 synchronized 会自动释放锁；Lock 必须要手动释放锁！ 如果不释放，死锁 synchronized 线程1（获得锁，阻塞）、线程2（等待、傻傻的等）；Lock 锁就不一定会等待下去 synchronized 可重入锁，不可以中断的，非公平的；Lock ，可重入锁，可以判断锁，非公平（可以自己设置） synchronized 适合锁少量的代码同步问题；Lock 适合锁大量的！","categories":[{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://xmmarlowe.github.io/tags/%E9%94%81/"},{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://xmmarlowe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Marlowe"},{"title":"设计模式-策略","slug":"设计模式/设计模式-策略","date":"2020-11-29T12:38:08.000Z","updated":"2020-11-30T04:04:57.448Z","comments":true,"path":"2020/11/29/设计模式/设计模式-策略/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/","excerpt":"在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。","text":"在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 使用场景 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 一个系统需要动态地在几种算法中选择一种。 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 优缺点及注意优点 算法可以自由切换。 避免使用多重条件判断。 扩展性良好。 缺点 策略类会增多。 所有策略类都需要对外暴露。 注意如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 实现策略角色 123456public interface Strategy &#123; /** * 算法方法 */ public void algorithmInterface();&#125; 以下三个实现类为具体的策略角色 123456public class ConcreteStrategyA implements Strategy&#123; @Override public void algorithmInterface() &#123; System.out.println(&quot;具体的策略A&quot;); &#125;&#125; 123456public class ConcreteStrategyB implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println(&quot;具体的策略B&quot;); &#125;&#125; 1234567public class ConcreteStrategyC implements Strategy &#123; @Override public void algorithmInterface() &#123; System.out.println(&quot;具体的策略C&quot;); &#125;&#125; Context上下文 1234567891011121314public class Context &#123; private Strategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; /** * 上下文接口,执行对应策略 */ public void executeStrategy() &#123; strategy.algorithmInterface(); &#125;&#125; 客户端 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.executeStrategy(); context = new Context(new ConcreteStrategyB()); context.executeStrategy(); context = new Context(new ConcreteStrategyC()); context.executeStrategy(); &#125;&#125; 结果： 123具体的策略A具体的策略B具体的策略C","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://xmmarlowe.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"策略","slug":"策略","permalink":"https://xmmarlowe.github.io/tags/%E7%AD%96%E7%95%A5/"}],"author":"Marlowe"},{"title":"JsonUtils","slug":"自定义工具类/JsonUtils","date":"2020-11-27T13:34:41.000Z","updated":"2020-12-11T02:07:56.029Z","comments":true,"path":"2020/11/27/自定义工具类/JsonUtils/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/JsonUtils/","excerpt":"","text":"123456789101112131415161718192021222324252627282930package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; public static String getJson(Object object,String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try &#123; return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125;","categories":[{"name":"自定义工具类","slug":"自定义工具类","permalink":"https://xmmarlowe.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://xmmarlowe.github.io/tags/Json/"},{"name":"Utils","slug":"Utils","permalink":"https://xmmarlowe.github.io/tags/Utils/"}],"author":"Marlowe"},{"title":"设计模式-代理","slug":"设计模式/设计模式-代理","date":"2020-11-27T08:36:13.000Z","updated":"2021-03-17T07:13:40.626Z","comments":true,"path":"2020/11/27/设计模式/设计模式-代理/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/","excerpt":"在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。","text":"在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 主要解决的问题在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 优缺点及注意优点 职责清晰。 高扩展性。 智能化。缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 注意 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 实现静态代理角色分析: 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作 客户：访问代理对象的人！ 接口1234567public interface Rent &#123; /** * 出租房屋 */ public void rent();&#125; 真实角色123456public class Landlord implements Rent &#123; @Override public void rent() &#123; System.out.println(&quot;房东要出租房子！&quot;); &#125;&#125; 代理角色12345678910111213141516171819202122232425262728293031public class Proxy implements Rent &#123; private Landlord landlord; public Proxy() &#123; &#125; public Proxy(Landlord landlord) &#123; this.landlord = landlord; &#125; @Override public void rent() &#123; seeHouse(); landlord.rent(); signContract(); fee(); &#125; public void seeHouse() &#123; System.out.println(&quot;中介带你看房&quot;); &#125; public void signContract() &#123; System.out.println(&quot;签合同&quot;); &#125; public void fee() &#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; 客户端访问代理角色1234567891011public class Client &#123; public static void main(String[] args) &#123; // 房东要租房子 Landlord landlord = new Landlord(); // 代理,中介帮房东租房子，但是 代理一般会有一些附属操作 Proxy proxy = new Proxy(landlord); // 你不用面对房东，直接找中介即可 proxy.rent(); &#125;&#125; 12345结果：中介带你看房房东要出租房子！签合同收中介费 Spring AOP 代理模式的好处： 可以是真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 缺点： 一个真实的角色就会产生一个代理角色；代码量会翻倍，开发效率会变低~ 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口 — JDK动态代理 基于类：cglib java字节码实现：javasist 需要两节两个类：Proxy，InvocationHandler：调用处理程序 动态代理的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要实现了同一接口即可。 接口123456789public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 实现类12345678910111213141516171819202122public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 动态代理工具类（通用方法）12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyInvocationHandlerUtil implements InvocationHandler &#123; /** * 被代理的接口 */ private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; /** * 生成得到代理类 * * @return */ public Object getProxy() &#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; /** * 处理代理实例，并返回结果 * * @param proxy * @param method * @param args * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String msg) &#123; System.out.println(&quot;[Debug] 使用了&quot; + msg + &quot;方法&quot;); &#125;&#125; 客户端访问代理角色12345678910111213public class Client2 &#123; public static void main(String[] args) &#123; // 真实角色 UserServiceImpl userService = new UserServiceImpl(); // 代理角色，不存在 ProxyInvocationHandlerUtil pihu = new ProxyInvocationHandlerUtil(); // 设置需要代理的对象 pihu.setTarget(userService); // 动态生成代理类 UserService proxy = (UserService) pihu.getProxy(); proxy.add(); &#125;&#125; 123结果：[Debug] 使用了add方法增加了一个用户","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"代理","slug":"代理","permalink":"https://xmmarlowe.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xmmarlowe.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"author":"Marlowe"},{"title":"设计模式-单例","slug":"设计模式/设计模式-单例","date":"2020-11-22T23:17:03.000Z","updated":"2020-12-05T04:44:01.063Z","comments":true,"path":"2020/11/23/设计模式/设计模式-单例/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。","text":"单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 介绍单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。 这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 使用场景： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。优缺点及注意 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。缺点没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。注意getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现饿汉式12345678910111213141516171819202122232425262728package com.marlowe.singleton;/** * @program: GoF23 * @description: 饿汉式 * @author: Marlowe * @create: 2020-11-23 15:07 **/public class Hungry &#123; /** * 可能会浪费空间 */ private byte[] data1 = new byte[1024 * 1024]; private byte[] data2 = new byte[1024 * 1024]; private byte[] data3 = new byte[1024 * 1024]; private Hungry() &#123; &#125; private final static Hungry HUNGRY = new Hungry(); public static Hungry getInstance() &#123; return HUNGRY; &#125;&#125; DCL(Double CheckLock 双重校验锁(线程安全、效率高))懒汉式，深究！注意： 如果不使用volatile关键词修饰，可能会导致拿到的对象是未被初始化的。具体原因见代码注释部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.marlowe.singleton;import java.lang.reflect.Constructor;import java.lang.reflect.Field;/** * @program: GoF23 * @description: 懒汉式 * @author: Marlowe * @create: 2020-11-23 15:11 **/public class LazyMan &#123; private static boolean marlowe = false; private LazyMan() &#123; synchronized (LazyMan.class) &#123; if (marlowe == false) &#123; marlowe = true; &#125; else &#123; throw new RuntimeException(&quot;不要试图使用反射破坏异常&quot;); &#125; &#125; System.out.println(Thread.currentThread().getName() + &quot;ok&quot;); &#125; private volatile static LazyMan lazyMan; /** * 双重检测所模式的 懒汉式单例 DCL懒汉式 * * @return */ public static LazyMan getInstance() &#123; if (lazyMan == null) &#123; synchronized (LazyMan.class) &#123; if (lazyMan == null) &#123; // 不是原子性操作 lazyMan = new LazyMan(); /** * 1. 分配内存空间 * 2. 执行构造方法，初始化对象 * 3. 把这个对象指向这个空间 * * 预期执行顺序 1-&gt;2-&gt;3 * 由于JVM具有指令重排的特性 实际顺序可能是1-&gt;3-&gt;2 * 指令重排在单线程的环境下不会出现问题，但是在多线程环境下可能会导致一个线程获得还没有初始化的实例 * 例如：A线程执行了1,3，此时B线程调用getInstance() 后发现 lazyMan 不为空，因此直接返回 lazyMan * 但此时 lazyMan 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行 * */ &#125; &#125; &#125; return lazyMan; &#125; /** * 反射 * * @param args */ public static void main(String[] args) throws Exception &#123; Field marlowe = LazyMan.class.getDeclaredField(&quot;marlowe&quot;); marlowe.setAccessible(true); Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null); declaredConstructor.setAccessible(true); LazyMan instance = declaredConstructor.newInstance(); LazyMan instance2 = declaredConstructor.newInstance(); marlowe.set(instance, false); System.out.println(instance); System.out.println(instance2); &#125;&#125; 静态内部类12345678910111213141516171819202122package com.marlowe.singleton;/** * @program: GoF23 * @description: 静态内部类 * @author: Marlowe * @create: 2020-11-23 15:32 **/public class Holder &#123; private Holder() &#123; &#125; public static Holder getInstance() &#123; return InnerClass.HOLDER; &#125; public static class InnerClass &#123; private static final Holder HOLDER = new Holder(); &#125;&#125; 单例不安全，因为有反射12345678910111213141516171819202122232425262728293031package com.marlowe.singleton;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * @program: GoF23 * @description: enum 是什么？ 本身也是一个class类 * @author: Marlowe * @create: 2020-11-23 15:49 **/public enum EnumSingleton &#123; INSTANCE; public EnumSingleton getInstance() &#123; return INSTANCE; &#125;&#125;class Test &#123; public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123; EnumSingleton instance1 = EnumSingleton.INSTANCE; Constructor&lt;EnumSingleton&gt; declaredConstructor = EnumSingleton.class.getDeclaredConstructor(String.class, int.class); declaredConstructor.setAccessible(true); EnumSingleton instance2 = declaredConstructor.newInstance(); System.out.println(instance1); System.out.println(instance2); &#125;&#125; 枚举类型的最终反编译原码里面是有参构造方法 经验之谈 单例对象 占用资源少，不需要延时加载，枚举 好于 饿汉 单例对象 占用资源多，需要延时加载，静态内部类 好于 懒汉式 参考文献blog.unclezs.com","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"单例","slug":"单例","permalink":"https://xmmarlowe.github.io/tags/%E5%8D%95%E4%BE%8B/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://xmmarlowe.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"author":"Marlowe"},{"title":"设计模式-工厂","slug":"设计模式/设计模式-工厂","date":"2020-11-20T08:49:24.000Z","updated":"2020-12-05T04:44:01.060Z","comments":true,"path":"2020/11/20/设计模式/设计模式-工厂/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82/","excerpt":"工厂设计模式很常用，分为简单工厂，工厂方法和抽象工厂。","text":"工厂设计模式很常用，分为简单工厂，工厂方法和抽象工厂。 核心本质 实例化对象不使用new，用工厂方法代替 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们实现类解耦 OOP七大原则 开闭原则：一个软件的实体应当对扩展开放，对修改关闭 依赖倒转原则：要针对接口编程，不要针对实现编程 迪米特法则：只与你直接的朋友通信，而避免与陌生人通信 应用场景 JDK中Calendar的getInstance方法 JDBC中的Connection对象的获取 Spring中IOC容器创建管理bean对象 反射中Class对象的newInstance方法 三种模式简单工厂(Simple Factory)用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码） 如下图需要扩展一类新车–Ford，需要扩展车工厂里面的代码 Car接口 123456789101112package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 车接口 * @author: Marlowe * @create: 2020-11-20 17:00 **/public interface Car &#123; public void name();&#125; 以下两个实体类实现Car接口 123456789101112131415package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 宝马 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Bmw implements Car &#123; @Override public void name() &#123; System.out.println(&quot;我是宝马！&quot;); &#125;&#125; 123456789101112131415package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 特斯拉 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Tesla implements Car&#123; @Override public void name() &#123; System.out.println(&quot;我是特斯拉！&quot;); &#125;&#125; CarFactory工厂类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 汽车工厂 * 静态工厂模式 * 开闭原则 * @author: Marlowe * @create: 2020-11-20 17:02 **/public class CarFactory &#123; /** * 方法一 * * @param car * @return */ public static Car getCar(String car) &#123; if (&quot;宝马&quot;.equals(car)) &#123; return new Bmw(); &#125; else if (&quot;特斯拉&quot;.equals(car)) &#123; return new Tesla(); &#125; else &#123; return null; &#125; &#125; /** * 方法二 * * @return */ public static Car getBmw() &#123; return new Bmw(); &#125; public static Car getTesla() &#123; return new Tesla(); &#125;&#125; 主类 1234567891011121314151617181920212223package com.marlowe.factory.simple;/** * @program: GoF23 * @description: 顾客 * @author: Marlowe * @create: 2020-11-20 17:03 **/public class Comsumer &#123; public static void main(String[] args) &#123; System.out.println(&quot;通过方式1获取:&quot;); Car car1 = CarFactory.getCar(&quot;宝马&quot;); Car car2 = CarFactory.getCar(&quot;特斯拉&quot;); car1.name(); car2.name(); System.out.println(&quot;通过方式2获取:&quot;); Car bmw = CarFactory.getBmw(); Car tesla = CarFactory.getTesla(); bmw.name(); tesla.name(); &#125;&#125; 1234567结果：通过方式1获取:我是宝马！我是特斯拉！通过方式2获取:我是宝马！我是特斯拉！ 工厂方法(Factory Method)用来生产同一等级结构中的固定产品（支持增加任意产品） 如下图需要扩展一类新车–Ford，横向扩展即可 Car接口 123456789101112package com.marlowe.factory.method;/** * @program: GoF23 * @description: 车接口 * @author: Marlowe * @create: 2020-11-20 17:00 **/public interface Car &#123; public void name();&#125; 以下两个实体类实现Car接口 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: 宝马 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Bmw implements Car &#123; @Override public void name() &#123; System.out.println(&quot;我是宝马！&quot;); &#125;&#125; 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: 特斯拉 * @author: Marlowe * @create: 2020-11-20 17:01 **/public class Tesla implements Car &#123; @Override public void name() &#123; System.out.println(&quot;我是特斯拉！&quot;); &#125;&#125; CarFactory接口 123456789101112package com.marlowe.factory.method;/** * @program: GoF23 * @description: 工厂方法模式 * @author: Marlowe * @create: 2020-11-20 18:54 **/public interface CarFactory &#123; Car getCar();&#125; 以下两个类实现CarFactory接口 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: * @author: Marlowe * @create: 2020-11-20 18:55 **/public class BmwFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Bmw(); &#125;&#125; 123456789101112131415package com.marlowe.factory.method;/** * @program: GoF23 * @description: * @author: Marlowe * @create: 2020-11-20 18:55 **/public class TeslaFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Tesla(); &#125;&#125; 主类 123456789101112131415161718192021package com.marlowe.factory.method;import com.marlowe.factory.simple.CarFactory;/** * @program: GoF23 * @description: 顾客 * @author: Marlowe * @create: 2020-11-20 17:03 **/public class Comsumer &#123; public static void main(String[] args) &#123; Car car1 = new TeslaFactory().getCar(); Car car2 = new BmwFactory().getCar(); Car car3 = new FordFactory().getCar(); car1.name(); car2.name(); car3.name(); &#125;&#125; 1234结果：我是特斯拉！我是宝马！我是福特！ 抽象工厂(Abstract Factory)围绕一个超级工厂创建其他工厂，该工厂又称为其他工厂的工厂 抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类 抽象产品工厂 123456789101112131415161718192021222324package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 抽象产品工厂 * @author: Marlowe * @create: 2020-11-21 10:54 **/public interface IProductFactory &#123; /** * 生产手机 * * @return */ IPhoneProduct iPhoneProduct(); /** * 生产路由器 * * @return */ IRouterProduct iRouterProduct();&#125; 小米工厂 1234567891011121314151617181920package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 小米工厂 * @author: Marlowe * @create: 2020-11-21 10:57 **/public class XiaomiFactory implements IProductFactory &#123; @Override public IPhoneProduct iPhoneProduct() &#123; return new XiaomiPhone(); &#125; @Override public IRouterProduct iRouterProduct() &#123; return new XiaomiRouter(); &#125;&#125; 华为工厂 1234567891011121314151617181920package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 华为工厂 * @author: Marlowe * @create: 2020-11-21 10:57 **/public class HuaweiFactory implements IProductFactory &#123; @Override public IPhoneProduct iPhoneProduct() &#123; return new HuaweiPhone(); &#125; @Override public IRouterProduct iRouterProduct() &#123; return new HuaweiRouter(); &#125;&#125; 手机产品接口 123456789101112131415161718192021222324252627282930package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 手机产品接口 * @author: Marlowe * @create: 2020-11-20 22:38 **/public interface IPhoneProduct &#123; /** * 开机 */ void start(); /** * 关机 */ void shutdown(); /** * 打电话 */ void call(); /** * 发信息 */ void sendMessage();&#125; 以下小米手机和华为手机分别实现手机产品接口 1234567891011121314151617181920212223242526272829303132package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 小米手机 * @author: Marlowe * @create: 2020-11-20 22:41 **/public class XiaomiPhone implements IPhoneProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开小米手机&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭小米手机&quot;); &#125; @Override public void call() &#123; System.out.println(&quot;小米手机打电话&quot;); &#125; @Override public void sendMessage() &#123; System.out.println(&quot;小米手机发信息&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 华为手机 * @author: Marlowe * @create: 2020-11-20 22:44 **/public class HuaweiPhone implements IPhoneProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开华为手机&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭华为手机&quot;); &#125; @Override public void call() &#123; System.out.println(&quot;华为手机打电话&quot;); &#125; @Override public void sendMessage() &#123; System.out.println(&quot;华为手机发信息&quot;); &#125;&#125; 路由器产品接口 123456789101112131415161718192021222324252627282930package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 路由器产品接口 * @author: Marlowe * @create: 2020-11-20 22:40 **/public interface IRouterProduct &#123; /** * 开机 */ void start(); /** * 关机 */ void shutdown(); /** * 打开wifi */ void openWifi(); /** * 设置 */ void setting();&#125; 以下小米路由器和华为路由器分别实现路由器产品接口 12345678910111213141516171819202122232425262728293031package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 小米路由器 * @author: Marlowe * @create: 2020-11-20 22:46 **/public class XiaomiRouter implements IRouterProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开小米路由器&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭小米路由器&quot;); &#125; @Override public void openWifi() &#123; System.out.println(&quot;打开小米路由器wifi&quot;); &#125; @Override public void setting() &#123; System.out.println(&quot;设置小米路由器&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 华为路由器 * @author: Marlowe * @create: 2020-11-20 22:46 **/public class HuaweiRouter implements IRouterProduct &#123; @Override public void start() &#123; System.out.println(&quot;打开华为路由器&quot;); &#125; @Override public void shutdown() &#123; System.out.println(&quot;关闭华为路由器&quot;); &#125; @Override public void openWifi() &#123; System.out.println(&quot;打开华为路由器wifi&quot;); &#125; @Override public void setting() &#123; System.out.println(&quot;设置华为路由器&quot;); &#125;&#125; 主类 12345678910111213141516171819202122232425262728293031package com.marlowe.factory.abstract1;/** * @program: GoF23 * @description: 客户端 * @author: Marlowe * @create: 2020-11-21 11:01 **/public class Client &#123; public static void main(String[] args) &#123; System.out.println(&quot;===============小米系列产品=================&quot;); XiaomiFactory xiaomiFactory = new XiaomiFactory(); IPhoneProduct iPhoneProduct = xiaomiFactory.iPhoneProduct(); iPhoneProduct.call(); iPhoneProduct.sendMessage(); IRouterProduct iRouterProduct = xiaomiFactory.iRouterProduct(); iRouterProduct.openWifi(); System.out.println(); System.out.println(&quot;===============华为系列产品=================&quot;); HuaweiFactory huaweiFactory = new HuaweiFactory(); iPhoneProduct = huaweiFactory.iPhoneProduct(); iPhoneProduct.call(); iPhoneProduct.sendMessage(); IRouterProduct iRouterProduct1 = huaweiFactory.iRouterProduct(); iRouterProduct1.openWifi(); &#125;&#125; 12345678910结果：===============小米系列产品=================小米手机打电话小米手机发信息打开小米路由器wifi===============华为系列产品=================华为手机打电话华为手机发信息打开华为路由器wifi 适用场景： 客户端（应用层）不依赖与产品类实例如何被创建、实现等细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复代码 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现 优点 具体产品在应用层的代码隔离，无需关心创建的细节 将一个系列的产品统一到一起管理 缺点 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难 增加了系统的抽象性和理解难度 小结 简单工厂模式（静态工厂模式）虽然某种程度上不符合设计原则，但实际使用最多！ 工厂方法模式不修改已有类的前提下，通过新增新的工厂类实现扩展。 抽象工厂模式不可以增加产品，可以增加产品族！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://xmmarlowe.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"工厂","slug":"工厂","permalink":"https://xmmarlowe.github.io/tags/%E5%B7%A5%E5%8E%82/"}],"author":"Marlowe"},{"title":"设计模式-模板","slug":"设计模式/设计模式-模板","date":"2020-11-20T07:06:57.000Z","updated":"2020-12-05T04:44:01.103Z","comments":true,"path":"2020/11/20/设计模式/设计模式-模板/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF/","excerpt":"一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。","text":"一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 介绍在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 主要解决了一些方法通用，却在每一个子类都重新写了这一方法。 使用场景： 有多个子类共有的方法，且逻辑相同。 重要的、复杂的方法，可以考虑为模板方法。 优缺点及注意优点 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现。 缺点每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 注意事项为防止恶意操作，一般模板方法都加上 final 关键词。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.marlowe;/** * @program: GoF23 * @description: 模板方法模式 * @author: Marlowe * @create: 2020-11-21 16:11 **/public class TemplateMethodPattern &#123; public static void main(String[] args) &#123; Cooking cooking = new CookingFood(); cooking.cook(); &#125;&#125;/** * 做饭抽象类 */abstract class Cooking &#123; protected abstract void step1(); protected abstract void step2(); /** * 模板方法 */ public final void cook() &#123; System.out.println(&quot;开始做饭:&quot;); step1(); step2(); System.out.println(&quot;做饭结束:&quot;); &#125;&#125;/** * 抽象类的具体实现 */class CookingFood extends Cooking &#123; @Override protected void step1() &#123; System.out.println(&quot;放鸡蛋和西红柿&quot;); &#125; @Override protected void step2() &#123; System.out.println(&quot;少放盐多放味精&quot;); &#125;&#125; 12345结果：开始做饭:放鸡蛋和西红柿少放盐多放味精做饭结束:","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"模板","slug":"模板","permalink":"https://xmmarlowe.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://xmmarlowe.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"author":"Marlowe"},{"title":"对链表进行插入排序","slug":"题解/对链表进行插入排序","date":"2020-11-19T16:37:34.000Z","updated":"2020-12-05T04:44:01.019Z","comments":true,"path":"2020/11/20/题解/对链表进行插入排序/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/20/%E9%A2%98%E8%A7%A3/%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"147. 对链表进行插入排序对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 分析由gif可以看出，链表在插入排序过程中由排序好的部分和当前节点以及后面的节点组成，因此可以去排序好部分的下一个元素作为当前待排序节点，当当前节点为null时，所有节点排序结束。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; // 如果头节点为空，直接返回 if(head == null)&#123; return head; &#125; // 新建哑节点，保存头结点信息 ListNode dummy = new ListNode(0); dummy.next = head; // 排序好部分最后一个元素 ListNode lastSorted = head; // 当前节点（待排序元素） ListNode curr = head.next; while(curr != null)&#123; // 如果当前元素不用排序，将排序链表增长，也即lastSorted后移 if(lastSorted.val &lt;= curr.val)&#123; lastSorted = lastSorted.next; &#125;else&#123; // 从头结点开始找，pre保存前一个元素 ListNode pre = dummy; while(pre.next.val &lt;= curr.val)&#123; pre = pre.next; &#125; // 将curr节点插入到对应位置 lastSorted.next = curr.next; curr.next = pre.next; pre.next = curr; &#125; // 更新当前节点为排序好链表下一个节点 curr = lastSorted.next; &#125; return dummy.next; &#125;&#125;","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xmmarlowe.github.io/tags/java/"},{"name":"链表","slug":"链表","permalink":"https://xmmarlowe.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"插入排序","slug":"插入排序","permalink":"https://xmmarlowe.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"author":"Marlowe"},{"title":"设计模式-外观","slug":"设计模式/设计模式-外观","date":"2020-11-18T14:05:41.000Z","updated":"2020-12-05T04:44:01.066Z","comments":true,"path":"2020/11/18/设计模式/设计模式-外观/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82/","excerpt":"要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易使用。","text":"要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易使用。 介绍外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。传统模式 外观模式 优缺点及注意优点 为复杂的模块或子系统提供外界访问的模块。 子系统相对独立。 预防低水平人员带来的风险。 缺点 不符合开闭原则。所谓的开闭原则是软件工程里面一个最基本的原则：对扩展开放，对修改关闭。换句话说，你的系统可以提供新的功能模块而不必进行修改。 注意事项在层次化结构中，可以使用外观模式定义系统中每一层的入口。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243package com.marlowe;/** * @program: GoF23 * @description: 外观模式 * @author: Marlowe * @create: 2020-11-21 17:04 **/public class FacadePattern &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); System.out.println(facade.prove()); &#125;&#125;class SubFlow1 &#123; boolean isTrue() &#123; return true; &#125;&#125;class SubFlow2 &#123; boolean isOk() &#123; return true; &#125;&#125;class SubFlow3 &#123; boolean isGoodMan() &#123; return true; &#125;&#125;class Facade &#123; SubFlow1 subFlow1 = new SubFlow1(); SubFlow2 subFlow2 = new SubFlow2(); SubFlow3 subFlow3 = new SubFlow3(); boolean prove() &#123; return subFlow1.isTrue() &amp;&amp; subFlow2.isOk() &amp;&amp; subFlow3.isGoodMan(); &#125;&#125; 12结果：true","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xmmarlowe.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"外观","slug":"外观","permalink":"https://xmmarlowe.github.io/tags/%E5%A4%96%E8%A7%82/"}],"author":"Marlowe"},{"title":"DockerFile","slug":"Docker/DockerFile","date":"2020-11-16T17:06:17.000Z","updated":"2020-12-05T04:44:00.874Z","comments":true,"path":"2020/11/17/Docker/DockerFile/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/17/Docker/DockerFile/","excerpt":"","text":"dockerfile 是用来构建docker镜像的文件！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xmmarlowe.github.io/tags/Docker/"}],"author":"Marlowe"},{"title":"容器数据卷","slug":"Docker/容器数据卷","date":"2020-11-16T12:10:54.000Z","updated":"2020-12-05T04:44:00.882Z","comments":true,"path":"2020/11/16/Docker/容器数据卷/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/16/Docker/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/","excerpt":"","text":"什么是容器数据卷docker的理念回顾将应用和环境打包成一个镜像！数据？如果数据都在容器中，那么容器一删除，数据就会丢失！==需求：数据可以持久化==MySQL，容器删了，删库跑路！==需求：MySQL数据可以存储在本地！==容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！总结一句话：容器的持久化和同步操作！容器建也是可以数据共享的！ 使用数据卷 方式一：直接使用命令来挂载 -v 123456docker run -it -v 主机目录：容器内目录# 测试[root@hecs-x-large-2-linux-20200425095544 home]# docker run -it -v /home/ceshi:/home centos /bin/bash# 启动起来的时候我们可以通过docker inspect 容器id 测试：1、停止容器2、宿主机上修改文件3、启动容器4、容器内的数据依旧是同步的！好处：我们以后修改只需要在本地修改即可，容器内会自动同步！ 实战：安装MySQL思考：MySQL的数据持久化问题！ 123456789101112131415161718# 获取镜像[root@hecs-x-large-2-linux-20200425095544 home]# docker pull mysql:5.7# 运行容器，需要做数据挂载！ # 安装启动mysql，需要配置密码的，这是注意点# 官当测试： docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# 启动我们的-d 后台运行-p 端口映射-v 卷挂载-e 环境配置--name 容器名字[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7# 启动成功之后，我们在本地使用navcat来连接测试一下# navcat-连接到服务器的3310 ----3310和容器内的3306映射，这个时候我们就可以连接上了！# 在本地测试创建一个数据库，查看一下我们的映射路径是否ok！ 加入我们将容器删除发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能！ 具名和匿名挂载12345678910111213141516171819# 匿名挂载-v 容器内路径！docker run -d -P --name nginx01 -v /etc/nginx nginx# 查看所有的 volume 的情况[root@hecs-x-large-2-linux-20200425095544 ~]# docker volume lsDRIVER VOLUME NAMElocal 7be1d9b8c43e3b6bedc76ab75894eb8b8a8423e83ef2c4e9cf8b4a22ee4d9f2b# 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内路径，没有写容器外路径！# 具名挂载[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx nginx86efd65c8724a4485ae7bb75b75ec8ed62a225cb33d0c75ed1b6b3652500f5e9[root@hecs-x-large-2-linux-20200425095544 ~]# docker volume lslocal juming-nginx# 通过 -v 卷名：容器内路径# 查看一下这个卷 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volume/xxx/_data我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的具名挂载 1234如何确定是具名挂载还是匿名挂载，还是指定路径挂载！-v 容器内路径 # 匿名挂载-v 卷名：容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载！ 拓展： 123456789# 通过 -v 容器内路径：ro rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写# 一旦这个设置了容器权限。容器对我们挂载出来的内容就限定了！docker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx03 -v juming-nginx:/etc/nginx:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！ 初识DockerfileDockerfile就是用来构建docker镜像的构建文件！ 命令脚本！先体验一下！通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！ 1234567891011# 创建一个dockerfile文件，名字可以随机 建议Dockerfile# 文件中的内容 指令(大写) 参数FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;---end---&quot;CMD /bin/bash# 这里的每个命令，就是镜像的一层！ 1# 启动自己写的容器 这个卷和外部一定有一个同步的目录！ 这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像！假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名:容器内路径！ 数据卷容器多个mysql同步数据！ 123# 测试：可以删除docker01，查看一下docker02和docker03是否还可以访问这个文件# 测试依旧可以访问(拷贝的概念) 多个mysql实现数据共享 12345[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root --name mysql02 --volumes-form mysql01 mysql:5.7# 这个时候，可以实现两个容器数据同步！ 结论：容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦持久到了本地，这个时候，本地的数据是不会删除的！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xmmarlowe.github.io/tags/Docker/"}],"author":"Marlowe"},{"title":"Docker镜像讲解","slug":"Docker/Docker镜像讲解","date":"2020-11-16T11:46:45.000Z","updated":"2020-12-05T04:44:00.878Z","comments":true,"path":"2020/11/16/Docker/Docker镜像讲解/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/16/Docker/Docker%E9%95%9C%E5%83%8F%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"如何提交一个自己的镜像 commit镜像1234docker commit 提交容器成为一个新的副本# 命令和git原理类似docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名：[TAG] 实战测试 1234567891011# 1、启动一个默认的tomcat[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -it -p 8080:8080 tomcat# 2、发现这个默认的tomcat是没有webapps应用，镜像的原因，官方的镜像默认webapps下面是没有文件的！# 3、我自己拷贝进去了基本的文件root@186285ef065e:/usr/local/tomcat# cp -r webapps.dist/* webapps# 4、将我们操作过的容器通过commit提交为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像[root@hecs-x-large-2-linux-20200425095544 ~]# docker commit -a=&quot;marlowe&quot; -m=&quot;add web app&quot; 186285ef065e tomcat02:1.0 1如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比以前学习VM的时候，快照！ 到这里才算是入门Docker！","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xmmarlowe.github.io/tags/Docker/"}],"author":"Marlowe"},{"title":"Docker常用命令","slug":"Docker/Docker常用命令","date":"2020-11-11T08:16:31.000Z","updated":"2020-12-05T04:44:01.217Z","comments":true,"path":"2020/11/11/Docker/Docker常用命令/","link":"","permalink":"https://xmmarlowe.github.io/2020/11/11/Docker/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"帮助命令123docker version # 显示docker的版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help # 帮助命令 帮助文档地址：https://docs.docker.com/reference/ 镜像命令docker images 查看所有本地的主机上的镜像 123456789[root@hecs-x-large-2-linux-20200425095544 home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 8.0 db2b37ec6181 2 weeks ago 545MBmysql latest db2b37ec6181 2 weeks ago 545MBhello-world latest bf756fb1ae65 10 months ago 13.3kB# 可选项 -a，--all # 列出所有的镜像 -q，--quiet # 只显示镜像的id docker search 搜索镜像 12345678910[root@hecs-x-large-2-linux-20200425095544 home]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL mysql MySQL is a widely used, open-source relation… 10148 [OK] # 可选项，通过收藏来过滤--filter=STARS=3000 # 搜索出来的镜像就是STARS大于3000的[root@hecs-x-large-2-linux-20200425095544 home]# docker search mysql --filter=stars=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10148 [OK] mariadb MariaDB is a community-developed fork of MyS… 3737 [OK] docker pull 下载镜像 12345678910111213141516171819202122# 下载镜像 docker pull 镜像名[:tag][root@hecs-x-large-2-linux-20200425095544 ~]# docker pull mysql:8.08.0: Pulling from library/mysql # 如果不写tag，默认就是latestbb79b6b2107f: Pull complete 49e22f6fb9f7: Pull complete 842b1255668c: Pull complete 9f48d1f43000: Pull complete c693f0615bce: Pull complete 8a621b9dbed2: Pull complete 0807d32aef13: Pull complete a56aca0feb17: Pull complete de9d45fd0f07: Pull complete 1d68a49161cc: Pull complete d16d318b774e: Pull complete 49e112c55976: Pull complete Digest: sha256:8c17271df53ee3b843d6e16d46cff13f22c9c04d6982eb15a9a47bd5c9ac7e2d # 签名Status: Downloaded newer image for mysql:8.0docker.io/library/mysql:8.0 # 真实地址# 等价于它docker pull mysqldocker pull docker.io/library/mysql:8.0 docker rmi 删除镜像 123[root@hecs-x-large-2-linux-20200425095544 ~]# docker rmi -f 镜像id # 删除指定的镜像[root@hecs-x-large-2-linux-20200425095544 ~]# docker rmi -f 镜像id 镜像id # 删除多个镜像[root@hecs-x-large-2-linux-20200425095544 ~]# docker rmi -f $(docker images -aq) # 删除全部的镜像 容器命令说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习 1docker pull centos 新建容器并启动 123456789101112131415161718192021222324docker run[可选参数] image# 参数说明--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p 指定容器的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口（常用） -p 容器端口 容器端口-P 随机指定端口# 测试，启动并进入容器[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -it centos /bin/bash[root@9b4676b718b5 /]# ls # 查看容器内的centos，基础版本，很多命令都是不完善的！bin etc lib lost+found mnt proc run srv tmp vardev home lib64 media opt root sbin sys usr# 从容器中退回主机[root@9b4676b718b5 /]# exitexit[root@hecs-x-large-2-linux-20200425095544 ~]# lsinstall.sh 列出所有运行的容器 123456789101112# docker ps 命令 # 列出当前正在运行的容器-a # 列出当前正在运行的容器 + 带出历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号[root@hecs-x-large-2-linux-20200425095544 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@hecs-x-large-2-linux-20200425095544 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9b4676b718b5 centos &quot;/bin/bash&quot; 26 minutes ago Exited (0) 16 minutes ago festive_feistelc8c1137aaa4e bf756fb1ae65 &quot;/hello&quot; 5 hours ago Exited (0) 5 hours ago confident_cannon 退出容器 12345exit # 容器停止并退出Ctrl + P + Q # 容器不停止退出[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -it centos /bin/bash[root@9d6ac1f17089 /]# [root@hecs-x-large-2-linux-20200425095544 ~]# 删除容器 123docker rm 容器id # 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f docker rm -f $(docker ps -aq) # 删除所有的容器docker ps -a -q|xargs docker rm # 删除所有的容器，使用管道 启动和容器的操作 1234docker start 容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止当前正在运行的容器docker kill 容器id # 强制停止当前容器 常用其他命令 后台启动容器 1234567# 命令 docker run -d 镜像名：[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d centos# 问题docker ps，发现 centos停止了# 常见的坑！！ docker容器使用后台运行，就唏嘘有一个前台进程，docker发现没有应用，就自动停止# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了 查看日志 12345678910111213 docker logs -f -t --tail 容器id ,没有日志 # 自己编写一段shell脚本 [root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d centos /bin/bash -c &quot;while true;do echo kuangshen; sleep 1;done&quot;[root@hecs-x-large-2-linux-20200425095544 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESaadc743a101c centos &quot;/bin/bash -c &#x27;while…&quot; 4 seconds ago Up 3 seconds tender_moser # 显示日志 -tf # 显示日志 -tail number # 要显示日志条数 [root@hecs-x-large-2-linux-20200425095544 ~]# docker logs -tf --tail 10 284eaba4616b 查看容器中进程信息 ps 12345# 命令 docker top 容器id [root@hecs-x-large-2-linux-20200425095544 ~]# docker top 284eaba4616bUID PID PPID C STIME TTY TIME CMDroot 15211 15194 0 18:31 ? 00:00:00 /bin/bash -c while true;do echo kuangshen; sleep 1;doneroot 15918 15211 0 18:37 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211# 命令docker inspect 容器id# 测试[root@hecs-x-large-2-linux-20200425095544 ~]# docker inspect 284eaba4616b[ &#123; &quot;Id&quot;: &quot;284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6&quot;, &quot;Created&quot;: &quot;2020-11-12T10:31:46.264703694Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo kuangshen; sleep 1;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 15211, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2020-11-12T10:31:46.559658378Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6/284eaba4616b4e748dc87a6aedf14d3b7bb508ef28d77cf215f01677a9149ae6-json.log&quot;, &quot;Name&quot;: &quot;/dazzling_roentgen&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;Capabilities&quot;: null, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a-init/diff:/var/lib/docker/overlay2/ab2394ffb62a3a589a4794ed317cdec52ff1b73d6c0025a32b56cfa266fe4d97/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/9f2dc5029ecc2e3355d547bc678a613bc9fcaf84e23692e9ae8d36b010c2392a/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;284eaba4616b&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;while true;do echo kuangshen; sleep 1;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20200809&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;da70a9e57940a409d3f4827907ee892aa3a9a20aa2575fbeffd380cedfc6b03a&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/da70a9e57940&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;9e9c2139cd06d068313f00e7e7ec3bf9411a3344792d962fffecd4324d1ff87a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;7a8c920abbd19ce06b9315879005e6d73adea85afc13f16ca1bd88c49bf5694b&quot;, &quot;EndpointID&quot;: &quot;9e9c2139cd06d068313f00e7e7ec3bf9411a3344792d962fffecd4324d1ff87a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819202122# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置# 命令 docker exec -it 容器id bashShell# 测试[root@hecs-x-large-2-linux-20200425095544 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 6 hours ago Up 6 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql[root@hecs-x-large-2-linux-20200425095544 ~]# docker exec -it e60fd257e7cf /bin/bashroot@e60fd257e7cf:/# lsbin docker-entrypoint-initdb.d home media proc sbin tmpboot entrypoint.sh lib mnt root srv usrdev etc lib64 opt run sys varroot@e60fd257e7cf:/# ps -ef# 方式2 docker attach 容器id# docker exec # 进入容器后开启一个新的终端，可以在里面操作（常用）# docker attach # 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到主机上 12345678910111213141516171819202122232425262728293031docker cp 容器id：容器内路径 目的的主机路径# 查看当前主机目录下[root@hecs-x-large-2-linux-20200425095544 home]# lschn hello.java hh leo Marlowe www[root@hecs-x-large-2-linux-20200425095544 home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES37b64bd24047 centos &quot;/bin/bash&quot; About a minute ago Up About a minute funny_williamse60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql# 进入docker容器内部[root@hecs-x-large-2-linux-20200425095544 home]# docker attach 37b64bd24047[root@37b64bd24047 /]# cd /home[root@37b64bd24047 home]# ls# 在容器内新建一个文件[root@37b64bd24047 home]# touch test.java[root@37b64bd24047 home]# lstest.java[root@37b64bd24047 home]# exitexit[root@hecs-x-large-2-linux-20200425095544 home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql# 将这文件拷贝出来到主机上[root@hecs-x-large-2-linux-20200425095544 home]# docker cp 37b64bd24047:/home/test.java /home [root@hecs-x-large-2-linux-20200425095544 home]# lschn hello.java hh leo Marlowe test.java www# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现，自动同步 /home /home Docker 安装nginx 123456789101112131415161718192021# 1.搜索镜像 search 建议大家去docker搜素，可以看帮助文档# 2.下载镜像 pull# 3.运行测试[root@hecs-x-large-2-linux-20200425095544 home]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest c39a868aad02 7 days ago 133MBmysql 8.0 db2b37ec6181 2 weeks ago 545MBmysql latest db2b37ec6181 2 weeks ago 545MBcentos latest 0d120b6ccaa8 3 months ago 215MB# -d后台运行# --name 给容器命名# -p 宿主机端口，容器内部端口[root@hecs-x-large-2-linux-20200425095544 home]# docker run -d --name nginx01 -p 3344:80 nginx100d4c411f6d16c5ff4e630f521f59448d065cb2b201bd0b3a1ea6840045e955[root@hecs-x-large-2-linux-20200425095544 home]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES100d4c411f6d nginx &quot;/docker-entrypoint.…&quot; 8 seconds ago Up 7 seconds 0.0.0.0:3344-&gt;80/tcp nginx01e60fd257e7cf mysql:8.0 &quot;docker-entrypoint.s…&quot; 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-&gt;3306/tcp mysql[root@hecs-x-large-2-linux-20200425095544 home]# curl localhost:3344 作业练习 Docker 安装 Nginx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 1.搜索镜像 search 建议去docker搜索，可以看到帮助文档# 2.下载镜像 pull# 3.运行测试[root@hecs-x-large-2-linux-20200425095544 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest c39a868aad02 9 days ago 133MBmysql 8.0 db2b37ec6181 3 weeks ago 545MBmysql latest db2b37ec6181 3 weeks ago 545MBcentos latest 0d120b6ccaa8 3 months ago 215MB# -d 后台运行# --name 容器命名# -p 宿主机端口：容器内端口[root@hecs-x-large-2-linux-20200425095544 ~]# docker run -d --name nginx01 -p 3344:80 nginx[root@hecs-x-large-2-linux-20200425095544 ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;# 进入容器[root@hecs-x-large-2-linux-20200425095544 ~]# docker exec -it nginx01 /bin/bashroot@100d4c411f6d:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx 思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？ -v 数据卷！ 作业2：docker装tomcat 123456789101112131415161718# 官方安装docker run -it --rm tomcat:9.0# 我们之前的启动都是后台，停止了容器之后，容器还是可以查到， docker run -it --rm 一般用来测试，用完就删除# 下载再启用docker pull tomcat# 启动运行docker run -d -p 3355:8080 --name tomcat01 tomcat# 测试访问没有问题# 进入容器[root@hecs-x-large-2-linux-20200425095544 ~]# docker exec -it tomcat01 /bin/bash# 发现问题：1.linux命令少了，2.没有webapps，阿里云镜像的原因，默认是最小的镜像，左右不必要的都删除掉。# 保证最小可运行的环境！ 思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外提供一个映射路径，webapps，我们在外部放置项目，就自动同步到内部就好了！ 作业：部署es+kibana 123456789101112131415161718192021222324252627282930313233# es 暴露的端口很多# es 十分的耗内存# es的数据一般需要放置到安全目录！ 挂载# --net somenetwork ？ 网络配置# 下载启动docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2# 启动后非常卡 linux卡住了，docker status 查看cpu状态# es十分耗内存；# 查看 docker stats# 测试es是否成功了[root@hecs-x-large-2-linux-20200425095544 ~]# curl localhost:9200&#123; &quot;name&quot; : &quot;6e4e7e14f10d&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;C4GbFU9pQ7m0WT6ko_pkJA&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 12# 增加内存限制，修改配置文件 -e 环境配置修改docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2 作业：使用kibana连接es？思考网络如何才能连接过去！ 可视化 portainer(先用这个)1docker run -d -p 8088:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer Rancher(CI/CD再用) 什么是portainer？Docker图形化界面管理工具！提供一个后台面板供我们操作！ 1docker run -d -p 8088:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xmmarlowe.github.io/tags/Docker/"}],"author":"Marlowe"},{"title":"二叉树的前中后序非递归遍历算法","slug":"题解/二叉树的前中后序非递归遍历算法","date":"2020-10-12T14:01:09.000Z","updated":"2020-12-05T04:44:01.014Z","comments":true,"path":"2020/10/12/题解/二叉树的前中后序非递归遍历算法/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/%E9%A2%98%E8%A7%A3/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"二叉树的前中后序非递归遍历算法学过数据结构的同学都知道二叉树的深度优先遍历算法有三种，前序，中序，后序遍历。 前序：根–&gt;左–&gt;右 中序：左–&gt;根–&gt;右 后序：左–&gt;右–&gt;根 不难发现，后序遍历和前序遍历有相似的地方，如果我们将后序遍历变成根右左的顺序，将结果集翻转后就会变成前序的根左右顺序。 前中后序非递归遍历的核心算法：前序遍历：123456789101112while(root != null || !stack.isEmpty())&#123; // 一直往左边走 while(root != null)&#123; res.add(root.val); stack.push(root); root = root.left; &#125; // 开始回退 TreeNode cur = stack.pop(); // 往右边走 root = cur.right;&#125; 后序遍历：123456789101112131415while(root != null || !stack.isEmpty())&#123; // 一直往右边走 while(root != null)&#123; res.add(root.val); stack.push(root); root = root.right; &#125; // 开始回退 TreeNode cur = stack.pop(); // 往左边走 root = cur.left; // 反转，使变成后序遍历 Collections.reverse(res);&#125; 中序遍历：12345678910111213while(root != null || !stack.isEmpty())&#123; // 碰到根节点，压栈 while(root != null)&#123; stack.push(root); // 往左边走 root = root.left; &#125; // 开始回退 root = stack.pop(); res.add(root.val); // 往右边走 root = root.right;&#125; 前中后序递归遍历的核心算法：前序遍历：1234567public void dfs(TreeNode root)&#123; while(root != null)&#123; res.add(root.val); dfs(root.left); dfs(root.right); &#125;&#125; 中序遍历：1234567public void dfs(TreeNode root)&#123; while(root != null)&#123; dfs(root.left); res.add(root.val); dfs(root.right); &#125;&#125; 后序遍历：1234567public void dfs(TreeNode root)&#123; while(root != null)&#123; dfs(root.left); dfs(root.right); res.add(root.val); &#125;&#125;","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://xmmarlowe.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"Marlowe"},{"title":"Map集合的统计每个字符出现次数的两种方法","slug":"题解/Map集合的统计每个字符出现次数的两种方法","date":"2020-10-12T13:53:51.000Z","updated":"2020-12-05T04:44:00.949Z","comments":true,"path":"2020/10/12/题解/Map集合的统计每个字符出现次数的两种方法/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/%E9%A2%98%E8%A7%A3/Map%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"Map集合的统计每个字符出现次数的两种方法一、map.containsKey()方法Map可以出现在k与v的映射中，v为null的情况。Map集合允许值对象为null，并且没有个数限制，所以当get()方法的返回值为null时，可能有两种情况，一种是在集合中没有该键对象，另一种是该键对象没有映射任何值对象，即值对象为null。因此，在Map集合中不应该利用get()方法来判断是否存在某个键，而应该利用containsKey()方法来判断。 1234567891011121314151617/** * map.containsKey()方法 * * @param nums */ public static void test1(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; if (!cnt.containsKey(num)) &#123; cnt.put(num, 1); &#125; else &#123; cnt.put(num, cnt.get(num) + 1); &#125; &#125; // 遍历HashMap pnt(cnt); &#125; 1234567原始数组：int[] nums &#x3D; new int[]&#123;1, 2, 2, 3, 5, 5, 5, 9, 1, 1&#125;;结果： 1出现的次数：3 2出现的次数：2 3出现的次数：1 5出现的次数：3 9出现的次数：1 二、map.getOrDefault()方法 当Map集合中有这个key时，就使用这个key值，如果没有就使用默认值defaultValue 。 12345678910111213/** * map.getOrDefault()方法 * * @param nums */ public static void test2(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; cnt.put(num, cnt.getOrDefault(num, 0) + 1); &#125; // 遍历HashMap pnt(cnt); &#125; 1234567原始数组：int[] nums = new int[]&#123;1, 2, 2, 3, 5, 5, 5, 9, 1, 1&#125;;结果： 1出现的次数：3 2出现的次数：2 3出现的次数：1 5出现的次数：3 9出现的次数：1 三、demo源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.HashMap;import java.util.Map;/** * @program: leecode1 * @description: * @author: Marlowe * @create: 2020-09-07 15:28 **/public class map集合统计每个字符出现的次数 &#123; public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 2, 3, 5, 5, 5, 9, 1, 1&#125;; test1(nums); test2(nums); &#125; /** * map.containsKey()方法 * * @param nums */ public static void test1(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; if (!cnt.containsKey(num)) &#123; cnt.put(num, 1); &#125; else &#123; cnt.put(num, cnt.get(num) + 1); &#125; &#125; pnt(cnt); &#125; /** * map.getOrDefault()方法 * * @param nums */ public static void test2(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;(); for (int num : nums) &#123; cnt.put(num, cnt.getOrDefault(num, 0) + 1); &#125; pnt(cnt); &#125; /** * 遍历HashMap */ public static void pnt(HashMap&lt;Integer, Integer&gt; map) &#123; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; int num = entry.getKey(); int count = entry.getValue(); System.out.println(num + &quot;出现的次数：&quot; + count); &#125; &#125;&#125;","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"}],"author":"Marlowe"},{"title":"Leetcode组合总和1-4题题解","slug":"题解/Leetcode组合总和1-4题题解","date":"2020-10-12T13:52:22.000Z","updated":"2020-12-05T04:44:00.946Z","comments":true,"path":"2020/10/12/题解/Leetcode组合总和1-4题题解/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/%E9%A2%98%E8%A7%A3/Leetcode%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C1-4%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"","text":"Leetcode组合总和1-4题题解Leecode最近几天的每日一题都是组合总和问题，预测明天是组合总和Ⅳ，因此，提前将组合总和的所有题目刷了，前三题的思路都差不多，最后一题做法有所不同： 组合总和：candidates 中的数字可以无限制重复被选取。 组合总和Ⅱ： candidates 中的每个数字在每个组合中只能使用一次。 组合总和Ⅲ：组合中只允许有1-9的数字，并且每种组合中不存在重复的数字。 组合总和Ⅳ：找出符合要求组合的个数。 39. 组合总和给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1： 123456输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,所求解集为：[ [7], [2,2,3]] 示例 2： 1234567输入：candidates &#x3D; [2,3,5], target &#x3D; 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 提示： 1 &lt;= candidates.length &lt;= 30 1 &lt;= candidates[i] &lt;= 200 candidate 中的每个元素都是独一无二的。 1 &lt;= target &lt;= 500 题解（dfs，回溯算法）分析：此类问题可以画出树形图，然后就会发现此题可以用dfs+回溯算法解决，用到的数据结构为双端队列，具有栈和队列的性质，其定义方式为：Deque stack = new ArrayDeque();具体步骤见代码。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; // 保存结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 获取数组的长度 int len = candidates.length; //如果数组为空，直接返回空集合 if(len == 0)&#123; return res; &#125; // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历求所有结果集 dfs(candidates,0,len,target,path,res); return res; &#125; public void dfs(int[] candidates,int start,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果选多了，也即target &lt; 0,直接return if(target &lt; 0)&#123; return; &#125; // 找到一条路径 if(target == 0)&#123; // 将路径加入结果集 res.add(new ArrayList(path)); &#125; // 从下标为start的数开始寻找 for(int i = start; i &lt; len; i++)&#123; // 将当前元素入栈 path.addLast(candidates[i]); // 由于可以选择重复的元素，因此i不变，但是选择了东西，target对应减少 dfs(candidates,i,len,target - candidates[i],path,res); // 回到之前的状态 path.removeLast(); &#125; &#125;&#125; 40. 组合总和 II给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 12345678输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 123456输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,所求解集为:[ [1,2,2], [5]] 题解（dfs，回溯算法，哈希表）分析：此题和组合总和的区别在于 candidates 中的每个数字在每个组合中只能使用一次，并且解集不能包含重复的元素，因此可用哈希表对重复解集去重，具体步骤看下方代码注释。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; // 将原始数组排序 Arrays.sort(candidates); // 获取数组长度 int len = candidates.length; // 结果集列表 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历 + 回溯 dfs(candidates,0,len,target,path,res); // 去重，因为解集不能有重复元素 HashSet&lt;List&lt;Integer&gt;&gt; set = new HashSet(); for(List&lt;Integer&gt; list : res)&#123; set.add(list); &#125; // 将HashSet转换为List集合 return new ArrayList(set); &#125; public void dfs(int[] candidates,int start,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果选多了，也即target &lt; 0,直接return if(target &lt; 0)&#123; return; &#125; // 找到一条路径 if(target == 0)&#123; // 将路径加入结果集 res.add(new ArrayList(path)); &#125; for(int i = start; i &lt; len; i++)&#123; // 将当前元素入栈 path.addLast(candidates[i]); // 由于数组中的元素只能用一次，因此i + 1,并且target减少 dfs(candidates,i+1,len,target - candidates[i],path,res); // 回到之前的状态 path.removeLast(); &#125; &#125;&#125; 216. 组合总和 III 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 12输入: k &#x3D; 3, n &#x3D; 7输出: [[1,2,4]] 示例 2: 12输入: k &#x3D; 3, n &#x3D; 9输出: [[1,2,6], [1,3,5], [2,3,4]] 题解（dfs，回溯算法）分析：此题和组合总和Ⅱ的区别在于在1-9中选择数据,并且每个数据只能选一次，且只需返回长度为k的路径,因此需对结果集进行筛选，具体步骤看下方代码注释。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; // 手动将1-9加入数组arr中 int[] arr = new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; // 初始结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 最终结果集 List&lt;List&lt;Integer&gt;&gt; res1 = new ArrayList(); // 临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历求出所有解集 dfs(arr,0,n,path,res); // 选出符合长度为k的解集 for(List&lt;Integer&gt; list : res)&#123; if(list.size() == k)&#123; res1.add(list); &#125; &#125; return res1; &#125; public void dfs(int[] arr,int start,int n ,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果选多了，也即n &lt; 0,直接return if(n &lt; 0)&#123; return; &#125; // 找到一条路径 if(n == 0)&#123; // 将路径加入结果集 res.add(new ArrayList(path)); &#125; for(int i = start; i &lt; 9; i++)&#123; // 将当前元素入栈 path.addLast(arr[i]); // 由于数组中的元素只能用一次，因此i + 1,并且n减少 dfs(arr,i + 1,n - arr[i],path,res); // 回到之前的状态 path.removeLast(); &#125; &#125;&#125; 377. 组合总和 Ⅳ给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: 12345678910111213141516nums &#x3D; [1, 2, 3]target &#x3D; 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶：如果给定的数组中含有负数会怎么样？问题会产生什么变化？我们需要在题目中添加什么限制来允许负数的出现？ 题解（1.dfs,回溯算法 2.动态规划）分析：此题和组合总和类似，区别在于求出所有解集后，还需求出解集的全排列，并返回全排列的个数。 组合总数前三题都是同样的套路，只是在结果处理以及中间过程有略微差别，但是这题不同的是要求结果集的全排列，因此，我就想用第一题的算法 + 全排列算法求出此题，代码如demo1，结果超时，代码逻辑是没有问题的，但题目所给数据过大，导致算全排列的时候使用过多时间，因此未通过。 查看题解，发现正确的解法为动态规划，根据分析可以得到状态转移方程： dp[i] = dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]]...... 例如nums = [1,3,4],target = 7; dp[7] = dp[6] + dp[4] + dp[3]; 具体代码见demo2 具体步骤如下：demo1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; Arrays.sort(nums); int sum = 0; // 保存结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 获取数组的长度 int len = nums.length; // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 深度优先遍历求所有结果集 dfs(nums,0,len,target,path,res); // 求出解集中的所有情况 for(List&lt;Integer&gt; list : res)&#123; sum += isok(list); &#125; return sum; &#125; // 求出所有解集 public void dfs(int[] nums,int start,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(target &lt; 0)&#123; return; &#125; if(target == 0)&#123; res.add(new ArrayList(path)); &#125; for(int i = start; i &lt; len; i++)&#123; path.addLast(nums[i]); // 可以重复使用，因此i不用+1 dfs(nums,i,len,target - nums[i],path,res); path.removeLast(); &#125; &#125; // 求出列表的所有组合情况 public int isok(List&lt;Integer&gt; list)&#123; int[] nums = new int[list.size()]; for(int i = 0 ; i &lt; nums.length; i++)&#123; nums[i] = list.get(i); &#125; int len = nums.length; Deque&lt;Integer&gt; path = new ArrayDeque(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 布尔数组，用于标记改数是否使用过 boolean[] used = new boolean[len]; dfs2(nums,len,0,used,path,res); return res.size(); &#125; // 求全排列 public void dfs2(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(depth == len)&#123; res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; if(used[i])&#123; continue; &#125; // 因为有重复元素，所以在下一层碰到相同元素会使结果重复，相对于全排列，进一步剪枝 if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])&#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs2(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; demo2 123456789101112131415class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp = new int[target + 1]; dp[0] = 1; for(int i = 0; i &lt;= target; i++)&#123; for(int num : nums)&#123; if(num &lt;= i)&#123; dp[i] += dp[i - num]; &#125; &#125; &#125; return dp[target]; &#125;&#125; :smile:以上题解仅限于个人理解，如有更好的方法或者更高效的解法，请移步至评论区，谢谢！","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xmmarlowe.github.io/tags/Leetcode/"}],"author":"Marlowe"},{"title":"Leetcode全排列1-2题题解","slug":"题解/Leetcode全排列1-2题题解","date":"2020-10-12T13:49:35.000Z","updated":"2020-12-05T04:44:00.939Z","comments":true,"path":"2020/10/12/题解/Leetcode全排列1-2题题解/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/%E9%A2%98%E8%A7%A3/Leetcode%E5%85%A8%E6%8E%92%E5%88%971-2%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"","text":"Leetcode全排列1-2题题解对于全排列问题，可能我们很多人从小在数学课上都做过，并且都能由一定的规律将所有排列情况写出来，但如何用编码的方式求解此类问题成了我的问题，或许也成是你们还未解决的问题，其实这类问题的套路都是 dfs + 回溯算法，然后，根据题目要求进行剪枝，我将通过下面两题来讲解这类问题具体做法。 46. 全排列给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 题解（dfs，回溯算法）分析：由于是回溯算法，因此，会用到栈，通常我们所学的栈是这种用法 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();,但在Stack的源码中发现了Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();这种用法，百度之后，知道了Deque : （double-ended queue，双端队列）是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，相比list增加运算符重载。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 数组长度 int len = nums.length; // 结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 布尔数组，保存改数字是否使用过 boolean[] used = new boolean[len]; // 深度优先遍历求所有结果集 dfs(nums,len,0,used,path,res); return res; &#125; public void dfs(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果到达最深的一层 if(depth == len)&#123; // 将当前路径加入结果集 res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; // 判断当前数字是否用过 if(used[i])&#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; 47. 全排列 II给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 题解（dfs，回溯算法）分析：此题和全排列解法类似，唯一的差别在于可选数组nums中存在重复的数字，可能会产生重复的路径，因此，需要在判断当前数字是否用过后，再次判断上一次使用的数字和当前数字是否相同，如果相同，进行剪枝，具体差别见代码。 具体步骤如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; // 数组长度 int len = nums.length; // 对数组排序 Arrays.sort(nums); // 结果集 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 双端队列，保存临时路径 Deque&lt;Integer&gt; path = new ArrayDeque(); // 布尔数组，保存改数字是否使用过 boolean[] used = new boolean[len]; // 深度优先遍历求所有结果集 dfs(nums,len,0,used,path,res); return res; &#125; public void dfs(int[] nums,int len,int depth,boolean[] used,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; // 如果到达最深的一层 if(depth == len)&#123; // 将当前路径加入结果集 res.add(new ArrayList(path)); return; &#125; for(int i = 0 ; i &lt; len; i++)&#123; // 判断当前数字是否用过 if(used[i])&#123; continue; &#125; // 因为有重复元素，所以在下一层碰到相同元素会使结果重复，相对于全排列，进一步剪枝 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123; continue; &#125; // 回溯算法经典步骤 // 先将当前数字加入栈，并将使用过的元素标记为true path.addLast(nums[i]); used[i] = true; dfs(nums,len,depth + 1,used,path,res); // 回到之前的状态 path.removeLast(); used[i] = false; &#125; &#125;&#125; :smile:以上题解仅限于个人理解，如有更好的方法或者更高效的解法，请移步至评论区，谢谢！","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xmmarlowe.github.io/tags/Leetcode/"}],"author":"Marlowe"},{"title":"Leetcode两数-四数之和题解","slug":"题解/Leetcode两数-四数之和题解","date":"2020-10-12T13:35:23.000Z","updated":"2020-12-05T04:44:00.942Z","comments":true,"path":"2020/10/12/题解/Leetcode两数-四数之和题解/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/%E9%A2%98%E8%A7%A3/Leetcode%E4%B8%A4%E6%95%B0-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%E9%A2%98%E8%A7%A3/","excerpt":"","text":"Leecode两数-四数之和题解最近两天做了两数之和，四数之和，并且之前也做过三数之和，感觉这几道题解法都差不多，并且用同样的方法能求解n数之和。 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解（哈希表）分析：利用哈希map，key存放数字，value存放索引，遍历数组，依次取一个数，然后计算出另外一个数，如果哈希map中存在，直接取出索引，返回结果，如果不存在，向哈希map中添加当前元素和对应的下标。 具体步骤如下：1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; // key存放数字，value存放index HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int i = 0; i &lt; nums.length;i++)&#123; int num2 = target - nums[i]; // 如果哈希map中存在当前数，直接返回i和当前数的下标 if(map.containsKey(num2))&#123; return new int[] &#123; map.get(num2), i &#125;; &#125;else&#123; // 将当前数放入哈希map map.put(nums[i],i); &#125; &#125; return null; &#125;&#125; 15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 题解（排序，双指针）分析：此题要求出三个数的和为0的结果集，则只需对原数组排序，然后从最小的数开始选，接着设置左右指针，如果当前三个数和为0，将这三个数加入结果集，继续寻找，如果当前三个数和大于0，右指针左移，小于0，左指针右移。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); //如果数组为空 或者长度小于三 直接返回空 if(nums == null || len &lt;3) return ans; //对数组排序 Arrays.sort(nums); for(int i = 0 ; i &lt; len;i++)&#123; //如果当前最小的数大于0，直接结束循环 if(nums[i] &gt; 0) break; //去重 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; //设置左右指针 int left = i + 1; int right = len - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[left] + nums[right]; if( sum == 0)&#123; ans.add(Arrays.asList(nums[i],nums[left],nums[right])); //左边元素去重 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; //右边元素去重 while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; //移动左右指针 left++; right--; &#125; if(sum &gt; 0) right--; if(sum &lt; 0) left++; &#125; &#125; return ans; &#125;&#125; 18. 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 题解（排序，双指针）分析：此题要求出四个数的和为target的结果集，则只需对原数组排序，然后将四数之和降为三数之和，接着设置左右指针，如果当前四个数和为target，将这四个数加入结果集，继续寻找，如果当前四个数和大于target，右指针左移，小于0，左指针右移，具体步骤见代码注释。 具体步骤如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); // 边界条件判断 if(nums == null || nums.length &lt; 4)&#123; return res; &#125; // 对原数组排序 Arrays.sort(nums); // 获取原数组长度 int l = nums.length; for(int i = 0; i &lt; l - 3; i++)&#123; // 去重 if( i &gt; 0 &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; // 如果当前数加上后面最小的三个数都比target大，直接跳出 if(nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target)&#123; break; &#125; // 如果当前数加上最大的三个数逗比target小，跳过当前数 if(nums[i] + nums[l - 3] + nums[l - 2] + nums[l - 1] &lt; target)&#123; continue; &#125; // 同上（n数之和直接重复此操作即可） for(int j = i + 1; j &lt; l - 2; j++)&#123; if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])&#123; continue; &#125; if(nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target)&#123; break; &#125; if(nums[i] + nums[j] + nums[l - 1] + nums[l - 2] &lt; target)&#123; continue; &#125; // 将n树之和转为两数之和 int left = j + 1; int right = l - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[j] + nums[left] + nums[right]; if(sum == target)&#123; // 加入结果集 res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); // 去重 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1])&#123; left++; &#125; left++; // 去重 while(left &lt; right &amp;&amp; nums[right] == nums[right - 1])&#123; right--; &#125; right--; &#125;else if(sum &gt; target)&#123; right--; &#125;else&#123; left++; &#125; &#125; &#125; &#125; return res; &#125;&#125; 由三数之和和四数之和可以得出n数之和的解法，思想是一样的，都是枚举，去重，再将最后两个数的和转换为双指针，降低时间复杂度","categories":[{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xmmarlowe.github.io/tags/Leetcode/"}],"author":"Marlowe"},{"title":"test","slug":"Java随笔/test","date":"2020-10-12T12:35:34.000Z","updated":"2020-12-02T15:04:50.067Z","comments":true,"path":"2020/10/12/Java随笔/test/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/Java%E9%9A%8F%E7%AC%94/test/","excerpt":"","text":"testhexohello,world!","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://xmmarlowe.github.io/tags/test/"}]},{"title":"我的第一篇博客","slug":"Java随笔/我的第一篇博客","date":"2020-10-12T12:20:20.000Z","updated":"2020-12-02T15:04:50.094Z","comments":true,"path":"2020/10/12/Java随笔/我的第一篇博客/","link":"","permalink":"https://xmmarlowe.github.io/2020/10/12/Java%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"我的第一篇博客记录一下最近使用hexo搭建的博客 &ensp;&ensp;周六晚上开始搭建，安装node、npm等等，碰到了一系列问题，换了一个主题后，总算把博客整体框架搭建好了，接着周日本是完整的一天，但早上九点多才起床，到实验室接近10点了，继续研究配置文件，以及主题的源代码，但是没啥效果，github有时候也抽风，就问了问学长,最后重新配置了仓库，总算解决了。&ensp;&ensp;周一中午开始研究上传到github以及自动部署脚本文件，到了晚上都没解决，最后才知道博客仓库只是部署编译出来的网站静态文件，如果想要使用github进行代码托管，只有新建一个代码库，把所有文件上传上去。脚本文件如下 12345678910111213@echo offD:cd D:\\PersonalFile\\HexoBlogecho &#39;start git sync&#39;git add .git add -Agit add -ugit commit -m &quot;update...&quot;git pull HexoBlog mastergit push HexoBlog mastercall hexo ghexo d","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://xmmarlowe.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"test","slug":"test","permalink":"https://xmmarlowe.github.io/tags/test/"},{"name":"随笔","slug":"随笔","permalink":"https://xmmarlowe.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://xmmarlowe.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/categories/Java/"},{"name":"题解","slug":"题解","permalink":"https://xmmarlowe.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/categories/JUC/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xmmarlowe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/categories/%E5%B9%B6%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"https://xmmarlowe.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"春招面试","slug":"春招面试","permalink":"https://xmmarlowe.github.io/categories/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95/"},{"name":"自定义工具类","slug":"自定义工具类","permalink":"https://xmmarlowe.github.io/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://xmmarlowe.github.io/categories/NoSQL/"},{"name":"学习方法","slug":"学习方法","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://xmmarlowe.github.io/categories/ElasticSearch/"},{"name":"环境配置之踩坑","slug":"环境配置之踩坑","permalink":"https://xmmarlowe.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B8%A9%E5%9D%91/"},{"name":"Java基础","slug":"Java基础","permalink":"https://xmmarlowe.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/categories/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://xmmarlowe.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"LeetCode题解","slug":"LeetCode题解","permalink":"https://xmmarlowe.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://xmmarlowe.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"搭建博客","slug":"搭建博客","permalink":"https://xmmarlowe.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xmmarlowe.github.io/tags/HTTP/"},{"name":"线程","slug":"线程","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://xmmarlowe.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"Cookie","slug":"Cookie","permalink":"https://xmmarlowe.github.io/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://xmmarlowe.github.io/tags/Session/"},{"name":"进程通信","slug":"进程通信","permalink":"https://xmmarlowe.github.io/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"Java","slug":"Java","permalink":"https://xmmarlowe.github.io/tags/Java/"},{"name":"对象","slug":"对象","permalink":"https://xmmarlowe.github.io/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"JVM","slug":"JVM","permalink":"https://xmmarlowe.github.io/tags/JVM/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://xmmarlowe.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"二叉树","slug":"二叉树","permalink":"https://xmmarlowe.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://xmmarlowe.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://xmmarlowe.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"dp","slug":"dp","permalink":"https://xmmarlowe.github.io/tags/dp/"},{"name":"TopK","slug":"TopK","permalink":"https://xmmarlowe.github.io/tags/TopK/"},{"name":"CAS","slug":"CAS","permalink":"https://xmmarlowe.github.io/tags/CAS/"},{"name":"ABA","slug":"ABA","permalink":"https://xmmarlowe.github.io/tags/ABA/"},{"name":"异步","slug":"异步","permalink":"https://xmmarlowe.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://xmmarlowe.github.io/tags/ForkJoin/"},{"name":"函数式接口","slug":"函数式接口","permalink":"https://xmmarlowe.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"},{"name":"GC","slug":"GC","permalink":"https://xmmarlowe.github.io/tags/GC/"},{"name":"DNS","slug":"DNS","permalink":"https://xmmarlowe.github.io/tags/DNS/"},{"name":"BTree","slug":"BTree","permalink":"https://xmmarlowe.github.io/tags/BTree/"},{"name":"B+Tree","slug":"B-Tree","permalink":"https://xmmarlowe.github.io/tags/B-Tree/"},{"name":"TCP","slug":"TCP","permalink":"https://xmmarlowe.github.io/tags/TCP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://xmmarlowe.github.io/tags/HTTPS/"},{"name":"OSI","slug":"OSI","permalink":"https://xmmarlowe.github.io/tags/OSI/"},{"name":"排序","slug":"排序","permalink":"https://xmmarlowe.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"AQS","slug":"AQS","permalink":"https://xmmarlowe.github.io/tags/AQS/"},{"name":"JUC","slug":"JUC","permalink":"https://xmmarlowe.github.io/tags/JUC/"},{"name":"原子类","slug":"原子类","permalink":"https://xmmarlowe.github.io/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"},{"name":"线程池","slug":"线程池","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"volatile","slug":"volatile","permalink":"https://xmmarlowe.github.io/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"https://xmmarlowe.github.io/tags/synchronized/"},{"name":"HashMap","slug":"HashMap","permalink":"https://xmmarlowe.github.io/tags/HashMap/"},{"name":"线程安全","slug":"线程安全","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"},{"name":"List","slug":"List","permalink":"https://xmmarlowe.github.io/tags/List/"},{"name":"I/O模型","slug":"I-O模型","permalink":"https://xmmarlowe.github.io/tags/I-O%E6%A8%A1%E5%9E%8B/"},{"name":"动态代理","slug":"动态代理","permalink":"https://xmmarlowe.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"JDK","slug":"JDK","permalink":"https://xmmarlowe.github.io/tags/JDK/"},{"name":"关键字","slug":"关键字","permalink":"https://xmmarlowe.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"Arrays","slug":"Arrays","permalink":"https://xmmarlowe.github.io/tags/Arrays/"},{"name":"Spring","slug":"Spring","permalink":"https://xmmarlowe.github.io/tags/Spring/"},{"name":"并发","slug":"并发","permalink":"https://xmmarlowe.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"异常","slug":"异常","permalink":"https://xmmarlowe.github.io/tags/%E5%BC%82%E5%B8%B8/"},{"name":"JWT","slug":"JWT","permalink":"https://xmmarlowe.github.io/tags/JWT/"},{"name":"辅助类","slug":"辅助类","permalink":"https://xmmarlowe.github.io/tags/%E8%BE%85%E5%8A%A9%E7%B1%BB/"},{"name":"Callable","slug":"Callable","permalink":"https://xmmarlowe.github.io/tags/Callable/"},{"name":"Redis","slug":"Redis","permalink":"https://xmmarlowe.github.io/tags/Redis/"},{"name":"redis","slug":"redis","permalink":"https://xmmarlowe.github.io/tags/redis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xmmarlowe.github.io/tags/SpringBoot/"},{"name":"Jedis","slug":"Jedis","permalink":"https://xmmarlowe.github.io/tags/Jedis/"},{"name":"事务","slug":"事务","permalink":"https://xmmarlowe.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"数据类型","slug":"数据类型","permalink":"https://xmmarlowe.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"学习","slug":"学习","permalink":"https://xmmarlowe.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"效率","slug":"效率","permalink":"https://xmmarlowe.github.io/tags/%E6%95%88%E7%8E%87/"},{"name":"工作方法","slug":"工作方法","permalink":"https://xmmarlowe.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95/"},{"name":"ES","slug":"ES","permalink":"https://xmmarlowe.github.io/tags/ES/"},{"name":"API","slug":"API","permalink":"https://xmmarlowe.github.io/tags/API/"},{"name":"Resuful","slug":"Resuful","permalink":"https://xmmarlowe.github.io/tags/Resuful/"},{"name":"踩坑","slug":"踩坑","permalink":"https://xmmarlowe.github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"Java基础","slug":"Java基础","permalink":"https://xmmarlowe.github.io/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面经","slug":"面经","permalink":"https://xmmarlowe.github.io/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"Swagger","slug":"Swagger","permalink":"https://xmmarlowe.github.io/tags/Swagger/"},{"name":"配置","slug":"配置","permalink":"https://xmmarlowe.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"注解","slug":"注解","permalink":"https://xmmarlowe.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"DI","slug":"DI","permalink":"https://xmmarlowe.github.io/tags/DI/"},{"name":"Bean","slug":"Bean","permalink":"https://xmmarlowe.github.io/tags/Bean/"},{"name":"IOC","slug":"IOC","permalink":"https://xmmarlowe.github.io/tags/IOC/"},{"name":"多线程","slug":"多线程","permalink":"https://xmmarlowe.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"list","slug":"list","permalink":"https://xmmarlowe.github.io/tags/list/"},{"name":"线程不安全","slug":"线程不安全","permalink":"https://xmmarlowe.github.io/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"},{"name":"锁","slug":"锁","permalink":"https://xmmarlowe.github.io/tags/%E9%94%81/"},{"name":"行为型模式","slug":"行为型模式","permalink":"https://xmmarlowe.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"策略","slug":"策略","permalink":"https://xmmarlowe.github.io/tags/%E7%AD%96%E7%95%A5/"},{"name":"Json","slug":"Json","permalink":"https://xmmarlowe.github.io/tags/Json/"},{"name":"Utils","slug":"Utils","permalink":"https://xmmarlowe.github.io/tags/Utils/"},{"name":"代理","slug":"代理","permalink":"https://xmmarlowe.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"结构型模式","slug":"结构型模式","permalink":"https://xmmarlowe.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"单例","slug":"单例","permalink":"https://xmmarlowe.github.io/tags/%E5%8D%95%E4%BE%8B/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://xmmarlowe.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"工厂","slug":"工厂","permalink":"https://xmmarlowe.github.io/tags/%E5%B7%A5%E5%8E%82/"},{"name":"模板","slug":"模板","permalink":"https://xmmarlowe.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"java","slug":"java","permalink":"https://xmmarlowe.github.io/tags/java/"},{"name":"插入排序","slug":"插入排序","permalink":"https://xmmarlowe.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"外观","slug":"外观","permalink":"https://xmmarlowe.github.io/tags/%E5%A4%96%E8%A7%82/"},{"name":"Docker","slug":"Docker","permalink":"https://xmmarlowe.github.io/tags/Docker/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xmmarlowe.github.io/tags/Leetcode/"},{"name":"test","slug":"test","permalink":"https://xmmarlowe.github.io/tags/test/"},{"name":"随笔","slug":"随笔","permalink":"https://xmmarlowe.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}